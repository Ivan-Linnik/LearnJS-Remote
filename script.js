"use strict"
/* некая директива - явная активация старого кода (пишется как строка - в кавычках)
влючает строгий режим (можно использовать отдельно в функции);
должна находиться в самом начале исполняемого кода, в противном случае,
директива будет игнорироваться. Над ней могут быть записаны только коммениарии.
Важно, что по умолчанию в devtools эта директива выключена. Но я могу использовать
многострочный ввод в консоль, и прописать её первой (при тестировании функций).
Иногда, когда use strict имеет значение, я могу получить неправильные результаты.
Если не работает, то:
(function () {
    'use strict';
    ...мой код
})() - и всё.
*/

//задачи после главы
//Работа с переменными
// let admin;
// let name;
// name = 'Джон';
// admin = name;
// alert(admin);
//Придумать правильные имена
//переменная для названия нашей планеты
// let ourPlanet = 'Earth';

//переменная для хранения имени текущего пользователя
// let currentUserName;

//Типы данных (сюда буду писать не всё)
//существуют: number, string, bigint,
//symbol, null, undefined, bollean, object.

//Использование BigInt
//Чтобы исаользовать большие числа, нужно добавить n в конце числа, вот так:
// let veryBig = 1000028768765656563333400n;
//Строка (string)
//можно использовать кавычки "", '', `` (обратные кавычки позволяют
//встраивать выражения в строку), вот так:
// let expression = 2 + 3;
// let result = `Результат вычисления: ${expression}`;
// console.log(result);

//Оператор typeof
//у него етсь две синтаксические формы
//синтаксис оператора typeof a
//синтаксис функции typeof(a)
//Результат одинаковый - он возвращает строку с именем типа данных.

//Взаимодействие: alert, prompt, confirm

//Преобразование типов
//чаще всего операторы и функции сами приводят значения к необходимому типу
//но иногда это нужно делать явно, итак:
//строковое преобразование String(value)
// let someNumber = true;
// console.log(`это переменная с типом ${typeof someNumber}`);
// console.log(`а теперь это та же переменная, но с типом ${typeof String(someNumber)}`);
// console.log('');
//численное преобразование - происходит неявно в мат. ф-ях и выражениях('12'/'4'=3),
//но есть явное преобразование Number(value)
// let myNumb = "437";
// console.log(`Итак, тип переменной сейчас ${typeof myNumb}`);
// console.log(`А теперь ${typeof Number(myNumb)}`);
// console.log('');
//если строка не может явно быть преобразована к числу, то рез-т NaN
//правила численного преобразования
//undefined - NaN, null - o, true/false - 1/0,
//пробельные символы (пробелы, знаки табуляции \t, новая строка \n и т.п.) по краям
//опускаются. Далее, если получается пустая строка, получаем 0, иначе из непустой строки
//считывается значение, иначе получаем NaN.

//Логическое преобразование - самое простое (ф-я Boolean(value))
//Правила преобразования: 0, пустая строка, undefined, null, NaN - false,
//все остальные - true.
// console.log(Boolean('hi'));
// console.log(Boolean(''));
// console.log('Заметим, что:')
// console.log(Boolean(0));
// console.log(Boolean('0'));

//Базовые операторы, математика (здесь будет не всё)
//взятие остатка от целочисленного деления - %, возведение в степень - **
// console.log(5%2); //1
// console.log(5**2); //25
//математически оператор работает и для нецелых чисел,
//например взятие квадратного корня a**(1/2), кубического a**(1/3)
// console.log(4 ** (1/2));
// console.log(8 ** (1/3));

//Сложение строк при помощи бинарного +
// console.log(1 + '21'); //если хотя бы один операнд строка - второй сразу становится строкой
// console.log('slozhil' + ' ' + 'stroku');
//здесь операторы будут работать один за одним
// console.log(2 + 2 + '1'); //41
// сложение и преобразование строк - это особенность бинарного плюса, остальные арифметические операторы работают только с числами,
//и всегда преобразуют операнды в числа. Например, вычитание и деление:
// console.log(4 / '2'); //2
// console.log('5' - 3); //2

//Приведение к числу - унарный +
//он не влияет никак на числа, даже если число отрицательное,
//т.е.: у = -2, значит +у = -2, а вот ниже унарный + выполнит преобразование
// let someN = true;
// let newSomeN = +someN;
// console.log(`До преобразования значение переменной было ${someN}, после преобразования стало ${newSomeN}`);
//на самом деле, это то же самое, что  и  Number(...), просто запись короче.
//необходимость преобразовать строки в числа возникает часто, например значения полей html формы, это почти всегда строки,
//так вот здесь нам поможет унарный +
// let apples = '1';
// let oranges = '2';

// console.log(`здесь я сложил только бинарным плюсом: ${apples + oranges}`); //12
// console.log(`а здесь унирными и бинарным: ${+apples + +oranges}`); 3
//сначала выполнятся унарные плюсы - приведение к числу, а затем бинарный.
//но есть ещё parseInt(expression/value) - лучше использовать его.

//Приоритет операторов
//у унарных операторов приоритет выше, чем у бинарных. Один из самых низких приоритетов
//у присваивания (=), это говорит о том, что сначала выполняется арифметика, и только потом результат присваивается переменной.
//присваивание возвращает значение, именно поэтому его можно использовать, как часть более сложного выражения:
// let a = 2;
// let b = 1;

// let c = 3 - (a = b -1);
// console.log(a);
// console.log(c);
//выше приведён странный пример, такое можно встретить в JS-библиотеках, самому такое писать не стоит. Это делает код менее понятным.

//Сокращённая арифметика с присваиванием
//часто нужно применить оператор к переменной и сохранить результат в ней же
//let n = 2; n = n + 5; n = n * 8 и т.д.
//можно сократить так: let n = 2; n += 5; n *= 8 и т.д. - это вызов с присваиванием.
//он имеет такой же приоритет, как и обычное присваивание.
//let n = 2; n *= 3 + 5 » здсь сначала выполнится правая часть, а потом вызов с присваиванием,
//т.е. n будет равно 16.

//Инкремент/декремент
//++ увеличивает на 1, -- уменьшает на 1. Можно примеять только к переменным.
//операторы ++ и -- могут быть расположены как до, так и после переменной.
//до - префиксная форма ++а возвращает новое значение, т.е. а+1=2 (если а было =1);
//после - постфиксная форма а++ возвращает предыдущее значение (до увеличения), т.е.
//если а = 1, то а++ вернёт 1. Получается, что они делают одно и то же, но выводят разные значения!
//Инкремент/декремент можно использовать в любых выражениях (также внутри выражений). Их приоритет выше, чем у любых других операторов.
// let counter = 1;
// console.log('Приоритет инкрементов/декрементов');
// console.log(2 * ++counter);
// counter = 1; //обнуление counter
// console.log(2 * counter++);
//но таких записей лучше избегть - можно пропустить при беглом чтении кода.
//писать лучше отдельное действие на отдельной строке.

//Побитовые операторы

//Оператор "запятая"
//редко применяется и является одним из самых необычных, иногда используется для написания
//более короткого кода. Он предоставляет возможность вычислять несколько выражений, разделяя их запятой.
//При этом возвращается результат только последнего выражения
// let q = (1 + 2, 3 + 4);
// console.log(q);
//первое вычисление выполняется, а результат отбрасывается, далее выполняется следующее, его рез-т возвращается.
//Запятая имеет очень низкий приоритет, ниже, чем присваивание (=). Поэтому скобки в примере важны.
//Этот оператор используют, чтобы записать несколько действий в одной строке. Во фреймворках тоже такие
//записи используются. Но такие записи не улучшают читаемость кода.
//одна из задач после раздела
// let aB = prompt("Первое число?", 1);
// let bA = prompt("Второе число?", 2);
//console.log(+aB + +bA); //здесь parseInt не сработал, сработал унарный плюс.

//Операторы сравнения (здесь будет не всё)
//равно в ДЖС обозначается, как == (= - это присваивание), не равно обозначается, как !=
//все опараторы сравнения возвращают значение логического типа (true/false). Результат можно присвоить переменной, как и любое значение.
// let w = 5 != 4;
// console.log(`А это результат сравнения, записанный в переменную - ${w}`);
//Сравнение строк
//чтобы определить, что одна строка больше другой ДЖС использует алфавитный и лексикографический порядок,
//другими словами - строки сравниваются посимвольно. Например
// let stroka1 = 'Привет';
// let stroka2 = 'Иван';
// console.log(`stroka1 bigger than stroka2 is: ${stroka1 > stroka2}`); //true
//используется unicode, а не настоящий алфавит. В ДЖС имеет значение регистр символов.
//Так заглавная А будет иметь меньшее значение, чем строчная а, потому что строчные буквы имеют больший код во внутренней
//таблице кодирования, которую использует ДЖС (Unicode)
//Сравнение разных типов
//при сравнивании значений разных типо JS приводит их к числу
// console.log('2' > 1); //true
// console.log('01' == 1); //true, 01 станет 1
// console.log(true == 1); //true
// console.log(false == 0); //true

//Строгое сравнение
//использование обычного сравнения == может вызвать проблемы. Например, оно не отличает
//0 от false 
// console.log(`обычное сравнение не отличает 0 от false: 0 == false  - ${0 == false}`);
//та же проблема и с пустой строкой
// console.log(`та же проблема и с пустой строкой '' == 0 - ${'' == 0}`);
//это происходит потому, что операнды разных типов преобразуются == к числу. Поэтому есть

//Оператор строго равенства ===
//он проверяет равенство без приведения типов, другими словами, если а и b имеют разные типы, то
//проверка а === b вернёт false
// let f = '123';
// let g = 123;
// console.log(`Строго сравню '123' и 123, вот - ${f === g}`);
// console.log('');
// console.log('Сравню null и undefined');
// console.log(`итак, строго - ${null === undefined} - потому что различны их типы`);
// console.log(`нестрого - ${null == undefined} - равны друг другу и не равны другим. Это специальное правило языка`);
//при использовании математических оператров и других операторов сравнения < > >= <= null и undefined преобразуются к числам:
//null становится 0, а undefined становится NaN.
//Странный результат сравнения null и 0
// console.log(null > 0 ); //false
// console.log(null == 0); //false
// console.log(null >= 0); //true
//причина в том, что нестрогое равенство (==) и сравнения (< > <= >=) работают по-разному
//сравнения преобразуют null в число, рассматривая его как 0, поэтому третья строчка будет true.
//с другой стороны, null==0 - false, потому что null==undefined, и не равно ни чему другому.
//undefined несравнимо с другими значениями
// console.log(undefined > 0); //false
// console.log(undefined == 0); //false
// console.log(undefined >= 0); //false

//Как избежать проблем? - следовать правилам:
// ! относиться с осторожностью к сравнениям с null/undefined, кроме случаев строгого равенства
// ! не использовать сравнения >=, <=, >, < с переменными, которые могут принимать значения null/undefined, разве что я
//полностью уверен в том, что делаю. Если переменная может принять эти значения, значит нужно сделать отдельную проверку для них.

//Условное ветвление: if, '?'
//Инструкция if (...) - вычисляет условие в скобках, и если результат true, выполняет блок кода.
//Пример (так писать не очень хорошо), нужны скобки, особенно, когда нужно выполнить несколько инструкций.
// let age = prompt('How old are you?', 'don\'t be a shy');
// if (age == 28) console.log('Ровесники');

// //лучше использовать всегда скобки, даже если инструкция будет одна. Это увеличивает читаемость кода.
// if (age == 28) {
//     console.log('Contemporary');
// }
//инструкция if вычисляет значнеие в скобках и преобразует результат к логическому типу,
//соответственно есть ложные (falsy) и правдивые (truthy) значения. При ложном значении код никогда не выполнится
//if (0) {
//     alert('nepravda')
// };,
// а при правдивом значении выполнится всегда
// if (1) {
//     alert('pravdivo')
// };
//я также могу передать заранее выполненное значение переменной, это удобно,
//если несколько условий - тогда можно каждое условие положить сразу в переменную, примерно так:
// let year = prompt("Input some year", "2022");
// let condition = (year == 2022);
// if (condition){
//     console.log('condition is ok');
// };

//Блок else
//нужен для действий, в случае если условие в блоке if ложно, используется так:
// let userGuesSomeThing = prompt('What is my age?', 'enter here');
// if(userGuesSomeThing == 28) {
//     console.log('Nice!');
// } else {
//     console.log('You are wrong!');
// };

//иногда нужно проверить несколько вариантов, тогда используется else if
// let guessAgainInput = prompt('How old am I?', 'nu sho');

// if (guessAgainInput < 28) {
//     console.log(`It has to be a little less - ${guessAgainInput}`);
// } else if (guessAgainInput > 28) {
//     console.log('It has to be a little much');
// } else {
//     console.log('Finally!');
// };

//Условный оператор "?"
//Его также называют тернарным оператором, т.к. он имеет три аргумента (он единственный в своём роде)

// let newAgeExample = prompt('How old are you?', '');
// let ternarExample = (newAgeExample >= 18) ? console.log('nice come in') : console.log('too small');
//первый аргумент - это условие (скобки в теории можно опустить, т.к. у тернарного оператора очень низкий приоритет)
//второй аргумент - это часть кода, которая вернётся в случае если условие истинно, третья - если ложно.

//Несколько операторов "?"
// let age = prompt('My age', '');

// let message = (age < 3) ? 'baby':
// (age <= 18) ? 'Hello':
// (age <= 100) ? 'You are old' : 'Stragne age';

// console.log(message);
//в примере выше код выполнится последовательно, если первое условие в скобках ложно, то выполнится клод дальше и так либо пока условие не будет правдиво,
//либо пока не закончится условие проверки, противном случает вернётся конструкция последней проверки (вторая часть, та что ложна).

//Нетрадиционное использоование "?"
//иногда тернарный оператор используется вместо конструкции if, но такая запись хуже читается, и рекомендуется использовать конструкцию if.
//напишу для примера
// let question = prompt('What is company created JavaScript', 'Netscape');

// (question == 'Netscape') ? console.log('yes') : console.log('no');
//Одна из задач после раздела
// let = qestionForUser = prompt('Какое официальное название Java Script?', 'ECMAScript');

// if (qestionForUser == 'ECMAScript') {
//     console.log("Верно");
// } else {
//     console.log("Неправильно");
// }

// let userNumberInput = prompt('Enter a number', 'Or not a number');
// let typeCast = Number(userNumberInput);

// if (typeCast > 0) {
//     console.log('1');
// } else if (typeCast < 0) {
//     console.log('-1');
// } else if (typeCast === 0) {
//     console.log('0');
// } else {
//     console.log('You wrote not a number');
// }

//Перепишите if в "?"
// let result;

// if (a + b < 4) {
//     result = 'Мало';
// } else {
//     result = 'Много';
// }
//  let result = (a + b < 4) ? 'Мало' : 'Много';

//перепешите if else в "?" с использованием нескольких операторов
// let message;

// if (login == "Сотрудник") {
//     message = 'Привет';
// } else if (login == "Директор") {
//     message = 'Здравствуйте';
// } else if (login == "") {
//     message = 'Нет логина';
// } else {
//     message = '';
// }

// let message = (login == 'Сотрудник') ? 'Привет' :
//     (login == 'Директор') ? 'Здравствуйте' :
//     (login == '') ? 'Нет логина' : '';

//Логические операторы
//Могут применяться к значениям любых типов
// ИЛИ || - при работе с булевыми значениями - если хотя бы одно из значений true - возвращает true.
//если значение не логического типа, то оно к нему приводится в целях вычислений, например 1 будет воспринято, как true, 0 - как false и т.п.
//обычно оператор || используется для проверки истинности любого из данных условий.
// let hour = 12;

// if (hour < 10 || hour > 18) {
//     console.log('Office is closed');
// }

// isWeekend = true;

// if (hour < 10 || hour > 18 || isWeekend == true) {
//     console.log('Office is closed');
// } else {
//     console.log('Office is open');
// }
//ИЛИ || находит первое истинное значение

// let result = value1 || value2 || value3
//расширенный алгоритм при выполнении ИЛИ с несколькими значениями работает так:
//оператор ИЛИ вычисляет операнды слева направо - каждый операнд конвертируется в логическое значение,
//если значение операнда true, то операция останавливается и возвращается исходное значение этого операнда,
//если все операнды являются ложными, то возвращается последний из них. Значение возвращается в исходном виде без преобразования.
//другими словами, цепочка ИЛИ возвращает первое истинное значение или последнее, если такое значение не найдено.
//Из нестандартных способов использования я знаю теперь (испоьзуется также в JS):

//1. получение первого истинного значения из списка переменных или выражений: допустим, у меня есть список переменных,
//которые могу принимать значения null или undefined, ок - а как мне найти среди них переменную с данными? - || ИЛИ, например
// let cuerntUser = null;
// let defaultUser = 'Ivan';

// let findName = cuerntUser || defaultUser || 'unnamed'; // выберется Ivan - первое правдивое значение, если первые две переменные были бы ложными,
//то в результате выявилось бы unnamed

//2. сокращённое вычисление - операндами может быть, как произвольные выражения, так и отдельные значение - ИЛИ || вычислит их слева направо.
//Вычисление остановится при достижении первого истинного значения. Поэтому этот процесс и называется сокращённым вычислением, ведь следующий этап
//вычисления выполнится (операнд вычислится), только если первого будет недостаточно для вычисления всего выражения
// let x;
// p = true || (x = 1);
// console.log(x);

// И && - находит первое ложное значение
//а при нескольких операторах И, result = value && value && value - он также как и ИЛИ вычисляет выражения слева направо,
//каждый операнд преобразуется в логическое значение, если результат фолс - останавливается и возвращается исходное значение этого операнда.
//если все операнды были истинными - возвращается значение последнего операнда.
// let someVarResult = 56 && 'string' && null && 0; // вернётся null
// 55 && 34 && true && 23 - вернётся 23, потому что все истинные значения
//Приоритет И && выше, чем у ИЛИ ||, также как и ИЛИ оператор И может заменять if, например
// let x = 1;
// (x > 0) && console.log('Greater than zero');
//но, как и ранее - лучше использовать if

// ! НЕ
//синтаксис такой - result = !value
//оператор НЕ сначала приводит значение к логическому типу, затем возвращает его противоположное значение. Например
// let operatorNe = true;
// console.log(!operatorNe);
//Двойное НЕ часто используется для преобразования значений к  логическому типу
// console.log(!!'not empty string'); //true
// console.log(!!null); //false
//Получается, что первое НЕ преобразует значение в логическое и возвращает обратное, а второе НЕ снова инвертирует его.
//Тоже самое делает ф-я Boolean('not empty string').
//Приоритет НЕ является наивысшим среди логических операторов, поэтому он всегда выполняется первым, перед && и ||.
//Задачи после раздела
// console.log(null || 2 || undefined);
// alert(alert(1));
//- написать код, который проверяет, находится ли значение в диапазоне между 14 и 90 включительно.
// let age = prompt('Enter some age', '28');

// if (age >= 14 && age <= 90) {
//     console.log('The value is in the range');
// } else {
//     console.log('The value is not in the range');
// }

//написать код для проверки, что значение переменной не находится в диапазоне от 14 до 90 включительно
//два варианта - первый с использованием НЕ, второй без этого оператора

// let age = prompt('Value', '28');
// //первый вариант
// if (!(age >= 18 && age <= 90)) {
//     console.log('I - The value is not in the range');
// } else {
//     console.log('I - The value is in the range');
// }
// //второй вариант
// if (age < 18 || age > 90) {
//     console.log('II - The value is not in range');
// } else {
//     console.log('II - The value is in range');
// }
//Проверка логина
// let userInputLogin = prompt('Enter your login', '');

// if (userInputLogin === 'Admin') {
//     let adminPassword = prompt('Enter password', '');

//     if (adminPassword === 'Imincharge') {
//         alert('Zdravstvuyte');
//     } else if (adminPassword === '' || adminPassword === null) {
//         alert('Canceled');
//     } else {
//         alert('Wrong password');
//     }

// } else if (userInputLogin === '' || userInputLogin === null) {
//     alert('Canceled');
// } else {
//     alert('I don\'t know who you are');
// }

//Оператор нулевого слияния "??"
//он обрабатывает null undefined одинаковым образом. Для текущей статьи в учебнике автор ввёл понятие - 
//значение "определено", если оно не равно null или undefined.
//Результат выражения a ?? b будет таким:
//если a определено, то a; если a не определено, то b.
//Иначе говоря, оператор ?? возвращает первый аргумент, если он не null или undefined, иначе возвращает второй.
//вот так можно переписать выражение result = (a != null && a != undefined) ? a : b
// result = a ?? b
//в этом примере я отображу имя пользователя, если оно "определено", в противном случае - аноним.

//Сравнение || и ??
//Основное различие заключается в том, что || не различает false, 0, пустую строку, undefined, null - для него это одно и то же - ложное,
//то есть он выводит первое "истинное" значение, а оператор нулевого слияния выведет первое "определённое", т.е. не null/undefined.
//В учебнике, в пользу ?? описан кратко пример с нулевой высотой.
//Приоритет у ?? и || одинаковый, он выше, чем у тернарного оператора и присваивания, но ниже, чем у +-* и тд, поэтому нужны скобки.
//Запрещено использовать ?? вместе с || ИЛИ, && И, если приоритет явно не указан в виде скобок.

//Циклы while и for
//Циклы нужны для многократного повторения одного участка кода
//While имеет синтаксис:
// while (condition) {
//код - "тело" цикла
//} // пока истинно условие тело цикла будет выполняться
// let someVar = 1;

// while (someVar <= 10) {
//     console.log(`Это значение переменной someVar: ${someVar}`);
//     someVar++;
// }
//Любое значение или переменная может быть условием цикла, условие while вычисляется и преобразуется в логическое значение
//например while (i) - более краткий вариант записи while  (i != 0) ->
// let i = 3
//  while (i) {
//     console.log(i);
//     i--;
// }
//Фигурные скобки не требуются для тела цикла из одной строки, т.е. while (i < 3) console.log(i++);

//Цикл do...while - отличается тем, что сначала выполнится тело цикла, а потом проверка условия.
// let i = false;
// do {
//     console.log(i);
// } while (i);
//это иногда нужно для того, чтобы выполнить хоть раз код при любом условии.

//Цикл for
//for (начало; условие; шаг), начало - выполняется один раз при входе в цикл; условие проверяется перед каждой
//итерацией цикла, если условие вычислится в false - цикл остановится; тело - выполняется, пока условие true;
//шаг - выполняется после тела цикла на каждой итерации перед проверкой условия.
// for (let i = 3; i >= 0; i--) {
//     console.log(i);
// }
//переменная, объявленная в пределах цикла, доступна только в пределах цикла. Можно не объявлять переменную внутри цикла, а использовать объявленную ранее.

//Прерывание цикла break
//обычно цикл завершается после того, как условие вычисляется в false, но бывает, когда нужно
//досрочно прервать выполнение цикла, для этого есть директива break.
// let sum = 0;
//  while (true) {
//     let value = +prompt('Enter a nuber', '');
//     if (!value) break;
//     sum += value;
//  }
//  console.log(`Уже столько ${sum}`);
//в примере выше директива break прекращает выполнение цикла и передаёт управление нас троку за его телом (527).

//Переход к следующей итерации : continue
//это облегчённая версия break, она не прерывает выполнение цикла, а переходит к следующей итерации, если условие всё ещё true.
//ниже я выведу только чётные значения, потому что континуе прервёт каждую итерацию, которая вернёт чётное число.
// let i = 0;
// for (i = 0; i < 6; i++) {
//     if (i % 2 == 0) continue;
//     console.log(i);
// }
//в примере выше continue помог избежать вложенности (она усложняет читаемость кода). Ниже напишу код со вложенностью
// let i = 0;
// for (i = 0; i < 6; i++) {
//     if (i % 2 == 0) {
//         console.log(i);
//     }
// }
//НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ break/continue c ? (тернарным оператором), т.к. эти синтаксические конструкции не являются выражениями. Такое использование вызовет ошибку.
//Метки для break/continue
//бывает так, что мне нужно выйти одновременно из нескольких уровней цикла сразу - допустим, мне нужно пройтись по i и j,
// запрашивая с помощью prompt координаты i и j с 0, 0 до 2, 2.
// for (let i = 0; i < 3; i++) {
//     for (let j = 0; j < 3; j++) {
//         let inputCoordinates = prompt(`Enter coordinamtes (${i}, ${j})`, '');
//     }
//что если я хочу перейти к done прямо отсюда?
// }
// console.log('Done');
// мне нужен способ остановить выполнение, если пользователь отменит ввод.
//break после input лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого можно при помощи меток.
// Метка имеет вид идентификатора с двоеточнием перед циклом.
// labelName: for (...) {...}. Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
// myLabel:for (let i = 0; i < 3; i++) {
//     for (let j = 0; j < 3; j++) {
//         let inputCoordinates = prompt(`Enter coordinates (${i}, ${j})`, '');

//         if (!inputCoordinates) break myLabel;
//         console.log(i, j);
//     }
// }
// console.log('Done');
//в примере выше описано, что вызовом break myLabel будет разорван внешний цикл до метки с именем myLabel. Таким образом, управление перейдёт на стр 568.
//директива continue также может быть использована с меткой. Важно, что метки не позволяют прыгнуть в любое место кода.
//были задачи на инкременты и то, как работают циклы, далее вывод чётного значения, замена for на while.

// Напишите цикл, который предлагает prompt ввести число, большее 100 . Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
// Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100 , либо не нажмёт кнопку Отмена (ESC).
// Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.
//ЭТО МОЁ РЕШЕНИЕ
// let userInput = parseInt(prompt ('Enter number bigger than 100'), 10);

// while(userInput <= 100) {
//     userInput = parseInt(prompt ('Try again', ''), 10);

//     if (userInput > 100 || !userInput) break;
//  }
//  console.log('Done!');
//ЭТО РЕШЕНИЕ ПО КНИГЕ
// let userInput;
// do {
//     userInput = prompt ('Enter number bigger than 100', '');
//     console.log('Nice');
// } while (userInput <= 100 && userInput);

//Напишите код, который выводит все простые числа из интервала от 2 до n . Для n = 10 результат должен быть 2,3,5,7 .
// P.S. Код также должен легко модифицироваться для любых других интервалов.
// let n = 10;

// stopLabel:
// for (let i = 2; i <= n; i++) {
//     for (let j = 2; j < i; j++) {
//         if (i % j == 0) continue stopLabel;
//     }
//     console.log(`prime number ${i}`);
// }

//Конструкция switch
//она заменяет собой несколько if, позволяет наглядно сравнить выражение сразу с несколькими вариантами
//имеет не менее одного блока case и необязательный блок default, который выполнится в случае, если все условия в констукции ложны.
// let d = parseInt(prompt('Угадай число', ''), 10);

// switch(d) {
//     case 1:
//         console.log('Это очень мало, давай дальше');
//         break;
//     case 2:
//         console.log('Кейс 2, всё ещё мало');
//         break;
//     case 3:
//         console.log('Это оно');
//         break;
//     default:
//         console.log(`Эта часть кода выполнится по-любому.\nТы ввёл ${d}, но такого значения нет в списке проверок.`)
// }
//если убрать break, то выполнение пойдёт ниже по следующим кейсам.
// !Любое выражение может стать аргумантом для switch/case? типа switch(a + b)...case i >= j:...
//Группировка case
// let a = +prompt('Угадай число', '');

// switch (a) {
//     case 1:
//     case 2:
//     case 3:
//         console.log(`Группировка case. Всё от 1 до 3 включительно - хуета`);
//         break;
//     case 4:
//         console.log('Молодец, правильно');
//         break;
//     case a > 4:
//         console.log('Это больше');
//         break;
//     default:
//         console.log('Default');
// }
//Проверка на равенство всегда строгая, значения должны быть одного типа, чтобы выполнялось равенство.

//Функции
// let myName = 'Ivan';

// function changeName() {
//    let myName = 'name from function';
//     console.log('Hi, I\'m ' + myName);
// }

// changeName();
// console.log('Now my name is ' + myName);

//функции могут использовать глобальные переменные, могут изменять их значение. А если внутри функции объявлена переменная
//с таким же именем, как и глобальная, то функция будет использовать локальную для себя переменную, а значение глобадльной
//будет проигнорировано.

//Аргументы фунции
// function message (from, text) {
//     console.log(from + ': ' + text);
// }
// message('Ivan', prompt('write something', ''));
// function message (from, text) {
//     from = '*' + from + '*';
//     console.log(from + ': ' + text);
// }

// let from = 'Ivan';

// message(from, 'Привет');
//значение, передаваемое в качестве параметра ф-ции также является аргументом, другими словами - 
//параметр - переменная, указанная в круглых скобках в объявлении ф-ции, аргумент - значение, которое передаётся ф-ции при её вызове.
//т.е., я объявляю функцию со списком параметров, а вызываю её передавая аргументы.

//Параметры по умолчанию
//Если прамент не указан, его значением становится undefined. Та же ф-я message может быть вызвана с одним аргументом, ошибки не будет,
//просто второй параметр будет undefined

// function message (from, text) {
//     from = '*' + from + '*';
//     console.log(from + ': ' + text);
// }

// message ('Иван');

//В вызове не указан парметр text, поэтому подразумевается, что text === undefined. Если я хочу задать text параметр по умолчанию,
//то мне нужно указать после =:
//  function message (from, text = 'параметр по умолчанию') {
//     text = prompt('enter message', '') ?? 'параметр по умолчанию';
//      console.log(from + ': ' + text);
//  }
//  message('Ivan');
// в качестве параметра по умолчанию можно также передавать более солжные конструкции, например другую функцию - 
//function message(from, text = someFunction()) {...}; someFunction передастся тлько если не передан text.
//в JS параметры по умолчанию вычисляются каждый раз, когда ф-я вызывается без соответствующего параметра.

//Возврат значения
// function checkAge (age) {
//      if(age >= 18) {
//          return true;
//       } else {
//           return confirm('Do you schenok?');
//         //   return false;
//       }
// }

//  let age = +prompt('input age', '');

// if (ageCheck(age)) {
//     console.log('acces allowed');
// } else {
//     console.log('acced denided');
// }
//return можно также использовать и без значения, в таком случае происходит немедленный выход из функции. Например:
// function showMovie (age) {
//     if(checkAge === null || checkAge === undefined) {
//         return;
//     }
//     console.log('Showing movie');
// }
//Результат ф-ции с путсым return или без него === undefined. Если ф-я не возвращает значения,
//то это всё равно, как если бы она возвращала undefined.
//еслия хочу, чтобы возвращаемое выражение знимало несколько строк, то мне нужно начать его
//на той же строке, что и return или хотя бы поставить на той же строке открывающую скобку:
//return (
//     some + long + expression
//     + or + 
//     whatever * f(a) * f(b);
// )
//каждая отдельная функция должна выполнять что-то одно, либо только проверять, либо только присваивать
//и т.д. Имя функции обычно состоит из глагольного префикса и к чему он применяется - calcSum.
//обычно в командах разработчиков договариваются конкретно о нейминге ф-й.
//получается, что когда функции используются грамотно, а также правильно именуются, гораздо
//проще читать и тестить/отлаживать код, ф-я как бы становится комментарием.

//ЗАДАЧИ ПОСЛЕ РАЗДЕЛА
//Перепишите функцию, используя оператор '?' или '||'
// function checkAge(age) {
//     if (age > 18) {
//     return true;} else {
//     return confirm('Родители разрешили?'); }
//     }

// checkAge(18);

// function checkAge (age) {
//  return (age > 18) ? true : confirm('Did your parents allow?');
// return age > 18 || confirm('Did your parents allow?');
// }

// checkAge(18);
//написать ф-ю, которая возвращает меньшее из чисел

// function showLesser(a, b) {
//     if (a < b) {
//         return a;
//     } else if (b < a) {
//         return b;
//     }
//     return 'Equal';
// }
// console.log(showLesser(3, 3));

//(стр. 105) Написать ф-ю, которая возвращает x в степени n. Иначе говоря, умножает x на себя n раз и возвращает результат.
//например pow(3, 3) = 3 * 3 * 3 = 9;
//Создать страницу, которая запрашивает x и n, а затем выводит результат pow(x, n).
//П.С. В этой задаче функция обязана поддерживать только натуралные значения n, т.е. целые от 1 и выше.
// function pow(x, n) {
//     let result = x;

//     for(let i = 1; i < n; i++) {
//         result *= x;
//     }
//     return result;
// }
//  let x = +prompt('x ?','');
//  let n = +prompt('n ?', '');

// if (n < 1 || n % 1 === 0) {
//     console.log('нужно натуральное целое значение')
// } else {
//     console.log(pow(x, n));
// }

// Function Expression
// let someVar = function() {
//     console.log('I\'m function expression');
//     return 'return';
// };//примечательно, что после ф-экспрешн нужна ;
// console.log(someVar());
//функция по сути, это значение, и я могу работать с ней, как с любым другим значением.
// В примере выше, указав переменную с функцией, то есть экспрешн в строчном выводе - я просто
// получил код этой функции, а вызвав её со скобками я инициирую её код, как бы я просто вызвал функцию.
//я также могу скопировать ф-ю в другую переменную
// let a = someVar;
// a();
//или так
// function sayHi() {
//     console.log('Saying hi');
// }

// let b = sayHi;
// b();

//Функции-"колбэки"
// function ask(question, yes, no) {
//     if(confirm(question)) yes();
//     else no();
// }

// function yes() {
//     console.log('You\'re agree');
// }

// function no() {
//     console.log('You aren\'t agree');
// }

// ask('Do you agree?', yes, no);
//что получается, получается, что колбэк, это ф-я, передаваемая в качестве аргумента другой
//функции и вызываемая позже, после наступления того или иного события. В моём случае, yes() - 
//это колбэк для ответа yes.
//я могу переписать этот пример короче при помощи function expression
// function ask(question, yes, no) {
//     if(confirm(question)) yes();
//     else no();
// }

// ask(
//     'Вы согласны?',
//     function() {console.log('Я согласен')},
//     function() {console.log('Я не согласен')}
// );
//получается, что я в качестве значений передал две анонимные ф-ции (у них нет имён),
//они недоступны снаружи ask, потому что они не присвоены переменным - это то, что мне нужно.
//Получается, что функции - это значения, передающие действия. Обычные значения, как строки, числа
//передают данные, а функции можно воспринимать, как действие. Я могу передавать их в переменную
//и вызывать, когда захочу.
//Одним из ключевых отличий (помимо синтаксиса) между Function expression и Function Declaration
//то, что expression нельзя вызвать до непосредственно строки объявления ф-ции, а declaration можно.
//Это связано с тем, как движок JS парсит код - он сначала создаёт функции, объявленные при
//помощи declaration, как бы инициализируя их предварительно, expression инициализируется только
//после того, как движок дойдёт до самой строчки, где объявляется expression.
//В строгом режиме, когда Function Declaration находится в блоке {...}, ф-я
// доступна везде внутри блока, но не снаружи него, т.е.:

// let age = prompt("Сколько Вам лет?", 18);
// let welcome;
// // в зависимости от условия объявляем функцию
// if (age < 18) {
//     function welcome() { alert("Привет!");
//     }} else {
//     function welcome() { alert("Здравствуйте!");
//     }}
// // ...не работает
// welcome(); // Error: welcome is not defined

// чтобы welcome() была доступна снаружи if нужно использовать объявление функции
// при помощи function expression

// let age = 16;
// let welcome;

// if (age < 18) {
//     welcome = function() {
//         console.log('Привет');
//     };
// } else {
//     welcome = function() {
//         console.log('Здравствуйте');
//     };
// }

// welcome();
//это можно упростить, используя условный оператор (тернарный)
// let age = 18;
// let welcome = (age < 18) ? 
//     function() {console.log('Привет');}:
//     function() {console.log('Здравствуйте');};

// welcome();
//Function Expression нужно использовать преимущественно тогда, когда мне нужно условное
//объявление, как в примере выше, в остальных случаях лучше использовать Function Declaration.

//Стрелочные функции, основы
// let sum = (a, b) => a + b; //пример стрелочной ф-ции
// console.log(sum(2, 3));
//это то же самое, что и function sum(a, b) {
//     return a + b;
// }

// let double = n => n * 2; //пример без скобок
// console.log(`arrow double with no brackets equal ${double(3)}`);

// let noArgsArrow = () => console.log('No args aroow func'); //пример без аргументов
// noArgsArrow();

//их можно использовать также, как и Function Expression
// let age = 21;
// let welcome = (age > 18) ?
//     () => console.log('Здравствуйте'):
//     () => console.log('Привет');

// welcome();

//Многострочные стрелочные функции
//если мне нужна более сложная стрелочная функция, то мне нужно будет использовать фигурные
//скобки и return - его использование становится обязательным с появление фигурных скобок
// let sumMultiString = (a, b) => {
//     let result = a + b;
//     return result;
// }
// console.log(sumMultiString(2, 3));

//В итоге - главная цель стрелочных ф-ций (пока что) - это краткость. Я могу их использовать
//в качестве колбэков или простых однострочных действий.

//Отладка
//Условная точка останова - брейкпоинт, который ставится ПКМ на нужной строке. Эта точка сработает (т.е. выполнение кода остановится),
//если выражение, которое я укажу при создании этой точки истинно.
//Это удобно, когда мне нужно остановиться только при определённом параметре ф-ции.
//Команда debugger - пишется прямо в файл скрипта Она не сработает, если не открыты инструменты разработчика.
//Линтеры - автоматизированные средства проверки кода. Они проверяют стиль кода и могут вносить предложения по его улучшению.

//Объекты - используются для хранения коллекций различных значений и более сложных сущностей.
//Объект может быть создан при помощи {}. Данные внутри объекта - пара "ключ : значение"
//  let myNewObject = {
//     name : 'Ivan',
//     age : 28,
//     isHuman : true,
//  };
//Пустой объект можно создать при помощи одного из двух вариантов синтаксиса:
//конструктор объекта: let user = new Object();
//литерал объекта (литеральная нотация): let user = {}; - используется чаще всего
//Для обращения к свойствам используется запись через точку

// console.log('Получаю значение свойстd объекта - ' + myNewObject.name);
// myNewObject.lastName = 'Linnik';
// console.log('Добаввил ещё одно свойство со значением, а ниже вызвал сам объект с его свойствами');
// console.log(myNewObject);
// delete myNewObject.isHuman;
// console.log('Удалил свойство и ниже снова вызову объект');
// console.log(myNewObject);
// myNewObject['some feature'] = 'something';//имя свойства с пробелом - поэтому вызов через квадратные скобки.
// console.log(myNewObject);

//Объект, объявленный как константа может изменяться. Это связано с тем, что
//const защищает от изменений только переменную, а не её содержимое, т.е., если я в myNewObj положу например "Привет" - будет ошибка.

// const newObj = {
//     name : 'Viktoria',
//     lastName : 'Marakhovskaya',
// };
// console.log(`lastName до изменения: ${newObj.lastName}`);
// newObj.lastName = 'Linnik';
// console.log(`lastName после изменения: ${newObj.lastName}`);

//Вызов свойств объекта при помощи квадратных скобок является универсальным, и позволяет взаимодействовать с любыми ключами, а
//точечная нотация требует, чтобы ключи именовались по правилам именования переменных - не начинались с цифры, без пробелов и т.д.
//квадратные скобки также дают возможность обратиться к свойству, имя которого может быть результатом выражения. В примере из книги имя
//свойства хранится в переменной
// let user = {
//     name : 'Ivan',
//     gender : 'male',
// };

// console.log(user);

// let key = prompt('enter something', 'likes birds');
// user[key] = true;

// console.log(user);
// console.log(`Интересно - доступ к значению ключа. Точечная нотация так не умеет. Только квадратные скобки.
//             А вот и значение: ${user[key]}.
//             Точечная нотация вернула андефайнед.
// `);

//Вычисляемые свойства
//Я могу использовать квадратные скобки для создания вычисляемого свойства в литеральной нотации

// let fruit = prompt('what a...', 'apple');

// let bag = {
//     eggs : 10,
//     [fruit + 'Computers'] : 5,
// };

// console.log(bag);
//Свойства из переменной
// Зачастую необходимо использовать существующие переменные как значения для свойств с тем же именем

// function makeUser(name, age) {
//     return {
//         name : name,
//         age : age,
//     };
// }

// let user = makeUser('Ivan', 28);
// console.log(user);
// console.log(user.name);
// console.log(user.age);
//в примере выше названия свойств name и age совпадают с названиями переменных,
// которые я подставляю в качестве значений этих свойств. Для этого есть специальные короткие свойства для упрощения этой записи

// function makeUser(name, age, isHuman) {
//     return {
//         name,
//         age,
//         isHuman : true, //здесь я показал, что могу использовать обычные и короткие свойства
//     };
// }

// let user = makeUser(prompt('name is...', 'Ivan'), +prompt('age is...', 28));//а это фанкшн экспрешн
// let humanCheck = user.isHuman ? 'человек' : 'хуй пойми что';// а здесь я просто вспомнил про тернарный оператор

// console.log(`пользователь ${user.name}, ему ${user.age} лет и он ${humanCheck}`);

//Ограничений на имена свойств нет, свойства можно называть даже зарезервированными словами лэт, фор, ретёрн 'for : 5'.
//С другой стороны, что бы не ввёл пользователь в качестве ключа значнеия - это будет преобразовано к строке, если он
// ввёл 0 : 'hello', значит это будет '0' : 'hello'.

//Проверка существования свойства. Оператор "in".
//Её можно выполнить так
// let user = {
//     name : 'Ivan',
//     age : 28,
// };
// console.log(user.noSuchProperty === undefined);//true
// console.log(user.name === undefined);//false
//Также наличие свойства в объекте можно проверить при помощи оператора in
// let user = {
//     name : 'Ivan',
//     age : 28,
// };

// console.log('age' in user);//указано в кавычках
//если я опущу кавычки, значит, что я указываю переменную, в которой находится имя свойства:
// let user = {age : 30};
// let key = 'age';

// console.log(key in user);
//Оператор in мне нужен для того, чтобы когда свойство сущесвует, но имеет значение undefined.
//В таком случае проверка выполнится неправильно. Вот, как это может быть:
// let user = {
//     test : undefined,
//     name : 'Ivan',
// };

// console.log(user.test);//само значение свойства
// console.log(user.test === undefined);//хуёвая проверка пишет true - не правда
// console.log('test' in user);//пишет true - правда

//Цикл for...in - используется для перебора всех свойств объекта, вот так
//for (key in object) {
//выполнится для каждого свойства объекта
// }
// let user = {
//     name : 'Vika',
//     age : 31,
//     isHuman : true,
//     gender : 'woman',
// };

// for (let prop in user) {
//     console.log(`ключ ${prop} и его значение ${user[prop]}`);
// }
//обратиться к ключу - prop, обратиться к значению user[prop]

//Упорядочивание свойств объекта
//свойства внутри объекта упорядочены особым образом: свойства с целочисленными ключами
//сортируются по возрастанию, остальные - располагаются в порядке создания.

// let codes = { 
//     49 : 'Германия',
//     '41' : 'Швейцария',
//     '44' : 'Великобритания',
//     //..,
//     '1' : 'США',
// };

// for (let code in codes) {
//     console.log(+code, +code + ' : ' + codes[code]);//вывел номера в порядке возрастания
// }//тут ещё момент, если хочу получить число именно как число, то не стоит использовать
//сложение со строкой, т.к. на выходе я из числа получу строку.

//так вот, целочисленные свойства, это когда строка может быть преобразована в число и обратно
//без изменений '49' - такое свойство, а вот '+49' - уже нет.
//Интересно ещё, что ключ объекта всегда возвращает строку, не зависимо от того, что в него
//изначально передали.

//Встроенная ф-я, которая удаляет десятичную часть Math.trunc
//так мне показали что такое целочисленные свойства
// console.log(`Удалю десятичную часть 49:  ${
//     String(Math.trunc(Number('49')))
// }`);
// console.log(`Удалю десятичную часть +49: ${
//     String(Math.trunc(Number('+49')))
// }`);
// console.log(`Удалю десятичную часть 1.2: ${
//     String(Math.trunc(Number('1.2')))
// }`);

// let codes = { 
//     49 : 'Германия',
//     '41' : 'Швейцария',
//     '44' : 'Великобритания',
//     //..,
//     '1' : 'США',
// };

// for (let code in codes) {
//     console.log(+code, codes[code]);//вывел номера в порядке возрастания
// }

// console.log('а что если нужно вывеcти ключи для жителя Германии');
// console.log(`добавить плюс передкаждым значением, чтобы сделать
// код нецелочисленным
// `);

// let codes2 = { 
//     '+49' : 'Германия',
//     '+41' : 'Швейцария',
//     '+44' : 'Великобритания',
//     //..,
//     '+1' : 'США',
// };

// for (let code in codes2) {
//     console.log(+code, codes2[code]);//вывел номера в порядке возрастания
// }
// console.log(`это сработало, потому что если ключи нецелочисленные,
// то они перебираются в проядке создания`);

//Некоторые задачи
//ф-я, которая возвращает true, если у объекта нет свойств
//  let user = new Object();

//  function isEmpty(Object) {
//     //если цикл найдёт хоть одно значение - вернётся false
//     for (let key in Object) {
//         return false;
//     }
//     return true;
//  }
// //проверил
//  console.log(isEmpty(user));
//  user.name = 'Ivan';
//  console.log(isEmpty(user));



//Написать код, который суммирует все зарплаты команды
// let salaries = {
//     John : 100,
//     Ann : 160,
//     Pete : 130,
// };

// let sum = 0;

// for (let personalSalary in salaries) {
//     sum += salaries[personalSalary];
// }
// console.log(sum);

//Создать ф-ю, которая умножает все числовые свойства объекта на 2
//ф-ции ничего не нужно возвращать, только напрямую изменять объект. Использовать type of
//для проверки типа объекта
//  let menu = {
//     width : 200,
//     height : 300,
//     title : 'My menu',
//  };

// console.log(menu);

//  function multiplyNumeric(obj) {
//     for (let key in obj) {
//         if (typeof obj[key] == 'number') {
//             obj[key] *= 2;
//         }
//     }
//  }

// multiplyNumeric(menu);

//  console.log(menu);

//Копирование объектов и ссылки
//Важно - в отличие от примитив, объекты хранятся и копируются по ссылке. Примитивы же
// копируются, как целые значения.
//То есть, присвоение объекта переменной по сути является передачей ссылки на объект, а не
//передачу самого объекта, сам же объект хранится где-то в памяти. На один объект может
// быть несколько ссылок. Собственно при копировании объекта копируется только ссылка, а не
//сам объект не дублируется. После копирования изменять объект можно через любую из переменных.

//Сравнение по ссылке
//Два объекта равны, только если это один и тот же объект.
// let user = {};
// let huyuser = user; -> user == huyuser;//true
// let neuser = {}; -> user == neuser;//false
//Для сравнений типа obj1 > obj2 или obj == 5 объекты преобразуются специальным образом,
//но мне пока это не нужно, да это и в целом не нужно. Такие сравнения, как правило - ошибка программиста.

//Клонирование и объединение Object.assign
//Чтобы создать независимую копию, нужно создать новый объект и передать ему
// всю структуру существующего. В JS нет для этого встроенного метода.
// let user = {
//     name : 'Ivan',
//     age : 28,
// };
// let clone = new Object ();

// console.log(user);

// for (let key in user) {
//     clone[key] = user[key];
// }
// clone.name = 'Vika';
// // delete clone.age;
// console.log(clone, 'age' in clone);

//Также для этого можно использовать метод Object.assign
// let user = {
//     name : 'Ivan',
//     age : 28,
// };

// let user2 = {
//     $name: 'Vika',
//     $age: 31,
// };

// console.log(user);

// let sameUser = {};

// Object.assign(sameUser,user, user2);

// console.log(sameUser);

//если у свойств одинаковые имена - они будут перезаписаны.
//получается, что я могу исопльзовать Object.assign для простого клонирования вместо for..in.

//Вложенное клонирование
//что делать если свойства объекта не являются примитивами?
// let user = {
//     name : 'Ivan',
//     age : 28,
//     sizes : {
//         width : 65,
//         height : 165,
//     },
// };

// console.log('the whole object user->', user);
// console.log('current feature user->', user.sizes.width);

//получается, что теперь недостаточно скопировать объект так clone.sizes = user.sizes, потому
//что user.sizes это объект, и он будет скопирован по ссылке, и clone и user будут иметь общий
//объект.

//чтобы это исправить, мне нужно использовать цикл клонирования, который будет проверять
//каждое значение user[key], и если это объект, то также будет копировать его структуру.
//Это называется глубоким клонированием. Также можно использовать готовые реализации
//_.cloneDeep(obj) из библиотеки JS lodash.

//Методы объекта this


// let user = {
//     name : 'Ivan',
//     age : 28,
// };
//научу объект здороваться при помощи метода sayHi
// user.sayHi = () => console.log('Hello, my name is', user.name);

//Cокращённая запись метода в литерале объекта

// let user = {
//     name : 'Ivan',
//     age: 28,
//     // полная запись
//     // sayHi : function() {
//     //     console.log('Hello, I\'m', user.name);
//     // }
//     // сокращённая запись
//     sayHi () {
//         console.log('Hello, I\'m', user.name);
//     }
// };
//сокращённая и полная записи не эквивалентны - есть тонкие отличия при наследовании (позже),
//всё равно, предпочтительнее сокращённая запись.

//Ключевое слово this в методах
//Функцию которая является свойством объекта называют методом объекта
//Как правило, методу объекта обычно требуется доступ к другим свойствам объекта, например
//например методу, который здоровается, может понадобиться имя пользователя, которое также
//хранится в объекте

// let user = {
//     name : 'Ivan',
//     age : 28,
//     sayHi() {
//         console.log('Hello, my name is', this.name);//здесь this - это ссылка на объект user
//     },
//     isHuman : true,
// };

// user.sayHi();
//для доступа к информации внутри объекта, метод может использовать ключевое слово this.
//технически я могу получить доступ к свойству и через внешнюю переменную, в которой хранится
//ссылка на данный объект. Но такой код не надёжен, при изменении содержимого переменной user - 
//замене ссылки на объект любой примитивой - user.name уже не будет работать, а this.name сработает.
//В JS this не является фиксированным. Это ключевое слово может использоваться из любой функции,
//даже если это не метод объекта. This  вычисляется в момент выполнения кода в зависимости
// от контекста ->

// let user = {name : 'Ivan'};
// let admin = {name : 'Vika'};

// function hi() {
//     console.log(this.name);
// }

// user.f = hi;
// admin.f = hi;

// user.f();
// admin.f();

//я могу вызвать даже функцию без объекта 
// function hi() {
//     console.log(this);
// }

// hi();//здесь я получу undefined

//У стрелочных функций нет this
//если я ссылаюсь на this в таких функциях, то оно возьмётся из внешней "нормальной" функции.
// let user = {
//     firstName : 'Ivan',
//     age : 28,
//     sayHi() {
//         let arrow = () => console.log(this.firstName);
//         arrow();
//     },
//     isHuman : true,
// };

// user.sayHi();

//Задачи
//Создать калькулятор
// let calculator = {
//     read() {
//         this.firstValue = +prompt('enter first number', '28');
//         this.secondValue = +prompt('enter second number', '2');
//     },
//     sum() {
//         console.log(this.firstValue + this.secondValue);
//         return this.firstValue + this.secondValue;
//     },
//     mul() {
//         console.log(this.firstValue * this.secondValue);
//         return this.firstValue * this.secondValue;
//     }
// };

// calculator.read();
// console.log(calculator);

// calculator.sum();
// calculator.mul();

//Цепь вызовов

// let ladder = {
//     step : 0,
//     up() {
//         this.step++;
//     },
//     down() {
//         this.step--;
//     },
//     showStep() {
//         console.log(this.step);
//     }
// };

// ladder.up();
// ladder.up();
// ladder.down();
// ladder.showStep();

//изменить код методов ladder так, чтобы их можно было вызывать по цепочке
// ladder.up().up().down().showStep().down().showStep();

// let ladder = {
//     step : 0,
//     up() {
//         this.step++;
//         return this;
//     },
//     down() {
//         this.step--;
//         return this;
//     },
//     showStep() {
//         console.log(this.step);
//         return this;
//     },
// };
// ladder.up().up().down().showStep().down().showStep();

//Конструктор оператора new
//Функция контсруктор - технически является обычной функцией, но есть два соглашения:
//1. имя должно начинаться с заглавной буквы, 2. ф-я-конструктор должна выполняться только при
//помощи оператора new. Например

// function User (name, surname) {
//     this.name = name;
//     this.surname = surname;
//     this.isAdmin = false;

//     this.sayHi = function() {
//         console.log(`Hello, my name is ${this.name} ${this.surname}.`);
//     };
// }

// let user = new User('Ivan', 'Linnik');
// let userV = new User(prompt('name', 'Viktoriya'), prompt('surname', 'Marakhovskaya'));

// console.log(user);
// user.sayHi();

// console.log(userV);
// userV.sayHi();
//как я понял, функции-конструкторы нужны для многократного создания однотипных объектов.
//такой код более читабельный и понятный, чем многократное создание литерала объекта.
//И да, технически любая функция может быть конструктором - важно, чтобы она начиналась с заглавной
//буквы (так принято для понимания), а при её вызове использовать оператор new, тогда движок
//выполнит необходимый алгоритм.

//Задачи
//создать конструктор калькулятора
// function Calculator() {
//     this.read = function() {
//         this.firstValue = +prompt('enter firstValue', '');
//         this.secondValue = +prompt('enter second value');
//     };
//     this.sum = function() {
//         console.log(`сумма ${this.firstValue} и ${this.secondValue} =`, this.firstValue + this.secondValue);
//         return this.firstValue + this.secondValue;
//     };
//     this.mul = function() {
//         console.log(`произведение ${this.firstValue} и ${this.secondValue} =`, this.firstValue * this.secondValue);
//         return this.firstValue * this.secondValue;
//     };
// }

// let calculator = new Calculator();
// calculator.read();
// calculator.sum();
// calculator.mul();

//Создайте функцию аккумуятор

// function Accumulator(startValue) {
//     this.value = startValue;
//     this.read = function() {
//         this.newNumber = +prompt('enter any number', '');
//         this.value += this.newNumber;
//         return this.value;
//     }
// }

// let accumulator = new Accumulator(1);
// console.log(accumulator.read());
// console.log(accumulator.read());

//Опциональная цепочка "?." - безопасный способ доступа к свойствам
//объекта, даже если они не существуют. Это важно, ведь если я попытаюсь
//получить доступ к несуществующему свойству - я получу ошибку.
// let elem = document.querySelector('.txt-main').innerHTML;
// let noElem = document.querySelector('.class').innerHTML;

// console.log(elem);//выведет содержимое
// console.log(noElem);//будет ошибка

//иногда нормально, что у объекта нет того или иного свойства. Тогда я могу использовать if или тернарный опертор

// let user = {
//     name : 'Ivan',
//     // adress : {
//     //     street : 'Abay st.'
//     // },
// };

// console.log(user.name, 'is living on', user.adress ? user.adress.street : undefined);
//выглядит неэлегантно, вот ещё пример с querySelector, чтобы я увидел всё безобразие:
// console.log(document.querySelector('.elem') ? document.querySelector('.elem') : document.querySelector('.elem'));
//а если мне нужно проверить несколько условий?:
// console.log(user.adress ? user.adress.street ? user.adress.street.name : null : null);
//Для того, чтобы избежать подобного пиздеца есть опциональная цепочка.
// Она возвращает undefined, если значение перед ?. равно null или undefined.
// let user = {
//     name : 'Ivan',
//     adress : {
//         street : {
//             // StName : 'Abay st',
//             index : 7895671,||             штвуч Ж 7895671?

//         },
//     },
// };

// console.log(user.name, user?.adress?.street?.StName);
//А вот пример с querySelector
// console.log(document.querySelector('.elem')?.innerHTML);
//Не стоит злоупотреблять опциональной цепочкой, например подразумевается, что у объекта точно
//точно долженбыть парамет name и не точно адрес, тогда я использую опциональную цепочку только для
//адреса, а для имени просто точечную нотацию console.log(user.name, user?.adress);
//Переменная перед ?. должна быть объявлена, иначе будет ошибка.
// console.log(user?.adress);//ошибка
//Опциональная цепочка, это не оператор, а специальная синтаксическая конструкция,
//которая работает также с функциями и квадратными скобками. Например её можно использовать
//для вызова функции, которой может не существовать

// let userAdmin = {
//     admin() {
//         console.log('I\'m admin');
//     },
// };

// let userGuest = {
//     guest() {
//         console.log('Guest');
//     }
// };

// userAdmin.admin?.();
// userGuest.admin?.();
//в верхних двух строках я предполагаю, что объект юзер существует, и читать из него
//безопасно, затем ?. проверяет левую (от себя) часть, если функция admin существует,
//то она запускается, в противном случае, вычисление остановится без ошибок.
//Сокращённое вычисление - если после выполнения опциональной цепочки с результатом
//undefined есть ещё вычисления, то они выполнены не будут.

// let user = null;

// let x = 0;

// user?.sayHi(x++);//не выполнится
// console.log('Hi'); //выполнится
//Синтаксис ?[] также будет работать, если я буду обращаться к свойству объекта
//без точеной нотации. И это будет работать. Как и в предыдущих примерах, опциональная
//цепочка позволит безопасно обратиться к несуществующим свойствам

// let key = 'surname';

// let user = {
//     name : 'Ivan',
//     [key] : 'Linnik',
//     sayAbout() {
//         console.log(user.name, user.surname);
//     },
// };


// console.log(user);

//Я могу использовать опциональную цепочку только для безопасного чтения, но не для записи
// user?.name = 'Ivan'; //не сработает - это то же самое, что undefined = 'Ivan'

//Тип данных Symbol
//Майсон предлагает не заострять на этом внимание, прочитать, не задротить особо.

//Преобразование объектов в примитивы
//При выполнении математических действий с объектами, например при сложении, я не получу
//так называемый суммарный объект, также в  JS невозможно построить матрицу из объектов или векторы.
//1. Не существует преобразования объекта к логическому значению.
// В логическом контексте все объекты - true. Существует только числовое и строковое преобразование.
//2. Числовое преобразование происходит, когда я вычитаю объекты или применяю мат. ф-ции.
//3. Преобразование к строке происходит, когда я вывожу объект на экран при помощи alert.

//Я могу также реализовать преобразования к строке и чису, используя объектные методы.

//Хинты
//Существует три преобразования типов
//"string" - для преобразования объекта к строке (toString(obj))
//"number" - для преобразования объекта к числу в случае математических операций (Number(obj), +obj)
//"default" - когда оператор не уверен, какой тип ожидать (бинарный +, ==)
//Операторы <, > также могут работать со строками и числами, они используют по умолчанию хинт "number", а не "default"

//Symbol.toPrimitive - встроенный символ, который используется для
//обозначения метода преобразования, вот так:

// obj[Symbol.toPrimitive] = function(hint) {
//     //вот код для преобразования этого объекта в примитив
//     //он должен вернуть примитивное значение
//     //hint = чему-то из "string", "number", "default"
// }
//Если метод Symbol.toPrimitive существует, то он используется для всех хинтов
//и больше никаких методов не требуется. Ниже я напишу объект, который реализует его

// let user = {
//     name : 'Ivan',
//     age : 28,
//     [Symbol.toPrimitive](hint) {
//         console.log(`hint is ${hint}`);
//         return hint == 'string' ? `name: ${this.name}` : this.age;
//     }
// };
// console.log(String(user));
// console.log(+user);
// console.log(user + 10);

//Получается, что в зависимости от преобразования объект user становится либо строкой с описанием,
//либо числом, отражающим возраст. Единый метод Symbol.toPrimitive отбрабатывает все
// случаи преобразования.

//Существуют также методы toString и valueOf, JS пытается их найти, если нет Symbol.toPrimitive.
// Они считаются старомодными методами преобразования.

// let user = {
//     name : 'Ivan',
//     age : 28,
//     //для хинта, равного  'string'
//     toString() {
//         return `name : ${this.name}`;
//     },
//     //для хинта, равного  'number'
//     valueOf() {
//         return this.age;
//     },
// };

// console.log(String(user));
// console.log(+user);
// console.log(user - 10);

//Часто мне нужно некое единое место для обработки всех примитивных преобразований.
//В этом случае я могу реализовать только toString(). В отсутствии Symbol.toPrimitive и
// valueOf, toString()

// let user = {
//     name : 'Ivan',
//     age : 28,
//     toString() {
//         return this.name;
//     }
// };
// console.log(String(user));
// console.log(user + 10);

//Преобразование может вернуть любой тип!
//Не факт, что метод преобразования примитивов вернёт именно
//именно подсказанный хинтом примитив. Единственное, в чём можно быть уверенным,
//что они вернут примитив, а не объект.

//Методы примитивов
// JS позволяет нам работать с примитивами, как с объектами. У примитив могут быть свои методы.
//Чтобы использовать примитивы как объекты, обращаться к методам примитив создаётся как бы
//объект-обёртка, название которого зависит от примитива - String, Number, Boolean, Symbol, BigInt.
//И получается, что разные примитивы обладают разным набором методов. Например есть метод str.toUpperCase,
// который возвращает строку в верхнем регистре:

// let str = 'Ivan';
// console.log(str.toLowerCase());

//число тоже имеет набор методов, например toFixed(n) - округляет значение до n.

// let num = 4.25345;
// console.log(num.toFixed(1));

//null и  undefined не имеют методов

// let str = 'khuy';

// str.num = 5;
// console.log(str.num);

//Числа
//в современном JS существуют два типа чисел
//Обычные числа - записываются в 64-битном формате, они же - числа
//с плавающей точкой двойной точности, а также БигИнт - от -(2**53)-1 до (2**53)-1 (позже).

//Способы записи числа
//Можно использовать букву е для записи большого количества нулей
// let billion = 1000000000; // 1 миллиард, легко ошибиться в такой записи
//можно записать как:
//let billion = 1e9;// что буквально означает 1 и 9 нулей
//let num = 7.3e9// будет равно 7.3 млрд. 300 млн или 7 300 000 000,
//другими словами, е умножает число на 1 с количеством нулей, указанных после е.
//тысяча будет выглядеть как 1е3.
// А чтобы записать что-то маленькое, например микросекунду:
// let ms = 0.000001;//длинная запись
// let ms = 0e-6;//шесть нулей слева от 1.

//Шестнадцатеричные и двоичные числа
//Шестнадцатеричные широко используются для кодировки цветов, символов и пр.
//пример шестнадцатеричногоn представления числа 255 - регистр не имеет значения
// console.log(0xff, 0xFF);
//не так часто используется двоичная (бинарная) форма записи числа
// console.log(0b11111111);
//и восьмеричная
// console.log(0o377);
// console.log(0b11111111 === 0o377);

// Метод num.toString(base) возвращает строковое представление числа num в системе исчисления base
// let num = 2344566;
// console.log(num.toString(8));
//максимальное основание base = 36, с его помощью можно делать короткие ссылки для длинных числовых идентификаторов
// console.log(1234567..toString(36));//две точки используются чтобы JS не ожидал
//десятичную часть числа, вторая точка для этого и нужна

//Округление
//есть несколько часто встроенных функций для работы с округлением

// let anyNum = [3.1, 1.1];//массив для упрощения использования чисел и методов
// console.log(Math.floor(anyNum[0]), Math.floor(anyNum[1]));//округление в меньшую сторону
// console.log(Math.ceil(anyNum[0]), Math.ceil(anyNum[1]));//округление в большую сторону
// console.log(Math.round(anyNum[0]), Math.round(anyNum[1]));//округление до ближайшего целого
// console.log(Math.trunc(anyNum[0]), Math.trunc(anyNum[1]));//отбрасывание дробной части без округления (не работает в IE)

// А что если мне нужно округлить до определённого знака? Есть два способа
// let num = 1.235461;

// умножить и разделить (до второго знака)
// console.log('умножаю и делю на 100 ->', Math.floor(num * 100) / 100);//1.235461->123.5461->123->1.23

// метод toFixed(n) - округляет число до n знаков после запятой и возвращает строковое значение
// как в большую, так и в меньшую сторону аналогично методу Math.round
// console.log('toFixed() ->', num.toFixed(2));//возвращается строка, поэтому можно использовать + или Number()

//Неточные вычисления
//в js числа представлены в виде 64-битного формата, т.е. для хранения числа используется 64 бита.
//52 бита для хранения цифр, 11 бит для хранения положения десятичной точки, 1 бит для хранения знака.
//если число слишком большое оно переполнит 64-битное хранилище, тогда js вернёт бесконечность, например
// console.log(1e500);
//Наиболее часто встречающаяся ошибка в js - потеря точности.
// console.log((0.1 + 0.2) == 0.3);//false - странно пиздец, тогда смотрю, чему равно 01+02
// console.log(0.1 + 0.2); //0.30000000000000004
//это происходит потому что число хранится в бинарной форме в виде едениц и нолей
//получается, что в десятичной форме дроби типа 0.1, 0.2 выглядят довольно просто,
// но в двоичной форме это бесконечная дробь. Просто в js нет возможности хранить точное значение 0.1 и 0.2
//в двоичной форме. Поэтому и используют округление. Вот интересный пример
// console.log(0.1.toFixed(20)); //0.10000000000000000555 - и это не предел, дробь действительно бесконечная
// вот ещё пример интересный
// console.log(9999999999999999);// 16 девяток - покажет 10000000000000000, число как бы растёт само/
// всё потому же - потеря точности. получается, что если для записи числа не хватит бит,
// то при записи пропадут младшие разряды.

// Проверка isFinite isNaN
//Infinity, -Infinity, NaN (представляет ошибку) - это чиcловые значения, которые принадлежат типу number, но они не являются
//обычными значениями, поэтому существуют функции для их проверки.
// isNaN(value) - преобразует значение в число и проверяет, не является ли оно NaN.
// console.log(isNaN(NaN));// true
// console.log(isNaN("str"));// true - NaN при приведениии строки к числу
// console.log(isNaN("12"));// false - 12 при приведении строки к числу
// console.log(isNaN(true));// false - 1 при приведении boolean к числу
// разве нельзя просто строго сравнить NaN, вот так a === NaN - нет, потому
// что NaN не равно даже себе, поэтому нужно использовать ф-ю isNaN.
// console.log(NaN === NaN); // false
//isFinite преобразует аргумент в число и возвращает true, если число не Infinity, -Infinity, NaN.
// console.log(isFinite(15));//true
// console.log(isFinite('hello'));//false
// console.log(isFinite(false));//true
// Иногда isFinite используется для проверки, содержится ли число в строке
// let num = +prompt('enter a number', '');
// console.log(isFinite(num));// вернёт всегда true, кроме ситуаций, когда аргумент Infinity,
//  -Infinity или не число.
//Number.isNaN(value) более строгая проверка значения. Само значение не преобразуется в число,
// а проверяется,
// является ли оно чиловым.
//Вернёт true только в том случае, когда объект принадлежит к типу number и является NaN.
// console.log(
//     Number.isNaN('str'/2)
// );

//стоит учитывать, что пустая строка интерпретируется как 0, а строка с текстом, как 1.

//То же самое и с Number.isFinite(value) - возвращает true только в том случае, если
//value принадлежит типу number и является Infinite -Infinite, NaN.
// console.log(
//     Number.isFinite('ere'/1)
// );

// Существет метод Object.is(value1, value2) - он сравнивает значения как === (строгое равенство)
//но более надёжен в двух особых ситуациях:
// 1 - работает с NaN
// let val = NaN;
// console.log(Object.is(NaN, val));//true

// Значения 0 и -0. Технически они разные и такое сравнение нужно достаточно редко, но тем не менее.
// let zero = 0;
// let minusZero = -0;

// console.log(Object.is(zero, minusZero));

//parseInt, parseFloat
//Если мне нужно получить число из строки, в которой например есть единицы измерения
//то parseInt/Float вернёт мне число, полученное до получения ошибки вычисления
// console.log(
// parseInt('10px')
// );//10px
// parseInt(a10px);//NaN
// console.log(
//     parseFloat('12.45$')
// );
//Ф-я parseInt имеет второй необязательный параметр, он определяет систему счисления
// console.log(
//     parseInt('0xff', 16)
// ); //255

// Другие математические функции
//В JS существует встроенный объект Math, который содержит различные математические
//функции и константы. Например Math.random() - возвращает псевдослучайное число в диапазоне
//от 0 до 1, не включая 1.
// console.log(
//     Math.random()
// );
//Math.min, Math.max(a, b, с, ...) - возвращают максимальное и минимальное значение соответственно
// console.log(
//     Math.min(2, 12, 45, 21)
// );
// Math.pow(n, power) - возвращает число n, в степени power.
// console.log(
//     Math.pow(2, 3)
// )
// console.log(
//     Math.round(6.35 * 10) / 10
// );

// function readNumber() {
//     let value = prompt('enter number', 'any number - 5');

//     if (value === null || value === '') {
//         console.log('ok, bye');
//     } else if (Number.isNaN(value)) {
//         console.log('enter a number! not a string!');
//         return null;
//     } else {
//         console.log(`nice! number you entered is ${value}`);
//         return parseInt(value, 10);
//     }
// }

//Задачи после раздела

///////////////////// Мой код /////////////////////////////
// function readNumber() {
//     let value = prompt('enter number', '0');
//     let parsedValue = parseInt(value, 10);

//     if (value === null || value === '') {
//         console.log('bye');
//     } else if (Number.isNaN(parsedValue)) {
//         console.log('entered is', typeof value);
//         readNumber();
//     } else {
//         console.log('number is', parsedValue);
//         return parsedValue;
//     }
// }

// readNumber();

///////////////////// Код из учебника /////////////////////////////

// function readNumber() {
//     let value;

//     do {
//         value = prompt('enter number', 0);
//     } while (!isFinite(value));

//     if (value === null || value === '') {
//         console.log('ok, bye!')
//         return null;
//     } else {
//         console.log('nice! number you entered is', +value);
//         return +value;
//     }
// }

// readNumber();

// let i = 0;

// while (i != 10) {
//     i += 0.2;
//     console.log(i);
// }

// Написать функцию которая генерирует случайное число из min, max
// пример работы alert(random(1, 5))

// function random(min, max) {
//     return min + Math.random() * (max - min);
// }

// console.log(random(10,20));

// Написать функцию которая генерирует случайное целое число от min
// до max включительно
// пример работы alert(random(1, 3))

// function randomInteger(min, max) {
//     let randomValue = min + Math.random() * (max - min);

//     return randomValue.toFixed(0);
// }

// console.log(randomInteger(2,10));

// Строки
// Спецсимволы
// перенос строки
// console.log('One\n\nTwo\nThree\n\n');
// //кавычки
// console.log('I\'m Ivan');

// Длина строки - str.length
// Это не фунцкия, это свойство (числовое), поэтому
// его нужно вызывать без кавычек
// let str = 'Hello,\nbitch';//12 - cgtцсимволы не учитываются в длине строки

// console.log('длина строки равна ', str.length);

// Доступ к символам
//Получить символ, который занимает определённую позицию можно
// при помощи str[pos] - это более современный способ

// console.log(str[0]); // индексация символов начинается с 0.

//также есть ещё один способ

// console.log(str.charAt()); // это менее современный способ

// Между ними есть разница - при отсутствии символа с необходимой позицией
// [] вернёт undefined, a charAt пустую строку

// console.log(
//     `способ [] - ${str[1000]}

// способ charAt() - ${str.charAt(1000)}
//     `
// );

// строку можно перебрать при помощи цикла for...of
// а ещё при помощи цикла for in (получилось случайно). Но тогда
// синтаксис будет немного другой (похоже на перебирание ключей объекта)

// for (let char in str) {
//     console.log(str[char]);
// }

// for (let char of str) {
//     console.log(char);
// }

// Строки неизменяемы - нельзя изменить символ строки
// str[1] = 'q'; // ошибка

// Но можно создать новую переменную и записать в неё новую
// строку вмсето старой (хуёвый пример, когда много символов)

// let hi = 'hi';
// let newHi = 'H' + hi[1];

// console.log(newHi);

// Изменение регистра

// let str = 'Пишу текст';

// console.log(
//     `
// исходный текст: ${str}
// нижний регистр: ${str.toLowerCase()}
// верхний регистр: ${str.toUpperCase()}

//     `
// );
// // для отдельного символа
//  console.log(
//     str[3].toUpperCase(), str
//  );

// Поиск подстроки - есть несколько способов

// str.indexOf(substr, pos) - ищет подстроку substr в строке
// str, начиная с позиции pos и возвращает позицию, на которой располагается
// совпадение, либо -1, если нет совпадений.

// let str = 'Здравствуйте, меня зовут Иван';

// console.log(str.indexOf('Иван')); //это слово начинается с 25 символа строки
// console.log(str.indexOf('ан', 10)); // поиск и с 10-го символа фрагмента 'ан'
// console.log(str.indexOf('здравствуйте', 0)); // не нашёл ничего -1
// console.log(str.indexOf('в')); // вернёт первую совпавшую позицию, но
// дальше не пойдёт. Чтобы найти все вхождения нужно запустить в цикле

// let str = 'Та тата тити ти та';

// let target = 'та';
// let pos = 0;

// while (true) {
//     let foundPos = str.indexOf(target, pos);

//     if (foundPos == -1) break;

//     console.log('Найдено тут', foundPos);
//     pos = foundPos + 1; // продолжаем со следующей позиции
// }

// Более короткая запись
// let target = 'та';
// let pos = -1;

// while((pos = str.indexOf(target, pos +1)) != -1) {
//     console.log('вот, что нашёл', pos);
// }

// Есть похожий метод, который ищет от конца к началу строки
// str.LastIndexOf(substr, pos) - он нужен тогда, когда нужно
// получить самое последнее вхождение - перед концом строки, или
// начинающееся до (включительно) определённой позиции.

//Есть интересная ситуация - совпадение есть, но indexOf ничего не находит:
// let str = 'hello';

// if(str.indexOf('hello')) { // возвращает 0
//     console.log('I found'); // поэтому код не сработает!
// } else {
//     console.log('Not found');
// }

// чтобы код сработал нужно изменить условие проверки на -1, вот так

// if(str.indexOf('hello') != -1) { // теперь всё работает
//     console.log('I found'); 
// }

// есть ещё старый трюк с побитовым оператором НЕ ~
// подробнее описано в учебнике
//  if(~str.indexOf('hello')) console.log('founded'); // работает
// этот трюк можно встретить только в старом коде, но его нужно помнить.
// в новом же есть метод .includes

// includes, startsWith, endsWith

// str.includes(substr, pos) - возвращает true, если в строке
// есть совпаление, false, если совпадения нет. Это правильный выбор,
// если мне нужно проверить только совпадение, а позиция не нужна.
// необязательный аргумент pos - для указания с какой позиции начать

// let str = 'hello world';

// console.log(str.includes('world'), // true
//             str.includes('bye') // false
// );

// startsWith, endsWith - проверяют, начинается ли строка
// с соответсвующей подстроки

// console.log(
// str.startsWith('hell'), // true - начало с hello
// str.endsWith('orld'), // true - окончание с orld и т.д.
// str.startsWith('hi'), // false
// str.endsWith('hi') // false
// );

// Получение подстроки
// В JS есть три метода получения подстроки substring, substr и slice
// str.slice(start, [, end]) - возвращает часть строки start до
// (не включая end).

// let str = 'stringify';

// console.log (str.slice(0, 5)); //strin

// console.log(str.slice(3)); // ingify - end отсутствует - строка возвращается до конца

// Также для start|end можно задать отрицательные значения, это
// означает, что позиция определена с конца строки

// console.log(
//     str.slice(-2), // fy
//     str.slice(-4, -1), //gif
// );

// Substring почти то же самое, что и  slice, но можно задавать
// start боьлше, чем end? тогда метод сработает, будто аргументы
// поменяны местами:

// console.log(str.substring(6,1)); //tring - slice вернёт пустую строку
// отрицательные значения substring не поддерживает и интерпретирует
// как 0.

// Substr(start, length) - возвращает часть строки от start длины length
// console.log(str.substr(-2, 6)); // fy
// если значение первого аргумента отрицательно, позиция определяется с конца.
// VS code метит его как устаревший, потому что он описан в приложении к
// спецификации, а не в самой спецификации (поэтому он зачёркнут). На практике
// он работает везде (не только в браузере). По итогу автор рекомендует
// запомнить только slice - он более гибкий и короткий для написания.

// Сравнение строк
// как я уже знаю, строки сравниваются посимвольно в алфавитном порядке.

// есть нюансы: строчные буквы больше заглавных
// console.log('a' > 'Z'); //true

// буквы, имеющие диакретические знаки, идут "не по порядку"
// console.log('Österreich' > 'Zealand'); // true

// это может приводить к неправильному результату при сортировке строк
// чтобы понять, что происходит нужно посмотреть внутренее представление строк
// str.codePointAt(pos)
// console.log('Ö'.codePointAt(0)); // 214
// console.log('Z'.codePointAt(0)); // 90
// console.log('O'.codePointAt(0)); // 79

// Можно создать символ по его коду
// console.log(String.fromCodePoint(3433)); // ൩

// сделаю  строку, содержащую символы от 65 до 220

// let str = '';

// for (let i = 65; i <= 220; i++) {
//     str += String.fromCodePoint(i);
// }

// console.log(str); // запусти, посмотри, там много символов
// вывод - строки сравниваются по кодам их символов, это нужно помнить всегда.

// Правильное сравнение
// правильный алгоритм сравнения строк сложнее, чем кажется, потому
// что разные языки используют разные алфавиты. Поэотму браузеру нужно понимать,
// какой язык использовать для сравнения. Все современные браузеры поддерживают
// стандарт ECMA-402, который позволяет правильно сравнивать строки с учётом
// языка, кроме IE10 - для него нужна специальная библиотека.

// Метод для сравнения строк
// str.locateCompare(str2)
// console.log(
//     'hello'.localeCompare('hello')
// );

// вернёт -1, если str < str2
// вернёт 0, если str = str2
// вернёт 1, если str > str2
// у этого метода есть два доп аргумента - 1 указывает язык,
// 2 дополнительные правила (чувствительность к регистру и т.д.)

// есть ещё полезные методы строк
// str.trim() - убирает пробелы в начале и конце строки
// let str = '   ebat\'              ';

// console.log(str, str.length);
// console.log(str.trim(), str.trim().length);

// str.repeat(n) - повторяет строку n раз
// let str = 'privet\n';

// console.log(str.repeat(5));

// Задачи после раздела
//написать ф-ю, которая возвращает любую строку с заглавной буквы

// function ucFirst(str) {
//     if (str === null) {
//         console.log('Bye!');
//         return null;
//     } else if (str.trim() === '') {
//         console.log('Nothing to Capitalize');
//         return null;
//     } else {
//         return str[0].toUpperCase() + str.slice(1).toLowerCase();
//     }
// }

// console.log(ucFirst('IVAN'));

// Написать ф-ю, которая возвращает true, если строка содержит
// 'viargra' или 'XXX' и false если совпадения не найдены. Ф-я
// должна быть не чувствительна к регистру

// let str = '123 sdvlsdvl   sdlvs    ssd;v/// XxX';

// function checkSpam(str) {
//     let modStr = str.toLowerCase();

//     if(modStr.includes('xxx') || modStr.includes('viagra')) {
//         return true;
//     } else {
//         return false;
//     }
// }

// console.log(checkSpam(str));

// Усечение строки

// let str = "Привет, меня зовут Иван Линник";

// function truncate(str, maxlength) {
//     let dots = ".".repeat(3);
//     let dotsLength = dots.length;

//     if(str.length > maxlength) {
//         return str.slice(0, (maxlength - str.length - dotsLength)) + dots;
//     } else {
//         return str;
//     }
// }

// console.log(truncate(str, 10));

// Выделить число

// let str = '$120';

// function extractCurrencyValue (str) {
//     if(isNaN(str[0])) {
//         return parseInt(str.slice(1));
//     } else {
//         return parseInt(str);
//     }
// }

// console.log(extractCurrencyValue(str));

// Массивы

// используются для хранения упорядоченных коллекций. Есть два способа, чтобы объявить пустой массив.
// let array = Array(); let array = [] - второй - самый популярный.
// можно сразу передать значения по умолчанию, вот так:
// let array = ['Иван', 'Виктория', 'Шапка'];

// массивы нумеруются с 0. Можно получить доступ к объектам массива через []
// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }
// console.log('');

// можно заменить элемент
// array[2] = 'Чоис';

// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }

// можно добавлять элементы массива, вот так
// array[3] = array.length;

// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }

// console.log(array);

// можно заменить элемент
// array[3] = 'музыка';
// console.log(array);

// в массиве могут храниться элементы любого типа
// let array = [1, true, {name: 'Ivan', surname: 'Linnik,'}, function() {console.log('Hello');}];
// console.log(array);
// console.log(array[2].name); // Ivan
// array[3](); // Hello
// список элементов массива может заканчиваться запятой, это придаст идентичности строкам кода
// висячая запятая приветствуется также, как и при работе с объектами

// Получение последних строк при помощи at
// допустим, мне нужен последний элемент массива. В других языках я бы мог попробовать array[-1],
// в JS это не сработает, потому что индекс в скобках воспринимается буквально,  и будет undefined.
// Но можно явно вычислить позицию последнего элемента, вот так: array[array.length - 1].

// let array = ['khuy', 'pizda', 'zalupa'];
// console.log(array[array.length - 1]); //ебать писать ещё два раза имя переменной
// как видно, такая запись выглядит громоздко. Есть более короткий синтаксис:
// console.log(array.at(-1));

// Другими словами array.at[i] - то же самое, что и arr[i], если i >= 0.
// Для отрицательных значений он отступает от конца массива.

// Методы pop/push, shift/unsift

// Очередь - один из самых распространённых способов применения массива - когда приходит последний, то первый уходит. 
// метод push - добавляет элемент в конец массива
// метод shift - удаляет элементы в начале, сдвигая очередь так, что второй элемент становится первым
// массивы поддерживают обе операции

// Стек - поддерживает два вида операций - удаляет последний элемент (метод pop), помещает
// элемент в конец массива (метод push) - самый простой пример - колода карт.
// Массивы в JS могут работать и как очередь, и как стек, в компьютерных науках это называется двусторонняя очередь.

// Методы, работающие с концом массива

// POP - удаляет последний элемент из массива и возвращает его

// let array = ['slovo', 'ne', 'vorobey'];
// console.log(array);

// let lastWord = array.pop();
// console.log(array, lastWord);

//PUSH - помещает элемент в конец массива

// let fruits = ['apple', 'orange', 'cherry', 'kiwi'];
// console.log(fruits);

// fruits.push('pineaple', 'banana');
// console.log(fruits);

// Методы, работающие с концом массива

// SHIFT - удаляет из массива первый элемент и возвращает его

// let fruits = ['apple', 'orange', 'cherry',];
// let firstArryElem = fruits.shift();

// console.log(firstArryElem, fruits);

// // UNSHIFT - добавляет элемент в начало массива
// fruits.unshift('apricot');
// console.log(fruits);

// Внутреннее устройство массива
// массив это особый подвид объектов - но, в основе всё равно лежит объект
// массивы расширяют объекты, так как предоставляют возможность работать
// с упорядоченными коллекциями данных, а также свойство length.

// Массив ведёт себя как объект, например он также копируется по ссылке

// let array = ['privet', 'pidor'];
// let arrayCopy = array;
// console.log(array === arrayCopy); //true

// console.log('до изменения копии массива', arrayCopy);
// array[0] = 'hello';
// console.log('изменил копию этого массива', arrayCopy);

// Одна из особенностей массива, это то, что движок хранит элементы массива
// в непрерывной области памяти, один за другим. Есть и другие способы
// оптимизации, благодаря которым массивы работают очень быстро.
// НО все эти способы перестанут рабоать, если я начну работать с массивом,
// как собъектом, т.е. перестану работать с ним, как с упорядоченной коллекцией
// данных, например до/после

// let array = ['иван', 'линник'];
// console.log('before', array);

// array.age = 25; // я могу так сделать, потому что в основе массива лежит объект
// console.log('after', array);
// но движок перестанет применять способы оптимизации для массивов
// и начнёт работать с массивом, как с обычным объектом

// как неправильно использовать массив
// добавление нечислового свойства, например array.feaute = 'something'
// создание дыр, например добавление arr[0], а  затем arr[1000].

// Перебор элементов

// let array = ['a lot', 'of', 'items', 'are', 'here'];

// // цикл for
// for (let i = 0; i < array.length; i++) {
//     console.log(`element with index ${i} is`, array[i]);
// }

// // цикл for of
// // он не предоставляет доступ к индексу элемента, только к значению, но этого
// // но этого обычно достаточно
// for (let item of array) {
//     console.log('for of: ', item);
// }

// также можно использовать цикл for in, но есть подводные камни, поэтому
// не рекомендуется его использовать, к тому же он от 10 до 100 раз медленнее,
// чем for of.

// Length
// это не длина массива, а наибольший цифровой индекс + 1, например единственный элемент, имеющий больший индекс даёт большую длину

// let array = [];

// array[100] = 'apple';
// console.log(array.length); // 101

// свойство length можно перезаписать, и тогда изменится и содержимое
// массива, вот так

// let array = [1, 2, 3, 4, 5];
// array.length = 2;

// console.log(array);// [1, 2]

// array.length = 4; // пытаюсь восстановить элементы

// console.log(array);// [1, 2, empty x 2] - невозможно восстановить

// самый простой способ очистить массив это array.length = 0;

// Многомерные массивы

// их особенность в том, что в них можно хранить матрицы

// let arrayForMatrix = [
//     [0, 1, 2],
//     [3, 4, 5],
//     [6, 7, 8],
// ];

// console.log(
//     arrayForMatrix[1][1]
// );

// toString для массивов

// массивы по-своему реализуют метод toString - он возвращает список элементов,
// разделённых запятыми
// let array = [1, 2, 3, 4,];
// console.log(String(array));

// автор предлагает попробовать следуещее
// console.log(String([] + 1)); // 1

// console.log(String([1] + 1)); // 11

// console.log(String([1, 2] + 1)); // 1,21

// интересно. Так происходит, потому что массивы не имеют встроенного
// Symbol.toPrimitive, а также valueOf(), они реализуют только проеобразование
// toString, и вот как оно работает на примерах выше:
// [] - становится пустой строкой,
// [1] - становится '1',
// [1, 2] - становится 1,2 - соответственно, [1, 2] + 1 - бинарный плюс тоже
// преобразовывает к строке '1,2' + '1' = '1,21'.

// НЕ СРАВНИВАЙ МАССИВЫ ПРИ ПОМОЩИ ==

// два объекта равны друг другу, только если они ссылаются на один объект
// если сравнивать объект и примитив, объект будет приводиться к примитиву, за
// исключением null и undefined, они равны (==) только себе и ничему другому
// === лучше всего, потому что он не преобразует типы
// стало быть, два объекта никогда не будут == друг другу, только если это
// не 2 переменные, ссылающиеся на один объект (массив), например:
// console.log([] == [], [1] == [1]); // false false, это потому,
// что технически я сравниваю два разных массива, оператор == не выполняет
// поэлементное сравнение.

// Сравнение с примитивами тоже может дать казалось бы странные результаты

// console.log(0 == []); // true
// console.log('0' == []); // false
// здесь я сранвил массив с примитивами, и получается, что пустой массив
// преобразуется в примитив и становится пустой строкой, а пустая строка
// становится 0 при ==, а во втором примере нет преобразования строк - 
// разные типы данных.

// Задачи после раздела
/////////////////
// let styles = ['jazz', 'blues',]; // создал массив
// console.log(styles); // проверка
// styles.push('rock-n-roll'); // добавил рок-н-ролл в конец
// console.log(styles); // проверка
// // заменить значение в середине массива на "классика",
// // должно работать для массива любой длины
// styles[((styles.length - 1) / 2).toFixed(0)] = 'classic';
// console.log(styles); // проверка
// console.log(styles.shift()); // удалил первый элемент массива и показал его
// console.log(styles); // проверка
// styles.unshift('rap', 'reggae'); // всавил рэп и регги в начало массива
// console.log(styles); // проверка
////////////////
// let array = ['1', '2'];
// array.push(function(){console.log(this)});
// array[2](); // выведет сам массив, потому this ссылается на объект
////////////////

//ф-я, которая запрашивает у пользователя данные через propmpt и сохраняет
// их в массив. Если пользователь вводит не число, пустую строку или escape
// тогда перестать запрашивать. Ф-я подсчитывает и возвращает сумму значений
// ноль считается числом

// function sumInput() {
//     let arr = [];
//     let sum = 0;


//     while (true) {
//         let userInput = prompt('any number', '');

//         if (userInput === '' || userInput === null || !isFinite(userInput)) break;

//         arr.push(+userInput);
//     }

//     for (let item of arr) {
//         sum += item;
//     }
//     return sum;
// }

// console.log(sumInput());

//Подмассив наибольшей суммы
// (спиздил из книги - это не совсем корректное задание по словам Майсона, но мне просто интересно)
// let arr = [4, 5, 7, 8];
// let arr2 = [-1, 2, 3, -9];
// let arr3 = [-1, -2, -3, -4];
// let arr4 = [-1, 2, 3, 8];

// function getMaxSubSum(arr) {
//     let maxSum = 0; // максимальная сумма
//     let currentSum = 0; // текущая сумма

//     for (let item of arr) { // для каждого элемента массива
//         currentSum += item; // добавляю значение эл-та к текущей сумме
//         maxSum = Math.max(maxSum, currentSum); // запоминаю максимум на момент итерации
//         // благодаря этой переменной не нужно делать несколько проходов вложенным циклом
//         if(currentSum < 0) currentSum = 0;
//     }
//     return maxSum;
// }

// console.log(getMaxSubSum(arr2));

// Методы массивов

// Добавление, удаление элементов
// arr.push(elem, elem, ..) - помещает элементы в конец массива
// arr.pop() - удаляет последний элемент массива и возвращает его
// arr.unshift(elem, elem, ..) - помещает элементы в начало массива и меняет значение length
// arr.shift() - извлекает элемент из начала массива и возвращает его

// Как удалить элемент из массива?
// Можно использовать delete arr[2] - и элемент удалится, но вот длина массива не изменится.
// Это происходит потому что это работает как delete obj.key - удаляется пара ключ:значение, для
// объектов это нрмально, но я хочу, чтобы остальные элементы сместились и заняли освободившееся место
// а сам массив стал короче. Вот поэтому для массива необходимо использовать специальные методы.

// Метод arr.splice. Его синтаксис:

// arr.splice(index[, deleteCount, elem1, ..., elemN]), вот как он работает:
// let array = ['I', 'love', 'JavaScript'];
// array.splice(1, 1); // начиная с позиции 1 удалить 1 элемент
// console.log(array);

// теперь удалю элементы и заменю их другими
// let array = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// array.splice(0, 3, "Давай", "танцевать");
// console.log(array);

// splice() возвращает массив из удалённых объектов
// let deletedItems = array.splice(0, 1);
// если указать только одно значение, а не диапазон, то удалится всё, начиная с этой позиции до конца массива
// console.log(deletedItems);
// console.log(array);

// если я хочу не удалять, а просто вставить элементы на определённую позицию
// let arr = ['today', 'I\'m', 'lazy'];
// console.log(arr);
// arr.splice(2, 0, 'not'); // это буквально означает со второй позиции удалить 0 элементов, вставить 'not'
// console.log(arr);

// Отрицательные индексы разрешены -  в этом случае работа метода будет производиться с конца
// let arr = [1, 2, 5];
// console.log(arr);
// arr.splice(-1, 0, 3, 4); // начиная c индекса -1 (перед последним элементом (или после первого с конца)) удалить 0 элементов,
// затем вставить числа 3 и 4
// console.log(arr);

// Метод slice
// его синтаксис  arr.slice(start, end) - он возвращает новый массив, в который копирует элементы
// если вызвать его без аргументов, то он просто сделает копию массива, такое копирование не меняет исходный массив

// Метод concat - создаёт новый массив, в котрый копирует данные из других массивов и дополнительные значения
// arr.concat(arg1, arg2) - он принимает любое количество аргументов, которые могут быть как массивами, так и объектами
// в результате получаю arr c новыми аргументами.

// let arr = [1, 2];
// let arr2 = [5,6,7,8];
// let arr3 = arr.concat([3, 4], arr2);
// console.log(arr3);
// а запись arr.concat(arr[0, 2]) - буквально означает - скопировать в arr все элементы arr2 за исключением с 0 по 2 элементы.
// Обычно, этот метод копирует только элементы массива, всё остальное копируется как есть

// let arr = [1, 2];
// let obj = {
//     0: 'sas',
//     1: 12,
// }
// console.log(arr.concat(obj));

// // Но если массивоподобный объект имеет свойство Symbol.isConcatSpreadable, то он обрабатывается как массив с помощью concat
// let arr2 = [10, 11];
// let obj2 = {
//     0: '12',
//     1: '13',
//     [Symbol.isConcatSpreadable]: true,
//     length: 2, // наличие этой пары обязательно (без неё не происходит преобразования)
// }
// console.log(arr.concat(obj2));

// Перебор forEach
// запускает функцию для каждого элемента, его синтаксис
// arr.forEach(function(item, index, array)) {
// делать что-то
// }
// результат функции, если она что-то возвращает отбрасывается или игнорируется

// let arr = [23, 43, 5, 667, 89, 0];

// arr.forEach((item, index, array) => {
//     console.log(
//         `элемент ${item} с индексом ${index}`
//     )
// });

// let arr = [1,2,3,4,5];

// function decreaseElemByOne() {
//     let newArr = [];
//     arr.forEach((item, index, array) => {
//         newArr.push(item -= 1);
//     });

//     console.log(arr);

//     return newArr;
// }

// console.log(forElem())

// Поиск в массиве
// let arr = [];

function createRandomArr(amount) {
    let arr = [];
    for (let i = 0; i < amount; i++) {
        var item = (Math.random() * 100).toFixed(0);
        arr.push(item);
    }
    console.log('Сгенерирован массив', arr);
    return arr;
}
// createRandomArr(12);

// let itemIndex = arr.indexOf('45', 0); // возвращает позицию элемента или -1

// let itemIndexByEnd = arr.lastIndexOf('45'); // то же самое, только с конца массива (ищет справа налево)

// let includes = arr.includes('45', 0); // true, если объект есть в массиве с указанного индекса (если не указать - с начала)



// console.log(`содержится?: ${includes}, под индексом: ${itemIndex}, а с конца: ${itemIndexByEnd}`);
// console.log(`Искомый элемент: ${arr[itemIndex]}`)
// console.log(arr);
// важно, что эти методы имеют строгое сравнение, поэтому false не будет 0
// а includes в отличие от других правильно работает с NaN - indexOf вернёт -1, а includes - true

// Методы find и findIndex

// А что если у меня массив объектов? Как мне найти объект с определённым условием?
// Метод arr.find(). Его синтаксис: let result = arr.find(function(item, index, array)) {
// если true - возвращается искомый элемент, все итерации прерываются
// если искомый элемент не найден, возвращается undefined;
// } - функция вызывается поочереди для каждого элемента массива
// Например

// let users = [
//     { id: 1, name: 'Vanya' },
//     { id: 2, name: 'Vika' },
//     { id: 3, name: 'Choice' },
// ];

// let user = users.find((item) => item.id == 1); // функции передан один аргумент (два передаётся редко)
// console.log(user.name, user.id, user);

// // можно передать аргумент без скобок.
// let vika = users.find(item => item.id == 2);
// console.log(vika)

// // Метод find принимает в cебя ф-ю колбэк, которая возвращает true или false.
// // А это я просто написал по сути тот же самый колбэк
// let param = (item) => {return (item.id == 3) ? true : false};

// let shap = users.find(param); // и использовал его
// console.log(shap);

// Метод findIndex() - по сути тоже самое, только возвращает индекс элемента, если найдет или -1, если ничего не найдёт.

// Метод filter()
// нужен тогда, когда найденных элементов может быть много. Синтаксис схож с find(), только метод filter()
// возвращает массив из найденных элементов. Синтаксис
// arr.filter(function(item, index, array){
// если true - элемент добавляется к результату, и перебор продолжается
// если ничего не найдено - возвращается пустой массив
// })

// let users = [
//     { id: 1, name: 'Vanya' },
//     { id: 2, name: 'Vika' },
//     { id: 3, name: 'Choice' },
//     { id: 4, name: 'Vanya' },
//     { id: 5, name: 'Vika' },
//     { id: 6, name: 'Choice' },
// ];

// let request = 'Choice';
// let someUsers = users.filter(item => item.name == request);
// console.log(someUsers);

// for (let elem of someUsers) {
//     console.log(` Идентификатор найденоого элемента: ${elem.id}, поиск по запросу ${request}`);
// }

// Преобразование массива
// метод arr.map() - один из наиболее часто используемых. Он вызывает функцию для каждого элемента
// и возвращает массив результатов выполнения этой функции. Его синтаксис
// let result = arr.map(function(item, index, array){
// возвращается новое значение вместо элемента
// })
//в примере из книги элемент в массиве преобразовывают в его длину.

// let arr = ['Frodo', 'Sam', 'Gandalf'];

// let result = arr.map(item => item = item.length);

// console.log(result);

// Сортировка массива
// метод sort(fn) выполняет сортировку массива на месте, меняя в нём порядок элементов

// let arr = [1, 2, 3, 45, 67, 4, 5, 21, 46];
// let sorted = arr.sort(); // 1, 2, 21, 3, 4, 45, 45, 5, 67
// по умолчанию, элементы сортируются как строки, т.е для них применяется лексографический порядок,
// и получается, что 3 > 21. Чтобы использовать собственный порядок, мне нужно предоставить ф-ю в качестве аргумента sort().
// И для пары значений ф-я должна возвращать:
// function compareNumeric(a, b) {
//     if (a > b) return 1;
//     if (a == b) return 0;
//     if (a < b) return -1;
// };

// let sortedRight = arr.sort(compareNumeric);
// console.log(sorted, sortedRight);

// а если я хочу узнать, какие элементы сравниваются, я могу вывести их на экран
// let arr2 = [12, 34, 1, 5, 6,];
// arr2.sort(function (a, b) {
//     console.log(a + '<>' + b);
// });

// для более аккуратного кода лучше использовать стрелочную функцию
// let secondSorted = arr.sort((a, b) => a - b);
// console.log('with arrow', secondSorted);

// Для строк лучше использовать метод str.localeCompare, чтобы избежать неправильного сравнения, ведь алгоритм сравнения строк
// сравнивает буквы по их кодам, и поэтому для многих алфавитов лучше использовать метод str.localeCompare.

// let nameArray = ["иван", "Виктория", "чоис"];
// let sortedNameArray = nameArray.sort((a, b) => a.localeCompare(b));
// console.log(nameArray, sortedNameArray);
// // или страны
// let countries = ['Österreich', 'Andorra', 'Vietnam'];
// console.log(countries);

// let sortedCountries = countries.sort((a, b) => a.localeCompare(b));
// console.log(sortedCountries);

// Метод reverse - меняет порядок на противоположный

// let numericAr = [1, 2, 3, 4]; // сортирует правильно только если элементы уже отсортированы правильно
// console.log(numericAr.reverse());

// Методы split и join
// метод str.split(delim) - разбивает строку на массив по заданномму разделителю (delim)

// let str = "Привет. Я твой рот ебал.";

// let arr = str.split(' ');
// console.log("получил массив из строки, delim - пробел", arr);

// for (let word of arr) {
//     console.log('перебираю массив > ', word);
// }

// // Разбивка по буквам - если не передать аргумент deli (передать ''), то строка разобьётся посимвольно
// let arrNoDelim = str.split('');
// console.log("получил массив из строки, delim - не указан", arrNoDelim);

// // Противоположный split(delim) метод join(glue)
// // он создаёт строку из элементов массива, вставляя glue между ними
// console.log(
//     'А вот я собрал строку обратно -> ', arrNoDelim.join('')
// );

// reduce и reduceRight - они используются для какого-нибудь вычисления на основе всего массива
// синтаксис: let value = arr.reduce(function(accumulator, item, index, array) {
// ...
// }, [initial]);
// эта функция применяется ко всем элементам массива, и "переносит" свой результат на следующий вызов
// например, можно получить сумму элементов массива одной строкой

// let arr = [1, 1, 1, 1, 1];

// let sumOfElems = arr.reduce((sum, current) => sum + current, 0);
// console.log(sumOfElems);

// если не передавать initial, то я получу тоже самое, потому что в этом случае метод примет за инициализацию первый элемент
// метод arr.reduceRight() работает точно также, но проходит по массиву справа налево.

// Array.isArray
// функция type of не может отличить массив от объекта, потому что в основе массива лежит объект
// поэтому был придуман специальные метод Array.isArray(arr) - он вернёт true, если arr является массивом, в противном случае false.
// let arrJoin = arr.join('>');
// console.log(
//     ` это массив?: ${Array.isArray(arr)}
//     а это?: ${Array.isArray(arrJoin)}, ${typeof arrJoin}`
// );

// Задачи после раздела
//1
// Напишите функцию camelize(str), которая преобразует строки вида «my-short-string» в «myShortString».
// То есть дефисы удаляются, а все слова после них получают заглавную букву.

// function camelize(str) {
//     let arrayFromString = str.split('');
//     let mapResult = arrayFromString.map((item, index, array) => {
//         if (item === '-') {
//             let nextItem = array[++index].toUpperCase();
//             array.splice(index, 1);
//             return nextItem;
//         } return item;
//     });
//     let finalStr = mapResult.join('');

//     return finalStr;
// }
// console.log(camelize('this-random-border-radius'));

// function camelize(str) {
//     return str
//     .split('-')
//     .map((word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1))
//     .join('');
// }
// console.log(camelize('this-random-border-radius'));

//2
// Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
// ищет элементы со значениями больше или равными a и меньше или равными b
// и возвращает результат в виде массива.
// Функция должна возвращать новый массив и не изменять исходный

// let originalArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// function filterRange(array, a, b) {
//    return array.filter(item => (item >= a && item <= b));
// }

// console.log(filterRange(originalArr, 0,3));

//3
// Напишите функцию filterRangeInPlace(arr, a, b), которая принимает массив arr и удаляет из него все значения
// кроме тех, которые находятся между a и b . НА МЕСТЕ. То есть,проверка имеет вид a ≤ arr[i] ≤ b .
// Функция должна изменять принимаемый массив и ничего не возвращать.

// let randomArray = createRandomArr(15);

// function filterRangeInPlace(arr, a, b) {
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] < a || arr[i] > b) {
//             arr.splice(i, 1);
//             i--;
//         };
//     }
//     console.log('диапазон от ', a, 'до ', b);
// }
// filterRangeInPlace(randomArray, 2, 17)
// console.log('после работы функции', randomArray);

//4
// Сортировать в порядке по убыванию
// let randomArray = createRandomArr(10);

// console.log('он же в порядке убывания', randomArray.sort((a, b) => { return a - b }).reverse());

//5
// Скопировать и отсортировать массив
// У нас есть массив строк arr. Нужно получить отсортированную копию, но оставить arr неизменённым.
// Создайте функцию copySorted(arr), которая будет возвращать такую копию.

// let arr = ["HTML", "JavaScript", "CSS", "Abeltone"];

// function copySorted(arr) {
//     return arr.slice('').sort(((a, b) => a.localeCompare(b)));
// }
// console.log(copySorted(arr), 'orig ->', arr);

//6
// Создать расширяемый калькулятор
// Создайте функцию конструктор Calculator, которая создаёт «расширяемые» объекты калькулятора.
// два этапа
// Во-первых, реализуйте метод calculate(str), который принимает строку типа "1 + 2" в формате «ЧИСЛО оператор ЧИСЛО»
// (разделено пробелами) и возвращает результат. Метод должен понимать плюс + и минус - .
// Во-вторых добавьте метод , который добавляет в калькулятор новые операции. Он принимает оператор   и функцию с двумя аргументами
// func(a,b) , которая описывает его.
// доделать
function Calculator() {
    this.methods = {
        '-': (a, b) => a - b,
        '+': (a, b) => a + b,
    };

    this.calculate = function (str) {
        let split = str.split(' '),
            a = +split[0],
            op = split[1],
            b = +split[2];

        if (!this.methods[op] || isNaN(a) || isNaN(b)) {
            return NaN;
        }
        return this.methods[op](a, b);
    };
    this.addMethod = function (name, func) {
        this.methods[name] = func;
    };
}
let anyCalc = new Calculator;





// Перебираемые объекты
// Symbol.iterator
// let range = { // хочу, чтобы здесь работал for of
//     from: 0,
//     to: 5,
// };
// чтобы работать с объектом как с итерируемым, нужно добавить ему специальный метод
// с именем Symbol.iterator - это специальный встроенный символ как раз для этого.
// range[Symbol.iterator] = function () {
//     return {
//         current: this.from,
//         last: this.to,
//         next() {
//             if (this.current <= this.last) {
//                 return { done: false, value: this.current++ };
//             } else {
//                 return { done: true };
//             }
//         },
//     }
// }

// for (let cou of range) {
//     console.log(cou);
// } // теперь это работает

// можно упростить код
// let rangeSimply = {
//     from: 6,
//     to: Infinity, // Infinity - будет итерировать бесконечно
//     [Symbol.iterator]() {
//         this.current = this.from;
//         return this;
//     },
//     next() {
//         if (this.current <= this.to) {
//             return { done: false, value: this.current++ };
//         } else {
//             return { done: true };
//         }
//     },
//     rangeId: 2,
// } // теперь метод [Symbol.iterator]() возвращает сам объект range, у него есть нужный метод next(),
// и он теперь запоминает текущее состояние итерации в this.current.
// Недостаток этого - нельзя использовать этот объект в двух параллельных циклах.

// for (let iterator of rangeSimply) {
//     if (iterator % 2 === 0) continue; // вывел только нечётные
//     console.log(iterator);
//     if (iterator >= 500) break; // остановил после 50 итераций
// }

// Можно использовать бесконечный итератор, например range будет бесконечным при range.to = Infinity.
// Прервать такой бесконечный цикл можно при пощи директивы break.

// Строка - это перебираемый объект
// let str = 'текст строки';

// for (let char of str) {
//     console.log(char.toLocaleUpperCase())
// }

// Явный вызов итератора
// Ниже я буду перебирать строку, как for of только вручную, прямыми вызовами.
// Ниже - получаю строковый итератор и беру из него значения

// 

// Итерируемые объекты - объекты, которые реализуют метод символ итератор
// Псеводмассивы - объекты, у которых есть length, индексированные свойства.
// ниже пример объекта, который является псевдомассивом, но его нельзя итерировать
// let pseudoAr = {
//     0: 'first',
//     1: 'second',
//     length: 2,
// };
// Общее между псевдомассивами и терируемыми объектами - методы массивов с ими не работают

// Array.from - принимает один из итер. объектов или псевдомассивов и делает из них массив.
// Методы массивов теперь будут работать
// Этот метод проверяет, является ли принимаемый объект итерируемым, а затем создаёт новый массив
// и копирует туда элементы.
// Метод также имеет необязательные аргументы - мап функцию - она позволяет изменять элементы перед
// добавлением в массив и зисАрг, который помогает правильно указать this для объекта
// Array.from(obj[, mapFn, thisArg])

// let arrayLike = {
//     0: 'first',
//     1: 'second',
//     length: 2,
// };
// let arrFrom = Array.from(arrayLike);
// console.log(arrFrom);

// for (let el of arrFrom) {
//     console.log(el);
// }
// arrFrom.push('third');
// console.log('after using push(\'third\')', arrFrom);

// let range = {
//     from: 1,
//     to: 5,
//     [Symbol.iterator]() {
//         this.current = this.from;
//         return this;
//     },
//     next() {
//         if (this.current <= this.to) {
//             return { done: false, value: this.current++ };
//         } else {
//             return { done: true };
//         }
//     },
// };

// let arrIter = Array.from(range, elem => (elem ** 0.5).toFixed(3));
// console.log(arrIter);

// Map и Set
// Map, в отличие от объекта не приводит ключи к строке, а хранит их как есть.
// то есть 1 и "1" = это разные ключи. Использовать Map стоит совместно с методами
// let someMap = new Map(); // создаёт коллекцию
// someMap.set(1, 'first value'); // записывает значение 'first value' по ключу 1 (цифра как ключ)
// someMap.set('1', 'second value');

// console.log(`
// возрващает значение по ключу 1: ${someMap.get(1)}, если нет ключа, то ${someMap.get(23)}.
// возвращает true, если ключ есть в коллекции: ${someMap.has('1')}.
// удаляет элемент по ключу ${someMap.delete('1')}
// теперь посмотрим размер: ${someMap.size}
// всё очистим: ${someMap.clear()}
// опять посмотрим размер: ${someMap.size}
// `)

// Можно использовать объекты в качестве ключей
// сохранить количество посещений
// let user = { name: 'John' };
// let visitCountMap = new Map();
// visitCountMap.set(user, 13);
// console.log(visitCountMap.get(user)); //13
// так вот, использование объектов в качестве ключей - одна из важных особенностей Map
// и если заменить Map на Object, то я получу [object Object] вместо ключей, то есть сам объект
// приведёт ключи к строке (что обычно и происходит).
// Сравнивание ключей происходит как при === (sameVaueZero), но при работе с Map NaN может быть равно NaN -
// получается, что NaN тоже может быть ключём.
// Цепочка вызовов - каждый раз вызов map.set() возвращает объект, поэтому можно делать последовательные вызовы
// этого метода:
// map.set(1, 'sosi').set('2', 'guboy').set(true, 'tryasi');

// Перебор Map
// для перебора коллекции Map есть три метода
// map.keys() - возвращает итерируемый объект по ключам
// map.values() - возвращает итерируемый объект по значениям
// map.entries() - возвращает итерируемый элемент по парам типа [ключ, значение] - этот вариант используется по умолчанию в for of

// let reciept = new Map([
//     ['cucumber', 500],
//     ['tomato', 300],
//     ['onion', 200],
// ]);

// // перебор по ключам (овощи)
// console.log('перебор по ключам (овощи)')
// for (let vegetable of reciept.keys()) {
//     console.log(vegetable);
// }

// // перебор по значениям (граммовка)
// console.log('перебор по значениям (граммовка)');
// for (let weight of reciept.values()) {
//     console.log(weight);
// }

// // перебор по элементам в формате [ключ, значение]
// console.log('перебор по элементам в формате [ключ, значение]');
// for (let elem of reciept.entries()) { // entries() можно не указывать
//     console.log(elem);
// }

// Используется порядок вставки, то есть, в отличие от объектов, перебор коллекции Map происходит в том порядке, в котором
// добавлялись пары. Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов
// reciept.forEach((value, key, map) => {
//     console.log(`${key} в количестве ${value} грамм (по рецепту ${map})`);
// });

// Object.entries: Map из Object
// // можно сделать Map при помощи метода entries
// let obj = {
//     name: 'John',
//     age: 30,
// };

// let mappy = new Map(Object.entries(obj));
// console.log(mappy);

// // и наоборот - Object из Map
// let objFromMap = Object.fromEntries(mappy);
// console.log(objFromMap);

// Set
// это особый вид коллекции, в котором значение может появиться только один раз, он не содержит ключей.
// его методы похожи на Map, а создаётся он так
// let mySet = new Set(iterable); // обычно, в качестве аргумента передаётся итерируемый объект (или массив), тогда значения
// копируются в новый Set.
// let arr = ['даров', 'заебал'];
// console.log('массив', arr);

// let mySet = new Set(arr);
// console.log('сет', mySet);

// mySet.add('hello').add('world').add('даров'); // даров - не добавится, т.к. уже есть в коллекции
// console.log('добавил элементы', mySet);

// // перебор Set

// for (let elem of mySet) {
//     console.log('перебор ', elem)
// }

// mySet.forEach((item, itemAgain, set) => {
//     console.log('элемент', item, 'в сете', mySet);
// }) // itemAgain нужен для совместимости с Map, в котором колбэк имеет 3 аргумента
// // Set имеет те же встроенные методы, что и Map set.keys(), set.values(), set.entries() (keys и values одно и то же).

// Задачи после раздела

// Допустим, у нас есть массив arr .
// Создайте функцию unique(arr) , которая вернёт массив уникальных, не повторяющихся
// значений массива arr .

// let values = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Krishna", "Hare", "Hare", ":-O"];

// function uniq(arr) {
//     return Array.from(new Set(arr));
// }

// let uniqValues = uniq(values);
// console.log(uniqValues);

// Напишите функцию   , которая возвращает массив слов, очищенный от анаграмм.
// Из каждой группы анаграмм должно остаться только одно слово, не важно какое.

// let anArr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
// let obj = {};

// function aclean(arr) {
//     for (let i=0; i < arr.length; i++) {
//         let sorted = 
//         arr[i].
//         toLowerCase().
//         split("").
//         sort().
//         join("");

//         obj[sorted] = arr[i];
//     }
//     return Object.values(obj);
// }
// console.log(aclean(anArr));

// Мы хотели бы получить массив ключей map.keys() в переменную и работать с ними, например, применить метод push().
// Но это не выходит:
// Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?

// let map = new Map();
// map.set('name', 'John');

// let keys = Array.from(map.keys());
// keys.push('more')
// console.log(keys);

// WeakMap и WeakSet

// основное отличие от Map в том, что ключами в WeakMap могут быть только объекты. Но если сделать объект
// недостижимым (например, obj = null, нет ссылок на объект), то этот объект удалится сборщиком мусора и из WeakMap.
// в WeakMap есть только следующие методы: weakMap.set(key, value), .get(key), .delete(key), .has.key. Эти ограничения
// связаны с тем, что движок может удалить элементы в любой момент, сразу или запланирует удаление на потом, получается
// что конечное число элементов в коллекции неизвестно, поэтому и нельзя перебрать все элементы.
// Это нужно, когда мне нужно временно хранить данные, например из какой-нибудь библиотеки - я положу сторонний объект, как
// ключ, и когда сам объект перестанет использоваться (станет недостижимым), он также удалится из weakMap.
// weakMap.set(obj, 'сектретные документы') - когда obj исчезнет, секретные документы удалятся.
// Пример реализации счётчика посещений с использованием Map:

// visitCounts.js
// let visitCountMap = new Map(); // map: пользователь => число визитов

// // увеличиваю счётчик
// function countUser(user) {
//     let count = visitCountMap.get(user) || 0;
//     return visitCountMap.set(user, count += 1);
// }

// // а это другая часть кода, возможно в другом файле, которая использует countUser
// // main.js
// let john = { name: 'John' };
// let bob = {name: 'Bob'}
// console.log(countUser(john)); // ведёт подсчёт посещений
// console.log(countUser(bob)); // ведёт подсчёт посещений

// bob = null; // теперь объект bob должен быть удалён из map, но этого не происходит. Такая коллекция может расти до бесконечности.
// чтобы этого избежать, нужно просто использовать weakMap
// let visitCountMap = new WeakMap();

// function countUser(user) {
//     let count = visitCountMap.get(user) || 0;
//     return visitCountMap.set(user, count += 1);
// }
// теперь, когда объект будет недостижим, кроме как из weakMap - вся информация о нём будет удалена, в том числе из weakMap

// Применение WeakMap для кэшироввания
// cache.js
// let cache = new WeakMap();

// // вычисляю и запоминаю результат
// function process(obj) {
//     if (!cache.has(obj)) {
//         let result = /* вычисляю что-то для объекта */ obj;
//         cache.set(obj, result);
//     }
//     return cache.get(obj);
// }

// // main.js
// let obj ={/* какой-то объект */};

// let result1 = process(obj);
// let result2 = process(obj);

// // ... позже, когда объект больше не нужен
// obj = null;

// нет возможности получить cache.size(), так как это WeakMap,
// но он равено 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кэша удаляются.

// WeakSet
// похожа на WeakMap - принимает в себя только объекты, когда объект становится недостижим вне WeakSet, удаляется из WeakSet.
// имеет тот же набор методов. Может пригодиться для определения, посещал ли пользователь сайт. Рекомендуют получать
// булевые значения.
// let visiteSet = new WeakSet();

// let sarah = {name:'Sarah'};
// let fred = {name:'Fred'};

// visiteSet.add(sarah);
// visiteSet.add(sarah);
// console.log('Сара заходила?:', visiteSet.has(sarah),'Фред заходил?:', visiteSet.has(fred));
// sarah = null; // теперь sarah ,eдет удалена из коллекции


// Задачи после раздела
// Хранение отметок непрочитано

// let messages = [
//     { text: "Hello", from: "John", },
//     { text: "How goes?", from: "John", },
//     { text: "See you soon", from: "Alice", },
// ];

// let readMessagesSet = new WeakSet();
// let isRead = Symbol('isRead');

// messages[1][isRead] = true;

// for (let i = 0; i < messages.length; i++) {
//     if (messages[i][isRead] === true) {
//         readMessagesSet.add(messages[i]);
//     } else continue;
// }

// console.log(readMessagesSet, messages[1][isRead] === true);

// Хранение времени прочтения
// let messages = [
//     { text: "Hello", from: "John" },
//     { text: "How goes?", from: "John" },
//     { text: "See you soon", from: "Alice" },
// ];

// let readMap = new WeakMap();

// let isRead = Symbol('isRead');
// let readDate = Symbol('readDate');

// messages[1][isRead] = true;
// messages[0][isRead] = false;

// for (let i = 0; i < messages.length; i++) {
//     if (messages[i][isRead] === true) {
//         readMap.set(messages[i], [readDate] = Date());
//     } else continue;
// }

// console.log(readMap);

// Object.keys(), .values(), .entries()
// существует общее соглашение использовать эти метода для структур данных, простые объекты тоже могут реализовать этот метод,
// но синтаксис отличается. Для простых объектов доступны следующие методы:
// Object.keys(obj), Object.keys(obj), Object.entries(obj). Важно, что прииспользовании с Map возвращается объект,
// а при использовании с простым объектом - "реальный" массив. Все объекты вида Object.* возвращают массив.
// let user = {
//     name: 'John',
//     age: 30,
// };
// console.log(Object.keys(user), Object.values(user), Object.entries(user), Object.entries(user)[0][1]);
// пример перебора значений объекта в цикле

// for (let value of Object.values(user)) {
//     console.log(value)
// }

// Object.keys/values/entries игнорируют символьные свойства. Обычно это удобно, но если они нужны
// для этого есть Object.getOwnPropertySymbols - возвращает массив только символьных ключей, а метод
// Reflect.ownKeys(obj) - вернёт все ключи.

// Трансформация объекта

// У объекта нет множества методов, которые есть у массива, но если я хочу их применить, то:
// можно использовать Object.entries с последующим вызовом Object.fromEntries. Пример с удвоением цен:
// let prices = {
//     banana: 1,
//     orange: 2,
//     meat: 4,
// };

// let doublePrices = Object.fromEntries(
// преобразовать в массив, применить метод map, затем снова преобразовать в массив
// Object.entries(prices).map(([key, value]) => ([key, value * 2]))
// ); // важно соблюдать баланс - сохранить читаемость таких преобразований
// console.log(doublePrices);

// Задачи после раздела

// Сумма свойств объекта
// let salaries = {
//     "John": 100,
//     "Pete": 300,
//     "Mary": 250,
// };

// function sumSalaries(salaries) {
//     let sum = 0;
//     for (let val of Object.values(salaries)) {
//         sum += val;
//     } 

//     return sum;
// }
// console.log(sumSalaries(salaries));

// // можно использовать reduce()
// function sumSalariesReduce(salaries) {
//     return Object.values(salaries).reduce((a, b) => a + b, 0);
// }
// console.log(sumSalariesReduce(salaries));

// Подсчёт количества свойств объекта
// игнорировать символьные, только обычные

// let obj = {
//     name: 'Jonh',
//     age: 30,
// };
// let symb = Symbol('symb');
// obj[symb] = "hasSymbol";

// function count(obj) {
//     return Object.keys(obj).length;
// }
// console.log(count(obj), obj);


// Деструктирующее присваивание

// это специальный синтаксис, который позволяет мне распаковать объекты или массивы в отдельные переменные.
// Так иногда проще. Деструктуризация также хорошо работает со сложными функциями, где много парметров и т.д.

// Деструктуризация массива
// есть массив
// let arr = ['Ivan', 'Linnik'];

// а вот деструктурирующее присваивание
// let [firstName, lastName] = arr; // записывает firstName = arr[0], lastName = arr[1]
// console.log(firstName, lastName); // Ivan Linnik

// можно использовать переменные вместе со split()
// let [firstName, lastName] = 'Ivan Linnik'.split(' ');
// console.log(firstName, lastName);

// Есть нюансы
// деструктуризация не разрушает массив, она не делает ничего с правой частью, лишь присваивает значения переменным
// это просто короткий ваирант записи
// let firstName = arr[0];
// let lastName = arr[1];

// можно пропускать ненужные элементы массива с помощью дополнительной запятой
// например второй элемент не нужен
// let [firstName, , title] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];
// console.log(title); // Consul

// // работает с любым перебираемым объектом с правой стороны
// let [a, b, c] = 'abc';
// console.log(b); // и

// let [one, two, three] = new Set([1, 2, 3]);
// console.log(three); // 3

// Цикл с .entries()
// в предыдущей главе я видел Object.entries(obj) -  теперь я могу использовать его для деструкткуризации
// let me = {
//     name: 'Ivan',
//     lastName: 'Linnik',
//     age: 28,
// };

// // цикл по ключам и значениям
// for (let [key, value] of Object.entries(me)) {
//     console.log(`${key} : ${value}`); // name : Ivan lastName : Linnik e.t.c.
// }

// // то же самое для Map
// let user = new Map();
// user.set('name', 'Ivan');
// user.set('age', 28);

// for(let [key, value] of user) {
//     console.log(`${key} : ${value}`);
// }

// Трюк обмена переменных
// let guest = 'Choice';
// let admin = 'Ivan';
// console.log(`before change > guest is ${guest}, admin is ${admin}`);

// [guest, admin] = [admin, guest]; // здесь я создаю временный массив из переменных и деструктурирую его
// // в порядке замены. Так я могу поменять более двух переменных.
// console.log(`after change > guest is ${guest}, admin is ${admin}`);

// Остаточные параметры
// Если массив длиннее, чем список слева, то лишние элементы опускаются. Но если я хочу их получить,
// я могу добавить ещё один параметр, который получает остальные значения, испоьзуя оператор "остаточные параметры" - 
// троеточие "...":

// let [name1, name2, ...residual] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];
// console.log(name1, name2);
// console.log(residual, residual.length); // 2 - rest - это массив, начиная с 3-го элемента
// console.log(residual[1]); // of the Roman Republic

// Значения по умолчанию
// если в массиве меньше параметров, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными.
// let [firstName, lastName] = [];
// console.log(firstName); // undefined

// // если я хочу, чтобы значение по умолчанию заменило существующее, то я могу указать его через "=":
// let [name = 'Choice', surname = 'Caesar'] = ['Julius'];
// console.log(name, surname); // Julius Caesar - Julius - из массива, Caesar - по умолчанию

// значения по умолчанию могут быть более сложными, и даже функциями, они выполняются только если значения отсутствуют.

// prompt запустится только для surname
// let [name = prompt('name?'), surname = prompt('surname?')] = ['Julius'];
// console.log(name, surname);

// Деструктуризация объекта

// деструктурирующее присваивание работает также с объектами, его синтаксис:
// let {var1, var2} = {var1: .., var2: ..,}

// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// let {title, width, height} = options;
// console.log(title, width, height); // menu 200 300
// console.log(options.title); // Menu

// все свойства options присваиваются тем же переменным, порядок не имеет значения. Вот так тоже работает
// let {width, height, title} = {title: 'Menu', height : 200, width: 100};
// console.log(height); // 200

// Шаблон левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
// Если я захочу присвоить свойство объекта переменной с другим названием, например свойство option.width
// присвоить переменной w, то я могу испоьлзовать двоеточие:
// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// // {sourceProperty: targetVariable}
// let {width: w, height: h, title} = options; // значение свойства width передать в переменную w и т.д.
// console.log(w, h, title); // 200 300 'Menu'

// Для потенциально остутствующих свойств я также могу использовать "=".
// let options = {
//     title: 'Menu',
// };

// let {width = 200, height = 300, title } = options;
// console.log(width, height, title); // 200 300 'Menu'

// Как и с массивами, значения по умолчанию могут быть любые, они применятся, если значения отсутствуют в объекте.
// prompt запросит width, но не title
// let options = {
//     title: 'Menu',
// };

// let {width = prompt('width?'), title = prompt('title?')} = options;
// console.log(width, title); // результат prompt 'Menu'

// также можно совмещать : и =
// let {width: w = 200, height: h = 300, title} = options;
// console.log(w, h, title); // 200 300 'Menu'

// если у меня большой объект, то я могу взять нужное и  отбросить остальное

// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// // let {title} = options;
// // console.log(title); // Menu

// // остаток свойств можно взять также, как и для массива "...", только обращаться нужно как свойству объекта

// let {title, ...rest} = options;
// console.log(rest, rest.width); // объект с остаточными значениями 200

// нюанс
// я мог бы сделать так: let = width, heihgt;
// {width, height} = {width: 200, height: 300}; - но так не будет работать!
// дело в том, что движок, видя {} воспринимает это в основном потоке, как блок кода.
// // Чтобы показать ему, что это не блок кода, нужно заключить всё выражение в скобки, и всё будет работать.
// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// let width, height;

// ({ width, height } = options);
// console.log(width, height); // 200 300

// Вложенная деструктуризация

// let options = {
//     size: {
//         width: 100,
//         height: 200,
//     },
//     items: ['Cake', 'Donut'],
//     extra: true,
// };

// шаблон в левой   части должен иметь такую же структуру, чтобы извлечь данные
// деструктуризация на несколько строк - для ясности

// let {
//     size: {
//         width,
//         height,
//     },
//     items: [item1, item2], // добавил элементы к items
//     title = 'Menu', // отсутствует в объекте, будет использовать как параметр по умолчанию
// } = options;
// заметим, что переменные для size и items отсутствуют, т.к. я сразу взял их содержимое
// console.log(width, height, item1, item2, title); // 100 200 'Cake' 'Donut' 'Menu'

// Умные параметы функций

// есть ситуации, когда когда функция имеет много параметров, большинство из которых не обязательны.
// проблемы в том - как запомнить эти параметры или вызвать функцию, когда большинство параметров передавать не надо
// можно передать параметры как объект и функция деструктуризирует его:

// передам этот объект в функцию
let options = {
    title: 'My menu',
    items: ['item_1', 'item_2'],
};

// и она извлечёт его параметры
// function showMenu({title = 'Untitled', width = 200, height =300, items = []}) {
//     console.log(title, width, height); // My menu 200 300
//     console.log(items); // ['item_1', 'item_2']
// }
// showMenu(options);

// можно использоватбь более сложное деструктурирование с вложенными объектами и двоеточием
// function showMenu({
//     title = 'Untitled',
//     width: w = 200, // присваиваю width в w
//     height: h = 300, // присваиваю height в h
//     items: [item1, item2], // первый элемент items присвоится item1, второй - item2
// }) {
//     console.log(title, w, h); // My menu 200 300
//     console.log(item1, item2); // item_1 item_2
// }
// showMenu(options);

// такое использование подразумевает, что в функцию должен быть передан аргумент!
// если мне нужны все значения по умолчанию - нужно передать пустой объект, иначе будет ошибка, но её можно исправить,
// сделав {} значением по умолчанию для всего объекта
// function showMenu({title = 'Untitled', width = 200, height = 300, items} = {}) {
//     console.log(title, width, height); // Untitled 200 300
// }
// showMenu();
// в примере выше всегда в функции есть объект, поэтому есть, что деструктуризировать

// Задачи после раздела

// деструктурирующее присваивание
// let user = {
//     name: 'John',
//     years: 30,
// };

// let { name, years: age, isAdmin = false } = user;
// console.log(name, age, isAdmin); // John 30 false

// Максимальная зарплата
// let salaries = {
//     "John": 100,
//     "Pete": 300,
//     "Mary": 250,
// };

// function getTopSarary(obj) {
//     let max = 0;
//     let maxName = null;

//     for (const [name, salary] of Object.entries(obj)) {
//         if (max < salary) {
//             max = salary;
//             maxName = name;
//         };
//     }
//     return maxName;
// }

// console.log(getTopSarary(salaries));

// Дата и время
// это новый встроенный объект, он содержит дату и время, а также предоставляет методы управления ими.
// для его содзания нужно вызвать конструктор new Date(). Если не передать аргументы, запишется текущие дата и время.
// let now = new Date();
// console.log(now);

// new Date(milliseconds)
// создать объект с временем, равным количеству миллисекунд(тысячная доля секунды), прошедших с 1 января 1970 года UTC+0
// 0 соответствует UTC+0
// let Jan01_1970 = new Date(0);
// console.log(Jan01_1970);

// теперь добавим 24 часа и получим 2 янаваря 1970
// let Jan02_1970 = new Date(24 * 3600 * 1000);
// console.log(Jan02_1970);

// целое число миллисекунд, прошедших с января 1970 года называется - таймстамп(timestamp  - отметка времени)
// это легковесное численное представление даты. Из него всегда можно получить дату new Date(timestamp) и преобразовать
// существующий объект Date в таймстамп, использую метод date.getTime().
// датам до 1 января 1970 будут соответствовать отрицательные таймстампы

// 31 декабря 1969 года
// let Dec31_1969 = new Date(-24 * 3600 * 1000);
// console.log(Dec31_1969);

// new Date(datestring)
// если аргумент всего один, и это строка, то из него прочитывается дата
// let date = new Date('2017-06-23');
// console.log(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу
// меняется в соответствии с часовым поясом места выполнения кода

// new Date (year, month, date, hours, minutes, seconds, ms)
// обязательны только первые два аргумента, year - должен состоять из 4 цифр, month - начинается с 0 (январь) и
// заканчивается 11 (декабрь).
// date означает день месяца, если не задан - принимается 1. Остальные параметры, если не заданы, то - 0.
// console.log(new Date(2020, 0));
// максимальная точность - 1 ms

// Получение компонентов даты
// методы получения компонентов даты: getFullYear() - получить год (4 цифры), getMonth(), getDate(), getHours(),
// getMinutes(), getSeconds(), getMilliseconds(), getDay() - получить день недели: 0 - воскресенье, 6 - суббота.
// все эти методы возвращают значения в соответсвтии с местным часовым поясом, однако существуют методы, которые
// возвращают значения в зоне UTC+0: getUTCFullYear(), getUTCMonth, getUTCDay().

// Если часовой пояс смещён относительно UTC, то код ниже покажет разные часы
// текущая дата
// let now = new Date();

// час в текущем часовом поясе
// console.log(now.getHours());

// час в лондонском времени без перехода на летнее время
// console.log(now.getUTCHours());

// Существуют также два особых метода без UTC варианта
// getTime() - для заданной даты возвращает таймстамп - количество миллисекунд, прошедших с 1 января 1970 года UTC+0
// getTimeZoneOffset() - возвращает разницу в минутах между UTC+0 и местным часовым поясом

// Установка компонетов даты
// методы установки:
// setFullYear(year, [month], [date]), setMonth([month], [date]), setDate(date), setHours(hour, [min], [sec], [ms]),
// setMinutes(minute, [sec], [ms]), setSeconds(second, [ms]), setMilliseconds(ms), setTimeMilliseconds - устанавливает
// дату в виде целого количества миллисекунд, прошедших с 01.01.1970. У всех этих методов, кроме setTime() есть UTC вариант.
// Методы позволяют указывать несколько компонентов даты, если компонент не указать - он не меняется.
// let today = new Date();
// today.setHours(0)
// console.log(today); // выведет сегодняшнюю дату, но количество часов будет 0, а вот минуты изменятся (от 00:00)
// today.setHours(0, 0, 0, 0);
// console.log(today); // всё время будет равно 0

// Автоисправление даты
// let date = new Date(2013, 0, 32); // 32 января 2013
// console.log(date); // 1 февраля 2013 - объект сам себя исправил!

// допустим нужно увеличить дату на 2 дня - нужно просто прибавить к дате 2 дня, а объект Date сам определит високосный
// это год или нет
// let date = new Date(2016, 1, 28); // 28 февраля
// date.setDate(date.getDate() + 2);
// console.log(date); // в зависимости от года будет 1 или 2 марта

// также возможность изменения используют, чтобы получить дату по прошествии заданного отрезка времени

// получить дату, спустя 70 секунд от текущего момента
// let date = new Date();
// date.setSeconds(date.getSeconds() + 70); // можно установить нулевые и отрицательные значения
// console.log(date);

// Преобразование к числу, разность дат

// если объект Date преобразовать к числу, то получу аналогичный таймстамп, возвращаемый .getTime()
// let date = new Date();
// console.log(date, '>', +date, date.getTime()); // количество миллисекнд
// побочный эффект от этого - разницу между датами можно вычислять в милисекундах

// let start = new Date(); // начало отсчёта времени

// выполняю некоторые действия
// for (let i = 0; i < 100000; i++) {
//     let doSomething = i * i * i;
// }

// let end = new Date(); // конец отсчёта времени

// console.log(`цикл отработал за ${end - start} миллисекунд`);

// Date.now()
// если нужно просто измерить время, объект Date мне не нужен. Date.now() эквивалентен new Date.getTime(),
// только он создаёт промежуточный объект Date. Этот сбособ работает быстрее и не нагружает сборщик мусора.
// можно переписать предыдущий пример так:

// let start = Date.now();

// for (let i = 0; i < 100000; i++) {
//     let doSomething = i * i * i;
// }

// let end = Date.now();
// console.log(`цикл отработал за ${end - start} миллисекунд`); // быстрее на 3-5 миллисекунд

// Бенчмаркинг

// протестируем скорость выполнения функций, какая быстрее?

// function diffSubstract(date1, date2) {
//     return date2 - date1;
// }

// function diffGetTime(date1, date2) {
//     return date2.getTime() - date1.getTime();
// }

// но эти функции простые, поэтому мне понадобится 100 000 повторений

// function bench(f) {
//     let date1 = new Date(0)
//     let date2 = new Date();

//     let start = Date.now();

//     for (let i = 0; i < 100000; i++) f(date1, date2);
//     return Date.now() - start;
// }
// console.log(`
// время diffSubstract: ${bench(diffSubstract)}, мс
// время diffGetTime: ${bench(diffGetTime)}, мс
// `); // getTime в 11 раз быстрее
// это потому что не производится преобразование типов и интерпретаторам так намного легче работать

// представим, что во время выполнения bench(diffSubstract) процессор делал что-то ещё, а к моменту начала 
// bench(diffGetTime) завершил - это нормально для многопроцессорных ОС - поэтому нужно делать много бенчмарков

// function diffSubstract(date1, date2) {
//     return date2 - date1;
// }

// function diffGetTime(date1, date2) {
//     return date2.getTime() - date1.getTime();
// }

// function bench(f) {
//     let date1 = new Date(0);
//     let date2 = new Date();

//     let start = Date.now();

//     for (let i = 0; i < 100000; i++) f(date1, date2);

//     return Date.now() - start;
// }

// let time1 = 0;
// let time2 = 0;

// предварительные запуски функций для "разогрева"
// bench(diffSubstract);
// bench(diffGetTime);

// запущу бенч каждой функции 10 раз
// for (let i = 0; i < 10; i++) {
//     time1 += bench(diffSubstract);
//     time2 += bench(diffGetTime);
// }
// console.log(`
// итоговое время diffSubstract: ${time1}
// итоговое время diffGetTime: ${time2}
// `);

// современные интерпретаторы не оптимизируют должным образом то, что выполняется 1 раз (или редко), оптимнизируют только то,
// что выполняется много раз. Поэтому делают предварительные запуски для "разогрева". Я напишу их выше.

// Разбор строки с датой
// метод Date.parse(str) - получает дату из строки.
// формат строки должен быть YYYY-MM-DDTHH:mm:ss.sssZ, где
// YYYY-MM-DD - год, месяц и день, символ Т - используется как разделительб HH:mm:ss.sss - часы, минуты, секунды, миллисекунды,
// Z - необязательная часть - обозначает часовой пояс в формате +- hh:mm, если указать просто букву Z - получу UTC+0.
// возможно сокращённое использование, тогда просто из аргумента убирается ненужное.
// Вызов этого метода возвращает таймстамп (количество миллисекунд с 1 янв 1970 UTC+0), если формат неправильный - NaN.

// let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
// console.log(ms); // 1327611110417

// можно создать объект Date из таймстампа
// let date = new Date(Date.parse('2012-01-26T13:51:50.417-07:00'));
// console.log(date); // Fri Jan 27 2012 00:51:50 GMT+0400 (Moscow Standard Time)
// let date2 = new Date(Date.parse('2012-01-26'));
// console.log(date2); // Thu Jan 26 2012 04:00:00 GMT+0400 (Moscow Standard Time)

// Задачи после раздела

// создать объект дата с нужной датой и временем
// let date = new Date(Date.parse('2012-01-20T03:12'));
// console.log(date);

//написать функцию, показывающую день недели
// let date = new Date(2012, 0, 3);

// function getWeekDay(date) {
//     let weekDays = ['ВС', 'ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ',];

//     return weekDays[date.getDay()];
// }

// console.log(getWeekDay(date));

// день в европейской нумерации
// let date = new Date(2012, 0, 3);

// function getLocalDay(date) {
//     let day = date.getDay();

//     if (day == 0) {
//         day = 7;
//     }

//     return day;
// }

// console.log(getLocalDay(date));

// какой месяц был много дней назад
// let date = new Date(2015, 0 ,2);
// console.log(date);

// function getDateAgo(date, days) {
//     let dateCopy = new Date(date);

//     dateCopy.setDate(date.getDate() - days);

//     return dateCopy;
// }

// console.log(getDateAgo(date, 365));

// Последнее число месяца
// function getLastDayOfMonth(year, month) {
//     let date = new Date(year, month + 1, 0);

//     return date.getDate();
// }

// console.log(getLastDayOfMonth(2023, 1));

// // Сколько сегодня прошло секунд
// function getSecondsToday() {
//     let now = new Date();

//     let today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); // получил сегодняшний день с 00 часов, минут, секунд
//     let diff = now - today;

//     return +(diff / 1000).toFixed(0);

// }
// console.log(getSecondsToday());

// // Альтернативное решение
// function getSecondsTodayAlt() {
//     let d = new Date();

//     return d.getHours() * 3600 * d.getMinutes() * d.getSeconds(); // получил часы и минуты и преобразовал их в секунды
// }
// console.log(getSecondsTodayAlt());

// Сколько секунд осталось до завтра
// function getSecondsToTomorrow() {
//     let now = new Date();
//     let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);

//     let remainder = tomorrow - now;


//     return parseInt((remainder / 1e3).toFixed(0), 10);
// }
// console.log(getSecondsToTomorrow());

// Форматирование относительной даты
// let date = new Date(new Date - 58e5);

// function formatDate(date) {
//     let diff = new Date() - date; // разница в милисекундах

//     if (diff < 1e3) {
//         return 'прямо сейчас';
//     }

//     let secondsDiff = Math.floor(diff / 1e3); // преобразовал разницу в секунды

//     if (secondsDiff < 60) {
//         return secondsDiff + ' секунд назад';
//     }

//     let minutesDiff = Math.floor(secondsDiff / 6e1); // преобразовал разницу в минуты

//     if (minutesDiff < 60) {
//         return minutesDiff + ' минут назад';
//     }

//     // отформатировать дату
//     // добавить ведущие нули к единственной цифре дню/месяцу/часам/минуте
//     let d = date;
//     d = [
//         '0' + d.getDate(),
//         '0' + (d.getMonth() + 1),
//         '' + d.getFullYear(),
//         '0' + d.getHours(),
//         '0' + d.getMinutes(),
//     ].map(component => component.slice(-2)); // взять последние 2 цифры из каждого компонента

//     // соеденить компоненты в дату
//     return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
// }
// console.log(formatDate(date));

// Формат JSON, метод toJSON

// часто нужно преобразовать объект в строку, для этого подходит toString(){}, но если я имею дело со сложным объектом,
// подобные преобразования могут стать проблемой. Для этого есть специальные методы.
// JSON - общий формат для представления значений и объектов, он может использоваться, когда клиент использует JavaScript,
// а сервер написан на Ruby/PHP/Java или любом другом языке.

// JavaScript предоставляет методы: JSON.stringify - для преобразования объектов в JSON, JSON.parse - для преобразования
// JSON обратно в объект.

// let student = {
//     name: 'Ivan',
//     age: 28,
//     isAdmin: false,
//     courses: ['html', 'css', 'js'],
//     wife: null,
// };

// let json = JSON.stringify(student);
// console.log(json, typeof json); // {"name":"Ivan","age":28,"isAdmin":false,"courses":["html","css","js"],"wife":null} string
// полученная строка называется JSON-форматированным или сериализованным объектом. Его можно отправить по сети и т.д.

// Важной особенностью является то, что в отличие от объектного литерала, строки в JSON используют строго двойные кавычки,
// имена свойств также заключаются в двойные кавычки.

// JSON.stringify может быть применён для примитивов. Сам JSON поддерживает следующие типы данных:
// объекты, массивы, строки, числа, логические значения, null.
// пример:
// console.log(JSON.stringify(1)); // 1 - остаётся числом, но его тип текстовый
// console.log(JSON.stringify('text')); // "text" - остаётся текстом, но в двойных кавычках
// console.log(JSON.stringify(true)); // true - остаётся булевым, но его тип текстовый
// console.log(JSON.stringify([1, 2, 3,])); // остаётся массивом, но его тип текстовый

// JSON является независимой от языка спецификацией данных, поэтому может пропускать некоторые специфичные свойства,
// такие как свойства-функции(методы объекта), символьные ключи и значения, свойства, содержащие undefined. Но это
// поведение можно настроить.

// Замечательно то, что поддерживаются вложенные объекты, они конвертируются в строку автоматически.
// Важное ОГРАНИЧЧЕНИЕ - не должно быть циклических ссылок!
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: ['Johnn', 'Ann'],
// };

// meetup.place = room; // ссылается на room
// room.ocupiedBy = meetup; // ссылается на meetup

// JSON.stringify(meetup); // ERROR: Converting circular structure to JSON

// Исключаем и преобразуем replacer

// полный синтаксис JSON.stringify
// let json = JSON.stringify(value, [replacer, space]), где value - значение для кодирования,
// replacer - массив свойств для кодирования или функция соответствия function(key, value),
// space - дополнительное пространство (отступы), используемые для форматирования.

// в большинстве случаев обычного вызова достаточно, но если мне нужно отфильтровать циклические ссылки, то
// можно использовать второй аргумент.

// если передать массив свойств, то будут закодированны только они
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: [{ name: 'Johnn' }, { name: 'Ann' }],
//     place: room, // ссылается на room
// };

// room.occupedBy = meetup; // ссылается на meetup
// console.log(JSON.stringify(meetup, ['title', 'parcipiants'])); // {"title":"Conference","parcipiants":[{},{}]}

// Здесь список свойств строго определяется ко всей структуре объекта, и внутри parcipiants пустые объекты,
// потому что name нет в списке.

// включу в список свойств все, кроме occupedBy
// console.log(JSON.stringify(meetup, ['title', 'parcipiants', 'place', 'name', 'number'])); // {"title":"Conference","parcipiants":[{"name":"Johnn"},{"name":"Ann"}],"place":{"number":23}}

// теперь всё, кроме occupedBy сериализовано, но список действий довольно длинный
// но в качестве replacer я могу использовать функцию, а не массив. Она будет вызываться для каждой пары (key, value), и она
// должна возвращать заменённое значение, которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.

// в моём случае можно вернуть value "как есть" для всего, кроме occupedBy, occupedBy будет проигнорировано, так как функция
// вернёт undefined

// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: [{ name: 'Johnn' }, { name: 'Ann' }],
//     place: room, // ссылается на room
// };

// room.occupedBy = meetup; // ссылается на meetup
// console.log(JSON.stringify(meetup, function replacer(key, value) {
//     return (key === 'occupedBy') ? undefined : value;
// }, 2));

// важно что функция replacer получает каждую пару ключ-значение, включая вложенные объекты и элементы массива
// Значение this внутри replacer - это сам объект, который содержит теущее свойство.
// Первый вызов особенный - ему передаётся специальный "объект-обёртка" {"": meetup}, другими словами - первая пара
// ключ-значение будет иметь пустой ключ, а значением будет целевой объект в общем. Идея в том, чтобы дать replacer как
// можно больше возможностей - проанализировать весь объект, заменить или даже пропустить весь объект целиком.

// Форматирование space
// для передачи данных по сети этот аргумент не нужен, он нужен, чтобы выводить файл в удобочитаемом виде - для логирования
// и красивого вида.

// Пользовательский 'toJSON'
// как и toString() для преобразования строк, объект может предоставлять метод toJSON для преобразования в строку.
// JSON.srtingify автоматически вызывает его, если он есть, например:
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     date: new Date(Date.UTC(2017, 0, 1)),
//     room,
// };
// console.log(JSON.stringify(meetup)); // {"title":"Conference","date":"2017-01-01T00:00:00.000Z","room":{"number":23}}
// дата стала текстовой, потому что объект Date имеет встроееный метод toJSON, который возвращает строку.

// можно реализовать подобный метод toJSON
// let room = {
//     number: 23,
//     toJSON() {
//         return this.number;
//     },
// };

// let meetup = {
//     title: 'Conference',
//     room,
// };
// console.log(JSON.stringify(room)); // 23
// console.log(JSON.stringify(meetup)); // {"title":"Conference","room":23}

// как видно, toJSON используется как при прямом вызове JSON.stringify, так и когда room вложен в другой сериализуемый объект.

// JSON.parse

// чтобы декодировать строку, мне нужен другой метод - JSON.parse
// его синтаксис: let value = JSON.parse(str, [reviver]);
// str - JSON для преобразования в объект,
// reviver - необязательная функция, которая будет вызываться для каждой пары ключ/значение, может преобразоввывать значения

// пример
// let numbers = "[1, 2, 3, 4, 5, 6]"; // строковый массив
// numbers = JSON.parse(numbers);
// console.log(numbers, numbers[3]); // [1, 2, 3, 4, 5, 6] 4

// или для вложенных объектов
// let user = '{ "name": "Ivan", "age": 28, "isAdmin": false, "friends": [0, 1, 2, 3, 4, 5] }';
// user = JSON.parse(user);
// console.log(user.friends[1]); // 1

// JSON может быть настолько сложным, насколько это необходимо. Объекты могут включать массивы, другие объекты.
// Написанный от руки JSON может включать ошибки - иногда от руки пишут для отладки.
// let json = '{
//     name: "John", // здесь ошибка - ключ без двойных кавычек
//     "surname": 'Smith', // ошибка - одинарные кавычки
//     'isAdmin': false, // одинарные кавычки
//     "birthday": new Date(200,0,3), // нельзя использовать конструктор new, только значения объекта Date
//     "friends": [0,1,2,3,4], // здесь все в порядке
// }';

// Также JSON не поддерживает комментарии - если они есть - файл считается недействительным.
// есть формат JSON5, который поддерживает одинарные кавычки и комментарии, но это отдельная библиотека.
// а строгость обычного JSON нужна для легкой и надёжной и быстрой реализации алгоритма кодирования и чтения.

// Использование Reviver

// допустим, я получил с сервера объект meetup в виде строки данных, вот такой
// title: (meetup title), date: (meetup date)
// let str = '{"title": "Conference", "date": "2017-11-30T12:00:00.000Z"}';

// теперь мне нужно его десериализовать, т.е снова превратить в объект JavaScript
// let meetup = JSON.parse(str);
// console.log(meetup.date.getDate()); // ошибка
// потому, что значением meetup.date является строка, а не объект Date

// теперь я передам JSON.parse функцию восстановления, вторым аргументом, которая будет возвращать значения как есть,
// но date станет Date

// let meetup = JSON.parse(str, function (key, value) {
//     if (key == 'date') return new Date(value);
//     return value;
// });
// console.log(meetup.date.getDate(), meetup.date.getFullYear()); // 30 2017 - работает!

// кстати, это работает и для вложенных объектов
// let scedule = `{
//     "meetups": [
//         {"title": "Conference", "date":"2017-11-30T12:00:00.000Z"},
//         {"title": "bithday", "date":"2017-04-18T12:00:00.000Z"}
//     ]
// }`;

// scedule = JSON.parse(scedule, function (key, value) {
//     if (key == 'date') return new Date(value);
//     return value;
// });
// console.log(scedule.meetups[0].date.getMonth() + 1); // 11 - всё работает!

// Задачи после раздела

// преобразовать объект в JSON, а затем обратно в в обычный объект (прочитать его в другую переменную)
// let user = {
//     name: "Василий Иванович",
//     age: 35,
// };
// // user = JSON.stringify(user);
// // console.log(user, typeof user); // {"name":"Василий Иванович","age":35} string

// // let parseUser = JSON.parse(user);
// // console.log(parseUser.name, parseUser); // Василий Иванович {name: 'Василий Иванович', age: 35}

// // или так
// let parsedUser = JSON.parse(JSON.stringify(user));
// console.log(parsedUser, parsedUser.name); // {name: 'Василий Иванович', age: 35} 'Василий Иванович'

// Исключить обратные ссылки
//  написать функцию для JSON-преобразования, которая удалит свойства, ссылающиеся на meetup
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Совещание',
//     occupiedBy: [{ name: 'Иванов' }, { name: 'Петров' }],
//     place: room,
// };

// // цикличные ссылки
// room.occupiedBy = meetup;
// meetup.self = meetup;

// console.log(JSON.stringify(meetup, function replacer(key, value) {
//     return (key != '' && value == meetup) ? undefined : value;
// })); // {"title":"Совещание","occupiedBy":[{"name":"Иванов"},{"name":"Петров"}],"place":{"number":23}}

// Продвинутая работа с функциями - рекурсия и стек