"use strict";
/* некая директива - явная активация старого кода (пишется как строка - в кавычках)
влючает строгий режим (можно использовать отдельно в функции);
должна находиться в самом начале исполняемого кода, в противном случае,
директива будет игнорироваться. Над ней могут быть записаны только комментарии.
Важно, что по умолчанию в devtools эта директива выключена. Но я могу использовать
многострочный ввод в консоль, и прописать её первой (при тестировании функций).
Иногда, когда use strict имеет значение, я могу получить неправильные результаты.
Если не работает, то:
(function () {
    'use strict';
    ...мой код
})() - и всё.
*/

//задачи после главы
//Работа с переменными
// let admin;
// let name;
// name = 'Джон';
// admin = name;
// alert(admin);
//Придумать правильные имена
//переменная для названия нашей планеты
// let ourPlanet = 'Earth';

//переменная для хранения имени текущего пользователя
// let currentUserName;

//Типы данных (сюда буду писать не всё)
//существуют: number, string, bigint,
//symbol, null, undefined, bollean, object.

//Использование BigInt
//Чтобы исаользовать большие числа, нужно добавить n в конце числа, вот так:
// let veryBig = 1000028768765656563333400n;
//Строка (string)
//можно использовать кавычки "", '', `` (обратные кавычки позволяют
//встраивать выражения в строку), вот так:
// let expression = 2 + 3;
// let result = `Результат вычисления: ${expression}`;
// console.log(result);

//Оператор typeof
//у него етсь две синтаксические формы
//синтаксис оператора typeof a
//синтаксис функции typeof(a)
//Результат одинаковый - он возвращает строку с именем типа данных.

//Взаимодействие: alert, prompt, confirm

//Преобразование типов
//чаще всего операторы и функции сами приводят значения к необходимому типу
//но иногда это нужно делать явно, итак:
//строковое преобразование String(value)
// let someNumber = true;
// console.log(`это переменная с типом ${typeof someNumber}`);
// console.log(`а теперь это та же переменная, но с типом ${typeof String(someNumber)}`);
// console.log('');
//численное преобразование - происходит неявно в мат. ф-ях и выражениях('12'/'4'=3),
//но есть явное преобразование Number(value)
// let myNumb = "437";
// console.log(`Итак, тип переменной сейчас ${typeof myNumb}`);
// console.log(`А теперь ${typeof Number(myNumb)}`);
// console.log('');
//если строка не может явно быть преобразована к числу, то рез-т NaN
//правила численного преобразования
//undefined - NaN, null - o, true/false - 1/0,
//пробельные символы (пробелы, знаки табуляции \t, новая строка \n и т.п.) по краям
//опускаются. Далее, если получается пустая строка, получаем 0, иначе из непустой строки
//считывается значение, иначе получаем NaN.

//Логическое преобразование - самое простое (ф-я Boolean(value))
//Правила преобразования: 0, пустая строка, undefined, null, NaN - false,
//все остальные - true.
// console.log(Boolean('hi'));
// console.log(Boolean(''));
// console.log('Заметим, что:')
// console.log(Boolean(0));
// console.log(Boolean('0'));

//Базовые операторы, математика (здесь будет не всё)
//взятие остатка от целочисленного деления - %, возведение в степень - **
// console.log(5%2); //1
// console.log(5**2); //25
//математически оператор работает и для нецелых чисел,
//например взятие квадратного корня a**(1/2), кубического a**(1/3)
// console.log(4 ** (1/2));
// console.log(8 ** (1/3));

//Сложение строк при помощи бинарного +
// console.log(1 + '21'); //если хотя бы один операнд строка - второй сразу становится строкой
// console.log('slozhil' + ' ' + 'stroku');
//здесь операторы будут работать один за одним
// console.log(2 + 2 + '1'); //41
// сложение и преобразование строк - это особенность бинарного плюса, остальные арифметические операторы работают только с числами,
//и всегда преобразуют операнды в числа. Например, вычитание и деление:
// console.log(4 / '2'); //2
// console.log('5' - 3); //2

//Приведение к числу - унарный +
//он не влияет никак на числа, даже если число отрицательное,
//т.е.: у = -2, значит +у = -2, а вот ниже унарный + выполнит преобразование
// let someN = true;
// let newSomeN = +someN;
// console.log(`До преобразования значение переменной было ${someN}, после преобразования стало ${newSomeN}`);
//на самом деле, это то же самое, что  и  Number(...), просто запись короче.
//необходимость преобразовать строки в числа возникает часто, например значения полей html формы, это почти всегда строки,
//так вот здесь нам поможет унарный +
// let apples = '1';
// let oranges = '2';

// console.log(`здесь я сложил только бинарным плюсом: ${apples + oranges}`); //12
// console.log(`а здесь унирными и бинарным: ${+apples + +oranges}`); 3
//сначала выполнятся унарные плюсы - приведение к числу, а затем бинарный.
//но есть ещё parseInt(expression/value) - лучше использовать его.

//Приоритет операторов
//у унарных операторов приоритет выше, чем у бинарных. Один из самых низких приоритетов
//у присваивания (=), это говорит о том, что сначала выполняется арифметика, и только потом результат присваивается переменной.
//присваивание возвращает значение, именно поэтому его можно использовать, как часть более сложного выражения:
// let a = 2;
// let b = 1;

// let c = 3 - (a = b -1);
// console.log(a);
// console.log(c);
//выше приведён странный пример, такое можно встретить в JS-библиотеках, самому такое писать не стоит. Это делает код менее понятным.

//Сокращённая арифметика с присваиванием
//часто нужно применить оператор к переменной и сохранить результат в ней же
//let n = 2; n = n + 5; n = n * 8 и т.д.
//можно сократить так: let n = 2; n += 5; n *= 8 и т.д. - это вызов с присваиванием.
//он имеет такой же приоритет, как и обычное присваивание.
//let n = 2; n *= 3 + 5 » здсь сначала выполнится правая часть, а потом вызов с присваиванием,
//т.е. n будет равно 16.

//Инкремент/декремент
//++ увеличивает на 1, -- уменьшает на 1. Можно примеять только к переменным.
//операторы ++ и -- могут быть расположены как до, так и после переменной.
//до - префиксная форма ++а возвращает новое значение, т.е. а+1=2 (если а было =1);
//после - постфиксная форма а++ возвращает предыдущее значение (до увеличения), т.е.
//если а = 1, то а++ вернёт 1. Получается, что они делают одно и то же, но выводят разные значения!
//Инкремент/декремент можно использовать в любых выражениях (также внутри выражений). Их приоритет выше, чем у любых других операторов.
// let counter = 1;
// console.log('Приоритет инкрементов/декрементов');
// console.log(2 * ++counter);
// counter = 1; //обнуление counter
// console.log(2 * counter++);
//но таких записей лучше избегть - можно пропустить при беглом чтении кода.
//писать лучше отдельное действие на отдельной строке.

//Побитовые операторы

//Оператор "запятая"
//редко применяется и является одним из самых необычных, иногда используется для написания
//более короткого кода. Он предоставляет возможность вычислять несколько выражений, разделяя их запятой.
//При этом возвращается результат только последнего выражения
// let q = (1 + 2, 3 + 4);
// console.log(q);
//первое вычисление выполняется, а результат отбрасывается, далее выполняется следующее, его рез-т возвращается.
//Запятая имеет очень низкий приоритет, ниже, чем присваивание (=). Поэтому скобки в примере важны.
//Этот оператор используют, чтобы записать несколько действий в одной строке. Во фреймворках тоже такие
//записи используются. Но такие записи не улучшают читаемость кода.
//одна из задач после раздела
// let aB = prompt("Первое число?", 1);
// let bA = prompt("Второе число?", 2);
//console.log(+aB + +bA); //здесь parseInt не сработал, сработал унарный плюс.

//Операторы сравнения (здесь будет не всё)
//равно в ДЖС обозначается, как == (= - это присваивание), не равно обозначается, как !=
//все опараторы сравнения возвращают значение логического типа (true/false). Результат можно присвоить переменной, как и любое значение.
// let w = 5 != 4;
// console.log(`А это результат сравнения, записанный в переменную - ${w}`);
//Сравнение строк
//чтобы определить, что одна строка больше другой ДЖС использует алфавитный и лексикографический порядок,
//другими словами - строки сравниваются посимвольно. Например
// let stroka1 = 'Привет';
// let stroka2 = 'Иван';
// console.log(`stroka1 bigger than stroka2 is: ${stroka1 > stroka2}`); //true
//используется unicode, а не настоящий алфавит. В ДЖС имеет значение регистр символов.
//Так заглавная А будет иметь меньшее значение, чем строчная а, потому что строчные буквы имеют больший код во внутренней
//таблице кодирования, которую использует ДЖС (Unicode)
//Сравнение разных типов
//при сравнивании значений разных типо JS приводит их к числу
// console.log('2' > 1); //true
// console.log('01' == 1); //true, 01 станет 1
// console.log(true == 1); //true
// console.log(false == 0); //true

//Строгое сравнение
//использование обычного сравнения == может вызвать проблемы. Например, оно не отличает
//0 от false 
// console.log(`обычное сравнение не отличает 0 от false: 0 == false  - ${0 == false}`);
//та же проблема и с пустой строкой
// console.log(`та же проблема и с пустой строкой '' == 0 - ${'' == 0}`);
//это происходит потому, что операнды разных типов преобразуются == к числу. Поэтому есть

//Оператор строго равенства ===
//он проверяет равенство без приведения типов, другими словами, если а и b имеют разные типы, то
//проверка а === b вернёт false
// let f = '123';
// let g = 123;
// console.log(`Строго сравню '123' и 123, вот - ${f === g}`);
// console.log('');
// console.log('Сравню null и undefined');
// console.log(`итак, строго - ${null === undefined} - потому что различны их типы`);
// console.log(`нестрого - ${null == undefined} - равны друг другу и не равны другим. Это специальное правило языка`);
//при использовании математических оператров и других операторов сравнения < > >= <= null и undefined преобразуются к числам:
//null становится 0, а undefined становится NaN.
//Странный результат сравнения null и 0
// console.log(null > 0 ); //false
// console.log(null == 0); //false
// console.log(null >= 0); //true
//причина в том, что нестрогое равенство (==) и сравнения (< > <= >=) работают по-разному
//сравнения преобразуют null в число, рассматривая его как 0, поэтому третья строчка будет true.
//с другой стороны, null==0 - false, потому что null==undefined, и не равно ни чему другому.
//undefined несравнимо с другими значениями
// console.log(undefined > 0); //false
// console.log(undefined == 0); //false
// console.log(undefined >= 0); //false

//Как избежать проблем? - следовать правилам:
// ! относиться с осторожностью к сравнениям с null/undefined, кроме случаев строгого равенства
// ! не использовать сравнения >=, <=, >, < с переменными, которые могут принимать значения null/undefined, разве что я
//полностью уверен в том, что делаю. Если переменная может принять эти значения, значит нужно сделать отдельную проверку для них.

//Условное ветвление: if, '?'
//Инструкция if (...) - вычисляет условие в скобках, и если результат true, выполняет блок кода.
//Пример (так писать не очень хорошо), нужны скобки, особенно, когда нужно выполнить несколько инструкций.
// let age = prompt('How old are you?', 'don\'t be a shy');
// if (age == 28) console.log('Ровесники');

// //лучше использовать всегда скобки, даже если инструкция будет одна. Это увеличивает читаемость кода.
// if (age == 28) {
//     console.log('Contemporary');
// }
//инструкция if вычисляет значнеие в скобках и преобразует результат к логическому типу,
//соответственно есть ложные (falsy) и правдивые (truthy) значения. При ложном значении код никогда не выполнится
//if (0) {
//     alert('nepravda')
// };,
// а при правдивом значении выполнится всегда
// if (1) {
//     alert('pravdivo')
// };
//я также могу передать заранее выполненное значение переменной, это удобно,
//если несколько условий - тогда можно каждое условие положить сразу в переменную, примерно так:
// let year = prompt("Input some year", "2022");
// let condition = (year == 2022);
// if (condition){
//     console.log('condition is ok');
// };

//Блок else
//нужен для действий, в случае если условие в блоке if ложно, используется так:
// let userGuesSomeThing = prompt('What is my age?', 'enter here');
// if(userGuesSomeThing == 28) {
//     console.log('Nice!');
// } else {
//     console.log('You are wrong!');
// };

//иногда нужно проверить несколько вариантов, тогда используется else if
// let guessAgainInput = prompt('How old am I?', 'nu sho');

// if (guessAgainInput < 28) {
//     console.log(`It has to be a little less - ${guessAgainInput}`);
// } else if (guessAgainInput > 28) {
//     console.log('It has to be a little much');
// } else {
//     console.log('Finally!');
// };

//Условный оператор "?"
//Его также называют тернарным оператором, т.к. он имеет три аргумента (он единственный в своём роде)

// let newAgeExample = prompt('How old are you?', '');
// let ternarExample = (newAgeExample >= 18) ? console.log('nice come in') : console.log('too small');
//первый аргумент - это условие (скобки в теории можно опустить, т.к. у тернарного оператора очень низкий приоритет)
//второй аргумент - это часть кода, которая вернётся в случае если условие истинно, третья - если ложно.

//Несколько операторов "?"
// let age = prompt('My age', '');

// let message = (age < 3) ? 'baby':
// (age <= 18) ? 'Hello':
// (age <= 100) ? 'You are old' : 'Stragne age';

// console.log(message);
//в примере выше код выполнится последовательно, если первое условие в скобках ложно, то выполнится клод дальше и так либо пока условие не будет правдиво,
//либо пока не закончится условие проверки, противном случает вернётся конструкция последней проверки (вторая часть, та что ложна).

//Нетрадиционное использоование "?"
//иногда тернарный оператор используется вместо конструкции if, но такая запись хуже читается, и рекомендуется использовать конструкцию if.
//напишу для примера
// let question = prompt('What is company created JavaScript', 'Netscape');

// (question == 'Netscape') ? console.log('yes') : console.log('no');
//Одна из задач после раздела
// let = qestionForUser = prompt('Какое официальное название Java Script?', 'ECMAScript');

// if (qestionForUser == 'ECMAScript') {
//     console.log("Верно");
// } else {
//     console.log("Неправильно");
// }

// let userNumberInput = prompt('Enter a number', 'Or not a number');
// let typeCast = Number(userNumberInput);

// if (typeCast > 0) {
//     console.log('1');
// } else if (typeCast < 0) {
//     console.log('-1');
// } else if (typeCast === 0) {
//     console.log('0');
// } else {
//     console.log('You wrote not a number');
// }

//Перепишите if в "?"
// let result;

// if (a + b < 4) {
//     result = 'Мало';
// } else {
//     result = 'Много';
// }
//  let result = (a + b < 4) ? 'Мало' : 'Много';

//перепешите if else в "?" с использованием нескольких операторов
// let message;

// if (login == "Сотрудник") {
//     message = 'Привет';
// } else if (login == "Директор") {
//     message = 'Здравствуйте';
// } else if (login == "") {
//     message = 'Нет логина';
// } else {
//     message = '';
// }

// let message = (login == 'Сотрудник') ? 'Привет' :
//     (login == 'Директор') ? 'Здравствуйте' :
//     (login == '') ? 'Нет логина' : '';

//Логические операторы
//Могут применяться к значениям любых типов
// ИЛИ || - при работе с булевыми значениями - если хотя бы одно из значений true - возвращает true.
//если значение не логического типа, то оно к нему приводится в целях вычислений, например 1 будет воспринято, как true, 0 - как false и т.п.
//обычно оператор || используется для проверки истинности любого из данных условий.
// let hour = 12;

// if (hour < 10 || hour > 18) {
//     console.log('Office is closed');
// }

// isWeekend = true;

// if (hour < 10 || hour > 18 || isWeekend == true) {
//     console.log('Office is closed');
// } else {
//     console.log('Office is open');
// }
//ИЛИ || находит первое истинное значение

// let result = value1 || value2 || value3
//расширенный алгоритм при выполнении ИЛИ с несколькими значениями работает так:
//оператор ИЛИ вычисляет операнды слева направо - каждый операнд конвертируется в логическое значение,
//если значение операнда true, то операция останавливается и возвращается исходное значение этого операнда,
//если все операнды являются ложными, то возвращается последний из них. Значение возвращается в исходном виде без преобразования.
//другими словами, цепочка ИЛИ возвращает первое истинное значение или последнее, если такое значение не найдено.
//Из нестандартных способов использования я знаю теперь (испоьзуется также в JS):

//1. получение первого истинного значения из списка переменных или выражений: допустим, у меня есть список переменных,
//которые могу принимать значения null или undefined, ок - а как мне найти среди них переменную с данными? - || ИЛИ, например
// let cuerntUser = null;
// let defaultUser = 'Ivan';

// let findName = cuerntUser || defaultUser || 'unnamed'; // выберется Ivan - первое правдивое значение, если первые две переменные были бы ложными,
//то в результате выявилось бы unnamed

//2. сокращённое вычисление - операндами может быть, как произвольные выражения, так и отдельные значение - ИЛИ || вычислит их слева направо.
//Вычисление остановится при достижении первого истинного значения. Поэтому этот процесс и называется сокращённым вычислением, ведь следующий этап
//вычисления выполнится (операнд вычислится), только если первого будет недостаточно для вычисления всего выражения
// let x;
// p = true || (x = 1);
// console.log(x);

// И && - находит первое ложное значение
//а при нескольких операторах И, result = value && value && value - он также как и ИЛИ вычисляет выражения слева направо,
//каждый операнд преобразуется в логическое значение, если результат фолс - останавливается и возвращается исходное значение этого операнда.
//если все операнды были истинными - возвращается значение последнего операнда.
// let someVarResult = 56 && 'string' && null && 0; // вернётся null
// 55 && 34 && true && 23 - вернётся 23, потому что все истинные значения
//Приоритет И && выше, чем у ИЛИ ||, также как и ИЛИ оператор И может заменять if, например
// let x = 1;
// (x > 0) && console.log('Greater than zero');
//но, как и ранее - лучше использовать if

// ! НЕ
//синтаксис такой - result = !value
//оператор НЕ сначала приводит значение к логическому типу, затем возвращает его противоположное значение. Например
// let operatorNe = true;
// console.log(!operatorNe);
//Двойное НЕ часто используется для преобразования значений к  логическому типу
// console.log(!!'not empty string'); //true
// console.log(!!null); //false
//Получается, что первое НЕ преобразует значение в логическое и возвращает обратное, а второе НЕ снова инвертирует его.
//Тоже самое делает ф-я Boolean('not empty string').
//Приоритет НЕ является наивысшим среди логических операторов, поэтому он всегда выполняется первым, перед && и ||.
//Задачи после раздела
// console.log(null || 2 || undefined);
// alert(alert(1));
//- написать код, который проверяет, находится ли значение в диапазоне между 14 и 90 включительно.
// let age = prompt('Enter some age', '28');

// if (age >= 14 && age <= 90) {
//     console.log('The value is in the range');
// } else {
//     console.log('The value is not in the range');
// }

//написать код для проверки, что значение переменной не находится в диапазоне от 14 до 90 включительно
//два варианта - первый с использованием НЕ, второй без этого оператора

// let age = prompt('Value', '28');
// //первый вариант
// if (!(age >= 18 && age <= 90)) {
//     console.log('I - The value is not in the range');
// } else {
//     console.log('I - The value is in the range');
// }
// //второй вариант
// if (age < 18 || age > 90) {
//     console.log('II - The value is not in range');
// } else {
//     console.log('II - The value is in range');
// }
//Проверка логина
// let userInputLogin = prompt('Enter your login', '');

// if (userInputLogin === 'Admin') {
//     let adminPassword = prompt('Enter password', '');

//     if (adminPassword === 'Imincharge') {
//         alert('Zdravstvuyte');
//     } else if (adminPassword === '' || adminPassword === null) {
//         alert('Canceled');
//     } else {
//         alert('Wrong password');
//     }

// } else if (userInputLogin === '' || userInputLogin === null) {
//     alert('Canceled');
// } else {
//     alert('I don\'t know who you are');
// }

//Оператор нулевого слияния "??"
//он обрабатывает null undefined одинаковым образом. Для текущей статьи в учебнике автор ввёл понятие - 
//значение "определено", если оно не равно null или undefined.
//Результат выражения a ?? b будет таким:
//если a определено, то a; если a не определено, то b.
//Иначе говоря, оператор ?? возвращает первый аргумент, если он не null или undefined, иначе возвращает второй.
//вот так можно переписать выражение result = (a != null && a != undefined) ? a : b
// result = a ?? b
//в этом примере я отображу имя пользователя, если оно "определено", в противном случае - аноним.

//Сравнение || и ??
//Основное различие заключается в том, что || не различает false, 0, пустую строку, undefined, null - для него это одно и то же - ложное,
//то есть он выводит первое "истинное" значение, а оператор нулевого слияния выведет первое "определённое", т.е. не null/undefined.
//В учебнике, в пользу ?? описан кратко пример с нулевой высотой.
//Приоритет у ?? и || одинаковый, он выше, чем у тернарного оператора и присваивания, но ниже, чем у +-* и тд, поэтому нужны скобки.
//Запрещено использовать ?? вместе с || ИЛИ, && И, если приоритет явно не указан в виде скобок.

//Циклы while и for
//Циклы нужны для многократного повторения одного участка кода
//While имеет синтаксис:
// while (condition) {
//код - "тело" цикла
//} // пока истинно условие тело цикла будет выполняться
// let someVar = 1;

// while (someVar <= 10) {
//     console.log(`Это значение переменной someVar: ${someVar}`);
//     someVar++;
// }
//Любое значение или переменная может быть условием цикла, условие while вычисляется и преобразуется в логическое значение
//например while (i) - более краткий вариант записи while  (i != 0) ->
// let i = 3
//  while (i) {
//     console.log(i);
//     i--;
// }
//Фигурные скобки не требуются для тела цикла из одной строки, т.е. while (i < 3) console.log(i++);

//Цикл do...while - отличается тем, что сначала выполнится тело цикла, а потом проверка условия.
// let i = false;
// do {
//     console.log(i);
// } while (i);
//это иногда нужно для того, чтобы выполнить хоть раз код при любом условии.

//Цикл for
//for (начало; условие; шаг), начало - выполняется один раз при входе в цикл; условие проверяется перед каждой
//итерацией цикла, если условие вычислится в false - цикл остановится; тело - выполняется, пока условие true;
//шаг - выполняется после тела цикла на каждой итерации перед проверкой условия.
// for (let i = 3; i >= 0; i--) {
//     console.log(i);
// }
//переменная, объявленная в пределах цикла, доступна только в пределах цикла. Можно не объявлять переменную внутри цикла, а использовать объявленную ранее.

//Прерывание цикла break
//обычно цикл завершается после того, как условие вычисляется в false, но бывает, когда нужно
//досрочно прервать выполнение цикла, для этого есть директива break.
// let sum = 0;
//  while (true) {
//     let value = +prompt('Enter a nuber', '');
//     if (!value) break;
//     sum += value;
//  }
//  console.log(`Уже столько ${sum}`);
//в примере выше директива break прекращает выполнение цикла и передаёт управление нас троку за его телом (527).

//Переход к следующей итерации : continue
//это облегчённая версия break, она не прерывает выполнение цикла, а переходит к следующей итерации, если условие всё ещё true.
//ниже я выведу только чётные значения, потому что континуе прервёт каждую итерацию, которая вернёт чётное число.
// let i = 0;
// for (i = 0; i < 6; i++) {
//     if (i % 2 == 0) continue;
//     console.log(i);
// }
//в примере выше continue помог избежать вложенности (она усложняет читаемость кода). Ниже напишу код со вложенностью
// let i = 0;
// for (i = 0; i < 6; i++) {
//     if (i % 2 == 0) {
//         console.log(i);
//     }
// }
//НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ break/continue c ? (тернарным оператором), т.к. эти синтаксические конструкции не являются выражениями. Такое использование вызовет ошибку.
//Метки для break/continue
//бывает так, что мне нужно выйти одновременно из нескольких уровней цикла сразу - допустим, мне нужно пройтись по i и j,
// запрашивая с помощью prompt координаты i и j с 0, 0 до 2, 2.
// for (let i = 0; i < 3; i++) {
//     for (let j = 0; j < 3; j++) {
//         let inputCoordinates = prompt(`Enter coordinamtes (${i}, ${j})`, '');
//     }
//что если я хочу перейти к done прямо отсюда?
// }
// console.log('Done');
// мне нужен способ остановить выполнение, если пользователь отменит ввод.
//break после input лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого можно при помощи меток.
// Метка имеет вид идентификатора с двоеточнием перед циклом.
// labelName: for (...) {...}. Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
// myLabel:for (let i = 0; i < 3; i++) {
//     for (let j = 0; j < 3; j++) {
//         let inputCoordinates = prompt(`Enter coordinates (${i}, ${j})`, '');

//         if (!inputCoordinates) break myLabel;
//         console.log(i, j);
//     }
// }
// console.log('Done');
//в примере выше описано, что вызовом break myLabel будет разорван внешний цикл до метки с именем myLabel. Таким образом, управление перейдёт на стр 568.
//директива continue также может быть использована с меткой. Важно, что метки не позволяют прыгнуть в любое место кода.
//были задачи на инкременты и то, как работают циклы, далее вывод чётного значения, замена for на while.

// Напишите цикл, который предлагает prompt ввести число, большее 100 . Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
// Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100 , либо не нажмёт кнопку Отмена (ESC).
// Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.
//ЭТО МОЁ РЕШЕНИЕ
// let userInput = parseInt(prompt ('Enter number bigger than 100'), 10);

// while(userInput <= 100) {
//     userInput = parseInt(prompt ('Try again', ''), 10);

//     if (userInput > 100 || !userInput) break;
//  }
//  console.log('Done!');
//ЭТО РЕШЕНИЕ ПО КНИГЕ
// let userInput;
// do {
//     userInput = prompt ('Enter number bigger than 100', '');
//     console.log('Nice');
// } while (userInput <= 100 && userInput);

//Напишите код, который выводит все простые числа из интервала от 2 до n . Для n = 10 результат должен быть 2,3,5,7 .
// P.S. Код также должен легко модифицироваться для любых других интервалов.
// let n = 10;

// stopLabel:
// for (let i = 2; i <= n; i++) {
//     for (let j = 2; j < i; j++) {
//         if (i % j == 0) continue stopLabel;
//     }
//     console.log(`prime number ${i}`);
// }

//Конструкция switch
//она заменяет собой несколько if, позволяет наглядно сравнить выражение сразу с несколькими вариантами
//имеет не менее одного блока case и необязательный блок default, который выполнится в случае, если все условия в констукции ложны.
// let d = parseInt(prompt('Угадай число', ''), 10);

// switch(d) {
//     case 1:
//         console.log('Это очень мало, давай дальше');
//         break;
//     case 2:
//         console.log('Кейс 2, всё ещё мало');
//         break;
//     case 3:
//         console.log('Это оно');
//         break;
//     default:
//         console.log(`Эта часть кода выполнится по-любому.\nТы ввёл ${d}, но такого значения нет в списке проверок.`)
// }
//если убрать break, то выполнение пойдёт ниже по следующим кейсам.
// !Любое выражение может стать аргумантом для switch/case? типа switch(a + b)...case i >= j:...
//Группировка case
// let a = +prompt('Угадай число', '');

// switch (a) {
//     case 1:
//     case 2:
//     case 3:
//         console.log(`Группировка case. Всё от 1 до 3 включительно - хуета`);
//         break;
//     case 4:
//         console.log('Молодец, правильно');
//         break;
//     case a > 4:
//         console.log('Это больше');
//         break;
//     default:
//         console.log('Default');
// }
//Проверка на равенство всегда строгая, значения должны быть одного типа, чтобы выполнялось равенство.

//Функции
// let myName = 'Ivan';

// function changeName() {
//    let myName = 'name from function';
//     console.log('Hi, I\'m ' + myName);
// }

// changeName();
// console.log('Now my name is ' + myName);

//функции могут использовать глобальные переменные, могут изменять их значение. А если внутри функции объявлена переменная
//с таким же именем, как и глобальная, то функция будет использовать локальную для себя переменную, а значение глобадльной
//будет проигнорировано.

//Аргументы фунции
// function message (from, text) {
//     console.log(from + ': ' + text);
// }
// message('Ivan', prompt('write something', ''));
// function message (from, text) {
//     from = '*' + from + '*';
//     console.log(from + ': ' + text);
// }

// let from = 'Ivan';

// message(from, 'Привет');
//значение, передаваемое в качестве параметра ф-ции также является аргументом, другими словами - 
//параметр - переменная, указанная в круглых скобках в объявлении ф-ции, аргумент - значение, которое передаётся ф-ции при её вызове.
//т.е., я объявляю функцию со списком параметров, а вызываю её передавая аргументы.

//Параметры по умолчанию
//Если прамент не указан, его значением становится undefined. Та же ф-я message может быть вызвана с одним аргументом, ошибки не будет,
//просто второй параметр будет undefined

// function message (from, text) {
//     from = '*' + from + '*';
//     console.log(from + ': ' + text);
// }

// message ('Иван');

//В вызове не указан парметр text, поэтому подразумевается, что text === undefined. Если я хочу задать text параметр по умолчанию,
//то мне нужно указать после =:
//  function message (from, text = 'параметр по умолчанию') {
//     text = prompt('enter message', '') ?? 'параметр по умолчанию';
//      console.log(from + ': ' + text);
//  }
//  message('Ivan');
// в качестве параметра по умолчанию можно также передавать более солжные конструкции, например другую функцию - 
//function message(from, text = someFunction()) {...}; someFunction передастся тлько если не передан text.
//в JS параметры по умолчанию вычисляются каждый раз, когда ф-я вызывается без соответствующего параметра.

//Возврат значения
// function checkAge (age) {
//      if(age >= 18) {
//          return true;
//       } else {
//           return confirm('Do you schenok?');
//         //   return false;
//       }
// }

//  let age = +prompt('input age', '');

// if (ageCheck(age)) {
//     console.log('acces allowed');
// } else {
//     console.log('acced denided');
// }
//return можно также использовать и без значения, в таком случае происходит немедленный выход из функции. Например:
// function showMovie (age) {
//     if(checkAge === null || checkAge === undefined) {
//         return;
//     }
//     console.log('Showing movie');
// }
//Результат ф-ции с путсым return или без него === undefined. Если ф-я не возвращает значения,
//то это всё равно, как если бы она возвращала undefined.
//еслия хочу, чтобы возвращаемое выражение знимало несколько строк, то мне нужно начать его
//на той же строке, что и return или хотя бы поставить на той же строке открывающую скобку:
//return (
//     some + long + expression
//     + or + 
//     whatever * f(a) * f(b);
// )
//каждая отдельная функция должна выполнять что-то одно, либо только проверять, либо только присваивать
//и т.д. Имя функции обычно состоит из глагольного префикса и к чему он применяется - calcSum.
//обычно в командах разработчиков договариваются конкретно о нейминге ф-й.
//получается, что когда функции используются грамотно, а также правильно именуются, гораздо
//проще читать и тестить/отлаживать код, ф-я как бы становится комментарием.

//ЗАДАЧИ ПОСЛЕ РАЗДЕЛА
//Перепишите функцию, используя оператор '?' или '||'
// function checkAge(age) {
//     if (age > 18) {
//     return true;} else {
//     return confirm('Родители разрешили?'); }
//     }

// checkAge(18);

// function checkAge (age) {
//  return (age > 18) ? true : confirm('Did your parents allow?');
// return age > 18 || confirm('Did your parents allow?');
// }

// checkAge(18);
//написать ф-ю, которая возвращает меньшее из чисел

// function showLesser(a, b) {
//     if (a < b) {
//         return a;
//     } else if (b < a) {
//         return b;
//     }
//     return 'Equal';
// }
// console.log(showLesser(3, 3));

//(стр. 105) Написать ф-ю, которая возвращает x в степени n. Иначе говоря, умножает x на себя n раз и возвращает результат.
//например pow(3, 3) = 3 * 3 * 3 = 9;
//Создать страницу, которая запрашивает x и n, а затем выводит результат pow(x, n).
//П.С. В этой задаче функция обязана поддерживать только натуралные значения n, т.е. целые от 1 и выше.
// function pow(x, n) {
//     let result = x;

//     for(let i = 1; i < n; i++) {
//         result *= x;
//     }
//     return result;
// }
//  let x = +prompt('x ?','');
//  let n = +prompt('n ?', '');

// if (n < 1 || n % 1 === 0) {
//     console.log('нужно натуральное целое значение')
// } else {
//     console.log(pow(x, n));
// }

// Function Expression
// let someVar = function() {
//     console.log('I\'m function expression');
//     return 'return';
// };//примечательно, что после ф-экспрешн нужна ;
// console.log(someVar());
//функция по сути, это значение, и я могу работать с ней, как с любым другим значением.
// В примере выше, указав переменную с функцией, то есть экспрешн в строчном выводе - я просто
// получил код этой функции, а вызвав её со скобками я инициирую её код, как бы я просто вызвал функцию.
//я также могу скопировать ф-ю в другую переменную
// let a = someVar;
// a();
//или так
// function sayHi() {
//     console.log('Saying hi');
// }

// let b = sayHi;
// b();

//Функции-"колбэки"
// function ask(question, yes, no) {
//     if(confirm(question)) yes();
//     else no();
// }

// function yes() {
//     console.log('You\'re agree');
// }

// function no() {
//     console.log('You aren\'t agree');
// }

// ask('Do you agree?', yes, no);
//что получается, получается, что колбэк, это ф-я, передаваемая в качестве аргумента другой
//функции и вызываемая позже, после наступления того или иного события. В моём случае, yes() - 
//это колбэк для ответа yes.
//я могу переписать этот пример короче при помощи function expression
// function ask(question, yes, no) {
//     if(confirm(question)) yes();
//     else no();
// }

// ask(
//     'Вы согласны?',
//     function() {console.log('Я согласен')},
//     function() {console.log('Я не согласен')}
// );
//получается, что я в качестве значений передал две анонимные ф-ции (у них нет имён),
//они недоступны снаружи ask, потому что они не присвоены переменным - это то, что мне нужно.
//Получается, что функции - это значения, передающие действия. Обычные значения, как строки, числа
//передают данные, а функции можно воспринимать, как действие. Я могу передавать их в переменную
//и вызывать, когда захочу.
//Одним из ключевых отличий (помимо синтаксиса) между Function expression и Function Declaration
//то, что expression нельзя вызвать до непосредственно строки объявления ф-ции, а declaration можно.
//Это связано с тем, как движок JS парсит код - он сначала создаёт функции, объявленные при
//помощи declaration, как бы инициализируя их предварительно, expression инициализируется только
//после того, как движок дойдёт до самой строчки, где объявляется expression.
//В строгом режиме, когда Function Declaration находится в блоке {...}, ф-я
// доступна везде внутри блока, но не снаружи него, т.е.:

// let age = prompt("Сколько Вам лет?", 18);
// let welcome;
// // в зависимости от условия объявляем функцию
// if (age < 18) {
//     function welcome() { alert("Привет!");
//     }} else {
//     function welcome() { alert("Здравствуйте!");
//     }}
// // ...не работает
// welcome(); // Error: welcome is not defined

// чтобы welcome() была доступна снаружи if нужно использовать объявление функции
// при помощи function expression

// let age = 16;
// let welcome;

// if (age < 18) {
//     welcome = function() {
//         console.log('Привет');
//     };
// } else {
//     welcome = function() {
//         console.log('Здравствуйте');
//     };
// }

// welcome();
//это можно упростить, используя условный оператор (тернарный)
// let age = 18;
// let welcome = (age < 18) ? 
//     function() {console.log('Привет');}:
//     function() {console.log('Здравствуйте');};

// welcome();
//Function Expression нужно использовать преимущественно тогда, когда мне нужно условное
//объявление, как в примере выше, в остальных случаях лучше использовать Function Declaration.

//Стрелочные функции, основы
// let sum = (a, b) => a + b; //пример стрелочной ф-ции
// console.log(sum(2, 3));
//это то же самое, что и function sum(a, b) {
//     return a + b;
// }

// let double = n => n * 2; //пример без скобок
// console.log(`arrow double with no brackets equal ${double(3)}`);

// let noArgsArrow = () => console.log('No args aroow func'); //пример без аргументов
// noArgsArrow();

//их можно использовать также, как и Function Expression
// let age = 21;
// let welcome = (age > 18) ?
//     () => console.log('Здравствуйте'):
//     () => console.log('Привет');

// welcome();

//Многострочные стрелочные функции
//если мне нужна более сложная стрелочная функция, то мне нужно будет использовать фигурные
//скобки и return - его использование становится обязательным с появление фигурных скобок
// let sumMultiString = (a, b) => {
//     let result = a + b;
//     return result;
// }
// console.log(sumMultiString(2, 3));

//В итоге - главная цель стрелочных ф-ций (пока что) - это краткость. Я могу их использовать
//в качестве колбэков или простых однострочных действий.

//Отладка
//Условная точка останова - брейкпоинт, который ставится ПКМ на нужной строке. Эта точка сработает (т.е. выполнение кода остановится),
//если выражение, которое я укажу при создании этой точки истинно.
//Это удобно, когда мне нужно остановиться только при определённом параметре ф-ции.
//Команда debugger - пишется прямо в файл скрипта Она не сработает, если не открыты инструменты разработчика.
//Линтеры - автоматизированные средства проверки кода. Они проверяют стиль кода и могут вносить предложения по его улучшению.

//Объекты - используются для хранения коллекций различных значений и более сложных сущностей.
//Объект может быть создан при помощи {}. Данные внутри объекта - пара "ключ : значение"
//  let myNewObject = {
//     name : 'Ivan',
//     age : 28,
//     isHuman : true,
//  };
//Пустой объект можно создать при помощи одного из двух вариантов синтаксиса:
//конструктор объекта: let user = new Object();
//литерал объекта (литеральная нотация): let user = {}; - используется чаще всего
//Для обращения к свойствам используется запись через точку

// console.log('Получаю значение свойстd объекта - ' + myNewObject.name);
// myNewObject.lastName = 'Linnik';
// console.log('Добаввил ещё одно свойство со значением, а ниже вызвал сам объект с его свойствами');
// console.log(myNewObject);
// delete myNewObject.isHuman;
// console.log('Удалил свойство и ниже снова вызову объект');
// console.log(myNewObject);
// myNewObject['some feature'] = 'something';//имя свойства с пробелом - поэтому вызов через квадратные скобки.
// console.log(myNewObject);

//Объект, объявленный как константа может изменяться. Это связано с тем, что
//const защищает от изменений только переменную, а не её содержимое, т.е., если я в myNewObj положу например "Привет" - будет ошибка.

// const newObj = {
//     name : 'Viktoria',
//     lastName : 'Marakhovskaya',
// };
// console.log(`lastName до изменения: ${newObj.lastName}`);
// newObj.lastName = 'Linnik';
// console.log(`lastName после изменения: ${newObj.lastName}`);

//Вызов свойств объекта при помощи квадратных скобок является универсальным, и позволяет взаимодействовать с любыми ключами, а
//точечная нотация требует, чтобы ключи именовались по правилам именования переменных - не начинались с цифры, без пробелов и т.д.
//квадратные скобки также дают возможность обратиться к свойству, имя которого может быть результатом выражения. В примере из книги имя
//свойства хранится в переменной
// let user = {
//     name : 'Ivan',
//     gender : 'male',
// };

// console.log(user);

// let key = prompt('enter something', 'likes birds');
// user[key] = true;

// console.log(user);
// console.log(`Интересно - доступ к значению ключа. Точечная нотация так не умеет. Только квадратные скобки.
//             А вот и значение: ${user[key]}.
//             Точечная нотация вернула андефайнед.
// `);

//Вычисляемые свойства
//Я могу использовать квадратные скобки для создания вычисляемого свойства в литеральной нотации

// let fruit = prompt('what a...', 'apple');

// let bag = {
//     eggs : 10,
//     [fruit + 'Computers'] : 5,
// };

// console.log(bag);
//Свойства из переменной
// Зачастую необходимо использовать существующие переменные как значения для свойств с тем же именем

// function makeUser(name, age) {
//     return {
//         name : name,
//         age : age,
//     };
// }

// let user = makeUser('Ivan', 28);
// console.log(user);
// console.log(user.name);
// console.log(user.age);
//в примере выше названия свойств name и age совпадают с названиями переменных,
// которые я подставляю в качестве значений этих свойств. Для этого есть специальные короткие свойства для упрощения этой записи

// function makeUser(name, age, isHuman) {
//     return {
//         name,
//         age,
//         isHuman : true, //здесь я показал, что могу использовать обычные и короткие свойства
//     };
// }

// let user = makeUser(prompt('name is...', 'Ivan'), +prompt('age is...', 28));//а это фанкшн экспрешн
// let humanCheck = user.isHuman ? 'человек' : 'хуй пойми что';// а здесь я просто вспомнил про тернарный оператор

// console.log(`пользователь ${user.name}, ему ${user.age} лет и он ${humanCheck}`);

//Ограничений на имена свойств нет, свойства можно называть даже зарезервированными словами лэт, фор, ретёрн 'for : 5'.
//С другой стороны, что бы не ввёл пользователь в качестве ключа значнеия - это будет преобразовано к строке, если он
// ввёл 0 : 'hello', значит это будет '0' : 'hello'.

//Проверка существования свойства. Оператор "in".
//Её можно выполнить так
// let user = {
//     name : 'Ivan',
//     age : 28,
// };
// console.log(user.noSuchProperty === undefined);//true
// console.log(user.name === undefined);//false
//Также наличие свойства в объекте можно проверить при помощи оператора in
// let user = {
//     name : 'Ivan',
//     age : 28,
// };

// console.log('age' in user);//указано в кавычках
//если я опущу кавычки, значит, что я указываю переменную, в которой находится имя свойства:
// let user = {age : 30};
// let key = 'age';

// console.log(key in user);
//Оператор in мне нужен для того, чтобы когда свойство сущесвует, но имеет значение undefined.
//В таком случае проверка выполнится неправильно. Вот, как это может быть:
// let user = {
//     test : undefined,
//     name : 'Ivan',
// };

// console.log(user.test);//само значение свойства
// console.log(user.test === undefined);//хуёвая проверка пишет true - не правда
// console.log('test' in user);//пишет true - правда

//Цикл for...in - используется для перебора всех свойств объекта, вот так
//for (key in object) {
//выполнится для каждого свойства объекта
// }
// let user = {
//     name : 'Vika',
//     age : 31,
//     isHuman : true,
//     gender : 'woman',
// };

// for (let prop in user) {
//     console.log(`ключ ${prop} и его значение ${user[prop]}`);
// }
//обратиться к ключу - prop, обратиться к значению user[prop]

//Упорядочивание свойств объекта
//свойства внутри объекта упорядочены особым образом: свойства с целочисленными ключами
//сортируются по возрастанию, остальные - располагаются в порядке создания.

// let codes = { 
//     49 : 'Германия',
//     '41' : 'Швейцария',
//     '44' : 'Великобритания',
//     //..,
//     '1' : 'США',
// };

// for (let code in codes) {
//     console.log(+code, +code + ' : ' + codes[code]);//вывел номера в порядке возрастания
// }//тут ещё момент, если хочу получить число именно как число, то не стоит использовать
//сложение со строкой, т.к. на выходе я из числа получу строку.

//так вот, целочисленные свойства, это когда строка может быть преобразована в число и обратно
//без изменений '49' - такое свойство, а вот '+49' - уже нет.
//Интересно ещё, что ключ объекта всегда возвращает строку, не зависимо от того, что в него
//изначально передали.

//Встроенная ф-я, которая удаляет десятичную часть Math.trunc
//так мне показали что такое целочисленные свойства
// console.log(`Удалю десятичную часть 49:  ${
//     String(Math.trunc(Number('49')))
// }`);
// console.log(`Удалю десятичную часть +49: ${
//     String(Math.trunc(Number('+49')))
// }`);
// console.log(`Удалю десятичную часть 1.2: ${
//     String(Math.trunc(Number('1.2')))
// }`);

// let codes = { 
//     49 : 'Германия',
//     '41' : 'Швейцария',
//     '44' : 'Великобритания',
//     //..,
//     '1' : 'США',
// };

// for (let code in codes) {
//     console.log(+code, codes[code]);//вывел номера в порядке возрастания
// }

// console.log('а что если нужно вывеcти ключи для жителя Германии');
// console.log(`добавить плюс передкаждым значением, чтобы сделать
// код нецелочисленным
// `);

// let codes2 = { 
//     '+49' : 'Германия',
//     '+41' : 'Швейцария',
//     '+44' : 'Великобритания',
//     //..,
//     '+1' : 'США',
// };

// for (let code in codes2) {
//     console.log(+code, codes2[code]);//вывел номера в порядке возрастания
// }
// console.log(`это сработало, потому что если ключи нецелочисленные,
// то они перебираются в проядке создания`);

//Некоторые задачи
//ф-я, которая возвращает true, если у объекта нет свойств
//  let user = new Object();

//  function isEmpty(Object) {
//     //если цикл найдёт хоть одно значение - вернётся false
//     for (let key in Object) {
//         return false;
//     }
//     return true;
//  }
// //проверил
//  console.log(isEmpty(user));
//  user.name = 'Ivan';
//  console.log(isEmpty(user));



//Написать код, который суммирует все зарплаты команды
// let salaries = {
//     John : 100,
//     Ann : 160,
//     Pete : 130,
// };

// let sum = 0;

// for (let personalSalary in salaries) {
//     sum += salaries[personalSalary];
// }
// console.log(sum);

//Создать ф-ю, которая умножает все числовые свойства объекта на 2
//ф-ции ничего не нужно возвращать, только напрямую изменять объект. Использовать type of
//для проверки типа объекта
//  let menu = {
//     width : 200,
//     height : 300,
//     title : 'My menu',
//  };

// console.log(menu);

//  function multiplyNumeric(obj) {
//     for (let key in obj) {
//         if (typeof obj[key] == 'number') {
//             obj[key] *= 2;
//         }
//     }
//  }

// multiplyNumeric(menu);

//  console.log(menu);

//Копирование объектов и ссылки
//Важно - в отличие от примитив, объекты хранятся и копируются по ссылке. Примитивы же
// копируются, как целые значения.
//То есть, присвоение объекта переменной по сути является передачей ссылки на объект, а не
//передачу самого объекта, сам же объект хранится где-то в памяти. На один объект может
// быть несколько ссылок. Собственно при копировании объекта копируется только ссылка, а не
//сам объект не дублируется. После копирования изменять объект можно через любую из переменных.

//Сравнение по ссылке
//Два объекта равны, только если это один и тот же объект.
// let user = {};
// let huyuser = user; -> user == huyuser;//true
// let neuser = {}; -> user == neuser;//false
//Для сравнений типа obj1 > obj2 или obj == 5 объекты преобразуются специальным образом,
//но мне пока это не нужно, да это и в целом не нужно. Такие сравнения, как правило - ошибка программиста.

//Клонирование и объединение Object.assign
//Чтобы создать независимую копию, нужно создать новый объект и передать ему
// всю структуру существующего. В JS нет для этого встроенного метода.
// let user = {
//     name : 'Ivan',
//     age : 28,
// };
// let clone = new Object ();

// console.log(user);

// for (let key in user) {
//     clone[key] = user[key];
// }
// clone.name = 'Vika';
// // delete clone.age;
// console.log(clone, 'age' in clone);

//Также для этого можно использовать метод Object.assign
// let user = {
//     name : 'Ivan',
//     age : 28,
// };

// let user2 = {
//     $name: 'Vika',
//     $age: 31,
// };

// console.log(user);

// let sameUser = {};

// Object.assign(sameUser,user, user2);

// console.log(sameUser);

//если у свойств одинаковые имена - они будут перезаписаны.
//получается, что я могу исопльзовать Object.assign для простого клонирования вместо for..in.

//Вложенное клонирование
//что делать если свойства объекта не являются примитивами?
// let user = {
//     name : 'Ivan',
//     age : 28,
//     sizes : {
//         width : 65,
//         height : 165,
//     },
// };

// console.log('the whole object user->', user);
// console.log('current feature user->', user.sizes.width);

//получается, что теперь недостаточно скопировать объект так clone.sizes = user.sizes, потому
//что user.sizes это объект, и он будет скопирован по ссылке, и clone и user будут иметь общий
//объект.

//чтобы это исправить, мне нужно использовать цикл клонирования, который будет проверять
//каждое значение user[key], и если это объект, то также будет копировать его структуру.
//Это называется глубоким клонированием. Также можно использовать готовые реализации
//_.cloneDeep(obj) из библиотеки JS lodash.

//Методы объекта this


// let user = {
//     name : 'Ivan',
//     age : 28,
// };
//научу объект здороваться при помощи метода sayHi
// user.sayHi = () => console.log('Hello, my name is', user.name);

//Cокращённая запись метода в литерале объекта

// let user = {
//     name : 'Ivan',
//     age: 28,
//     // полная запись
//     // sayHi : function() {
//     //     console.log('Hello, I\'m', user.name);
//     // }
//     // сокращённая запись
//     sayHi () {
//         console.log('Hello, I\'m', user.name);
//     }
// };
//сокращённая и полная записи не эквивалентны - есть тонкие отличия при наследовании (позже),
//всё равно, предпочтительнее сокращённая запись.

//Ключевое слово this в методах
//Функцию которая является свойством объекта называют методом объекта
//Как правило, методу объекта обычно требуется доступ к другим свойствам объекта, например
//например методу, который здоровается, может понадобиться имя пользователя, которое также
//хранится в объекте

// let user = {
//     name : 'Ivan',
//     age : 28,
//     sayHi() {
//         console.log('Hello, my name is', this.name);//здесь this - это ссылка на объект user
//     },
//     isHuman : true,
// };

// user.sayHi();
//для доступа к информации внутри объекта, метод может использовать ключевое слово this.
//технически я могу получить доступ к свойству и через внешнюю переменную, в которой хранится
//ссылка на данный объект. Но такой код не надёжен, при изменении содержимого переменной user - 
//замене ссылки на объект любой примитивой - user.name уже не будет работать, а this.name сработает.
//В JS this не является фиксированным. Это ключевое слово может использоваться из любой функции,
//даже если это не метод объекта. This  вычисляется в момент выполнения кода в зависимости
// от контекста ->

// let user = {name : 'Ivan'};
// let admin = {name : 'Vika'};

// function hi() {
//     console.log(this.name);
// }

// user.f = hi;
// admin.f = hi;

// user.f();
// admin.f();

//я могу вызвать даже функцию без объекта 
// function hi() {
//     console.log(this);
// }

// hi();//здесь я получу undefined

//У стрелочных функций нет this
//если я ссылаюсь на this в таких функциях, то оно возьмётся из внешней "нормальной" функции.
// let user = {
//     firstName : 'Ivan',
//     age : 28,
//     sayHi() {
//         let arrow = () => console.log(this.firstName);
//         arrow();
//     },
//     isHuman : true,
// };

// user.sayHi();

//Задачи
//Создать калькулятор
// let calculator = {
//     read() {
//         this.firstValue = +prompt('enter first number', '28');
//         this.secondValue = +prompt('enter second number', '2');
//     },
//     sum() {
//         console.log(this.firstValue + this.secondValue);
//         return this.firstValue + this.secondValue;
//     },
//     mul() {
//         console.log(this.firstValue * this.secondValue);
//         return this.firstValue * this.secondValue;
//     }
// };

// calculator.read();
// console.log(calculator);

// calculator.sum();
// calculator.mul();

//Цепь вызовов

// let ladder = {
//     step : 0,
//     up() {
//         this.step++;
//     },
//     down() {
//         this.step--;
//     },
//     showStep() {
//         console.log(this.step);
//     }
// };

// ladder.up();
// ladder.up();
// ladder.down();
// ladder.showStep();

//изменить код методов ladder так, чтобы их можно было вызывать по цепочке
// ladder.up().up().down().showStep().down().showStep();

// let ladder = {
//     step : 0,
//     up() {
//         this.step++;
//         return this;
//     },
//     down() {
//         this.step--;
//         return this;
//     },
//     showStep() {
//         console.log(this.step);
//         return this;
//     },
// };
// ladder.up().up().down().showStep().down().showStep();

//Конструктор оператора new
//Функция контсруктор - технически является обычной функцией, но есть два соглашения:
//1. имя должно начинаться с заглавной буквы, 2. ф-я-конструктор должна выполняться только при
//помощи оператора new. Например

// function User (name, surname) {
//     this.name = name;
//     this.surname = surname;
//     this.isAdmin = false;

//     this.sayHi = function() {
//         console.log(`Hello, my name is ${this.name} ${this.surname}.`);
//     };
// }

// let user = new User('Ivan', 'Linnik');
// let userV = new User(prompt('name', 'Viktoriya'), prompt('surname', 'Marakhovskaya'));

// console.log(user);
// user.sayHi();

// console.log(userV);
// userV.sayHi();
//как я понял, функции-конструкторы нужны для многократного создания однотипных объектов.
//такой код более читабельный и понятный, чем многократное создание литерала объекта.
//И да, технически любая функция может быть конструктором - важно, чтобы она начиналась с заглавной
//буквы (так принято для понимания), а при её вызове использовать оператор new, тогда движок
//выполнит необходимый алгоритм.

//Задачи
//создать конструктор калькулятора
// function Calculator() {
//     this.read = function() {
//         this.firstValue = +prompt('enter firstValue', '');
//         this.secondValue = +prompt('enter second value');
//     };
//     this.sum = function() {
//         console.log(`сумма ${this.firstValue} и ${this.secondValue} =`, this.firstValue + this.secondValue);
//         return this.firstValue + this.secondValue;
//     };
//     this.mul = function() {
//         console.log(`произведение ${this.firstValue} и ${this.secondValue} =`, this.firstValue * this.secondValue);
//         return this.firstValue * this.secondValue;
//     };
// }

// let calculator = new Calculator();
// calculator.read();
// calculator.sum();
// calculator.mul();

//Создайте функцию аккумуятор

// function Accumulator(startValue) {
//     this.value = startValue;
//     this.read = function() {
//         this.newNumber = +prompt('enter any number', '');
//         this.value += this.newNumber;
//         return this.value;
//     }
// }

// let accumulator = new Accumulator(1);
// console.log(accumulator.read());
// console.log(accumulator.read());

//Опциональная цепочка "?." - безопасный способ доступа к свойствам
//объекта, даже если они не существуют. Это важно, ведь если я попытаюсь
//получить доступ к несуществующему свойству - я получу ошибку.
// let elem = document.querySelector('.txt-main').innerHTML;
// let noElem = document.querySelector('.class').innerHTML;

// console.log(elem);//выведет содержимое
// console.log(noElem);//будет ошибка

//иногда нормально, что у объекта нет того или иного свойства. Тогда я могу использовать if или тернарный опертор

// let user = {
//     name : 'Ivan',
//     // adress : {
//     //     street : 'Abay st.'
//     // },
// };

// console.log(user.name, 'is living on', user.adress ? user.adress.street : undefined);
//выглядит неэлегантно, вот ещё пример с querySelector, чтобы я увидел всё безобразие:
// console.log(document.querySelector('.elem') ? document.querySelector('.elem') : document.querySelector('.elem'));
//а если мне нужно проверить несколько условий?:
// console.log(user.adress ? user.adress.street ? user.adress.street.name : null : null);
//Для того, чтобы избежать подобного пиздеца есть опциональная цепочка.
// Она возвращает undefined, если значение перед ?. равно null или undefined.
// let user = {
//     name : 'Ivan',
//     adress : {
//         street : {
//             // StName : 'Abay st',
//             index : 7895671,||             штвуч Ж 7895671?

//         },
//     },
// };

// console.log(user.name, user?.adress?.street?.StName);
//А вот пример с querySelector
// console.log(document.querySelector('.elem')?.innerHTML);
//Не стоит злоупотреблять опциональной цепочкой, например подразумевается, что у объекта точно
//точно долженбыть парамет name и не точно адрес, тогда я использую опциональную цепочку только для
//адреса, а для имени просто точечную нотацию console.log(user.name, user?.adress);
//Переменная перед ?. должна быть объявлена, иначе будет ошибка.
// console.log(user?.adress);//ошибка
//Опциональная цепочка, это не оператор, а специальная синтаксическая конструкция,
//которая работает также с функциями и квадратными скобками. Например её можно использовать
//для вызова функции, которой может не существовать

// let userAdmin = {
//     admin() {
//         console.log('I\'m admin');
//     },
// };

// let userGuest = {
//     guest() {
//         console.log('Guest');
//     }
// };

// userAdmin.admin?.();
// userGuest.admin?.();
//в верхних двух строках я предполагаю, что объект юзер существует, и читать из него
//безопасно, затем ?. проверяет левую (от себя) часть, если функция admin существует,
//то она запускается, в противном случае, вычисление остановится без ошибок.
//Сокращённое вычисление - если после выполнения опциональной цепочки с результатом
//undefined есть ещё вычисления, то они выполнены не будут.

// let user = null;

// let x = 0;

// user?.sayHi(x++);//не выполнится
// console.log('Hi'); //выполнится
//Синтаксис ?[] также будет работать, если я буду обращаться к свойству объекта
//без точеной нотации. И это будет работать. Как и в предыдущих примерах, опциональная
//цепочка позволит безопасно обратиться к несуществующим свойствам

// let key = 'surname';

// let user = {
//     name : 'Ivan',
//     [key] : 'Linnik',
//     sayAbout() {
//         console.log(user.name, user.surname);
//     },
// };


// console.log(user);

//Я могу использовать опциональную цепочку только для безопасного чтения, но не для записи
// user?.name = 'Ivan'; //не сработает - это то же самое, что undefined = 'Ivan'

//Тип данных Symbol
//Майсон предлагает не заострять на этом внимание, прочитать, не задротить особо.

//Преобразование объектов в примитивы
//При выполнении математических действий с объектами, например при сложении, я не получу
//так называемый суммарный объект, также в  JS невозможно построить матрицу из объектов или векторы.
//1. Не существует преобразования объекта к логическому значению.
// В логическом контексте все объекты - true. Существует только числовое и строковое преобразование.
//2. Числовое преобразование происходит, когда я вычитаю объекты или применяю мат. ф-ции.
//3. Преобразование к строке происходит, когда я вывожу объект на экран при помощи alert.

//Я могу также реализовать преобразования к строке и чису, используя объектные методы.

//Хинты
//Существует три преобразования типов
//"string" - для преобразования объекта к строке (toString(obj))
//"number" - для преобразования объекта к числу в случае математических операций (Number(obj), +obj)
//"default" - когда оператор не уверен, какой тип ожидать (бинарный +, ==)
//Операторы <, > также могут работать со строками и числами, они используют по умолчанию хинт "number", а не "default"

//Symbol.toPrimitive - встроенный символ, который используется для
//обозначения метода преобразования, вот так:

// obj[Symbol.toPrimitive] = function(hint) {
//     //вот код для преобразования этого объекта в примитив
//     //он должен вернуть примитивное значение
//     //hint = чему-то из "string", "number", "default"
// }
//Если метод Symbol.toPrimitive существует, то он используется для всех хинтов
//и больше никаких методов не требуется. Ниже я напишу объект, который реализует его

// let user = {
//     name : 'Ivan',
//     age : 28,
//     [Symbol.toPrimitive](hint) {
//         console.log(`hint is ${hint}`);
//         return hint == 'string' ? `name: ${this.name}` : this.age;
//     }
// };
// console.log(String(user));
// console.log(+user);
// console.log(user + 10);

//Получается, что в зависимости от преобразования объект user становится либо строкой с описанием,
//либо числом, отражающим возраст. Единый метод Symbol.toPrimitive отбрабатывает все
// случаи преобразования.

//Существуют также методы toString и valueOf, JS пытается их найти, если нет Symbol.toPrimitive.
// Они считаются старомодными методами преобразования.

// let user = {
//     name : 'Ivan',
//     age : 28,
//     //для хинта, равного  'string'
//     toString() {
//         return `name : ${this.name}`;
//     },
//     //для хинта, равного  'number'
//     valueOf() {
//         return this.age;
//     },
// };

// console.log(String(user));
// console.log(+user);
// console.log(user - 10);

//Часто мне нужно некое единое место для обработки всех примитивных преобразований.
//В этом случае я могу реализовать только toString(). В отсутствии Symbol.toPrimitive и
// valueOf, toString()

// let user = {
//     name : 'Ivan',
//     age : 28,
//     toString() {
//         return this.name;
//     }
// };
// console.log(String(user));
// console.log(user + 10);

//Преобразование может вернуть любой тип!
//Не факт, что метод преобразования примитивов вернёт именно
//именно подсказанный хинтом примитив. Единственное, в чём можно быть уверенным,
//что они вернут примитив, а не объект.

//Методы примитивов
// JS позволяет нам работать с примитивами, как с объектами. У примитив могут быть свои методы.
//Чтобы использовать примитивы как объекты, обращаться к методам примитив создаётся как бы
//объект-обёртка, название которого зависит от примитива - String, Number, Boolean, Symbol, BigInt.
//И получается, что разные примитивы обладают разным набором методов. Например есть метод str.toUpperCase,
// который возвращает строку в верхнем регистре:

// let str = 'Ivan';
// console.log(str.toLowerCase());

//число тоже имеет набор методов, например toFixed(n) - округляет значение до n.

// let num = 4.25345;
// console.log(num.toFixed(1));

//null и  undefined не имеют методов

// let str = 'khuy';

// str.num = 5;
// console.log(str.num);

//Числа
//в современном JS существуют два типа чисел
//Обычные числа - записываются в 64-битном формате, они же - числа
//с плавающей точкой двойной точности, а также БигИнт - от -(2**53)-1 до (2**53)-1 (позже).

//Способы записи числа
//Можно использовать букву е для записи большого количества нулей
// let billion = 1000000000; // 1 миллиард, легко ошибиться в такой записи
//можно записать как:
//let billion = 1e9;// что буквально означает 1 и 9 нулей
//let num = 7.3e9// будет равно 7.3 млрд. 300 млн или 7 300 000 000,
//другими словами, е умножает число на 1 с количеством нулей, указанных после е.
//тысяча будет выглядеть как 1е3.
// А чтобы записать что-то маленькое, например микросекунду:
// let ms = 0.000001;//длинная запись
// let ms = 0e-6;//шесть нулей слева от 1.

//Шестнадцатеричные и двоичные числа
//Шестнадцатеричные широко используются для кодировки цветов, символов и пр.
//пример шестнадцатеричногоn представления числа 255 - регистр не имеет значения
// console.log(0xff, 0xFF);
//не так часто используется двоичная (бинарная) форма записи числа
// console.log(0b11111111);
//и восьмеричная
// console.log(0o377);
// console.log(0b11111111 === 0o377);

// Метод num.toString(base) возвращает строковое представление числа num в системе исчисления base
// let num = 2344566;
// console.log(num.toString(8));
//максимальное основание base = 36, с его помощью можно делать короткие ссылки для длинных числовых идентификаторов
// console.log(1234567..toString(36));//две точки используются чтобы JS не ожидал
//десятичную часть числа, вторая точка для этого и нужна

//Округление
//есть несколько часто встроенных функций для работы с округлением

// let anyNum = [3.1, 1.1];//массив для упрощения использования чисел и методов
// console.log(Math.floor(anyNum[0]), Math.floor(anyNum[1]));//округление в меньшую сторону
// console.log(Math.ceil(anyNum[0]), Math.ceil(anyNum[1]));//округление в большую сторону
// console.log(Math.round(anyNum[0]), Math.round(anyNum[1]));//округление до ближайшего целого
// console.log(Math.trunc(anyNum[0]), Math.trunc(anyNum[1]));//отбрасывание дробной части без округления (не работает в IE)

// А что если мне нужно округлить до определённого знака? Есть два способа
// let num = 1.235461;

// умножить и разделить (до второго знака)
// console.log('умножаю и делю на 100 ->', Math.floor(num * 100) / 100);//1.235461->123.5461->123->1.23

// метод toFixed(n) - округляет число до n знаков после запятой и возвращает строковое значение
// как в большую, так и в меньшую сторону аналогично методу Math.round
// console.log('toFixed() ->', num.toFixed(2));//возвращается строка, поэтому можно использовать + или Number()

//Неточные вычисления
//в js числа представлены в виде 64-битного формата, т.е. для хранения числа используется 64 бита.
//52 бита для хранения цифр, 11 бит для хранения положения десятичной точки, 1 бит для хранения знака.
//если число слишком большое оно переполнит 64-битное хранилище, тогда js вернёт бесконечность, например
// console.log(1e500);
//Наиболее часто встречающаяся ошибка в js - потеря точности.
// console.log((0.1 + 0.2) == 0.3);//false - странно пиздец, тогда смотрю, чему равно 01+02
// console.log(0.1 + 0.2); //0.30000000000000004
//это происходит потому что число хранится в бинарной форме в виде едениц и нолей
//получается, что в десятичной форме дроби типа 0.1, 0.2 выглядят довольно просто,
// но в двоичной форме это бесконечная дробь. Просто в js нет возможности хранить точное значение 0.1 и 0.2
//в двоичной форме. Поэтому и используют округление. Вот интересный пример
// console.log(0.1.toFixed(20)); //0.10000000000000000555 - и это не предел, дробь действительно бесконечная
// вот ещё пример интересный
// console.log(9999999999999999);// 16 девяток - покажет 10000000000000000, число как бы растёт само/
// всё потому же - потеря точности. получается, что если для записи числа не хватит бит,
// то при записи пропадут младшие разряды.

// Проверка isFinite isNaN
//Infinity, -Infinity, NaN (представляет ошибку) - это чиcловые значения, которые принадлежат типу number, но они не являются
//обычными значениями, поэтому существуют функции для их проверки.
// isNaN(value) - преобразует значение в число и проверяет, не является ли оно NaN.
// console.log(isNaN(NaN));// true
// console.log(isNaN("str"));// true - NaN при приведениии строки к числу
// console.log(isNaN("12"));// false - 12 при приведении строки к числу
// console.log(isNaN(true));// false - 1 при приведении boolean к числу
// разве нельзя просто строго сравнить NaN, вот так a === NaN - нет, потому
// что NaN не равно даже себе, поэтому нужно использовать ф-ю isNaN.
// console.log(NaN === NaN); // false
//isFinite преобразует аргумент в число и возвращает true, если число не Infinity, -Infinity, NaN.
// console.log(isFinite(15));//true
// console.log(isFinite('hello'));//false
// console.log(isFinite(false));//true
// Иногда isFinite используется для проверки, содержится ли число в строке
// let num = +prompt('enter a number', '');
// console.log(isFinite(num));// вернёт всегда true, кроме ситуаций, когда аргумент Infinity,
//  -Infinity или не число.
//Number.isNaN(value) более строгая проверка значения. Само значение не преобразуется в число,
// а проверяется,
// является ли оно чиловым.
//Вернёт true только в том случае, когда объект принадлежит к типу number и является NaN.
// console.log(
//     Number.isNaN('str'/2)
// );

//стоит учитывать, что пустая строка интерпретируется как 0, а строка с текстом, как 1.

//То же самое и с Number.isFinite(value) - возвращает true только в том случае, если
//value принадлежит типу number и является Infinite -Infinite, NaN.
// console.log(
//     Number.isFinite('ere'/1)
// );

// Существет метод Object.is(value1, value2) - он сравнивает значения как === (строгое равенство)
//но более надёжен в двух особых ситуациях:
// 1 - работает с NaN
// let val = NaN;
// console.log(Object.is(NaN, val));//true

// Значения 0 и -0. Технически они разные и такое сравнение нужно достаточно редко, но тем не менее.
// let zero = 0;
// let minusZero = -0;

// console.log(Object.is(zero, minusZero));

//parseInt, parseFloat
//Если мне нужно получить число из строки, в которой например есть единицы измерения
//то parseInt/Float вернёт мне число, полученное до получения ошибки вычисления
// console.log(
// parseInt('10px')
// );//10px
// parseInt(a10px);//NaN
// console.log(
//     parseFloat('12.45$')
// );
//Ф-я parseInt имеет второй необязательный параметр, он определяет систему счисления
// console.log(
//     parseInt('0xff', 16)
// ); //255

// Другие математические функции
//В JS существует встроенный объект Math, который содержит различные математические
//функции и константы. Например Math.random() - возвращает псевдослучайное число в диапазоне
//от 0 до 1, не включая 1.
// console.log(
//     Math.random()
// );
//Math.min, Math.max(a, b, с, ...) - возвращают максимальное и минимальное значение соответственно
// console.log(
//     Math.min(2, 12, 45, 21)
// );
// Math.pow(n, power) - возвращает число n, в степени power.
// console.log(
//     Math.pow(2, 3)
// )
// console.log(
//     Math.round(6.35 * 10) / 10
// );

// function readNumber() {
//     let value = prompt('enter number', 'any number - 5');

//     if (value === null || value === '') {
//         console.log('ok, bye');
//     } else if (Number.isNaN(value)) {
//         console.log('enter a number! not a string!');
//         return null;
//     } else {
//         console.log(`nice! number you entered is ${value}`);
//         return parseInt(value, 10);
//     }
// }

//Задачи после раздела

///////////////////// Мой код /////////////////////////////
// function readNumber() {
//     let value = prompt('enter number', '0');
//     let parsedValue = parseInt(value, 10);

//     if (value === null || value === '') {
//         console.log('bye');
//     } else if (Number.isNaN(parsedValue)) {
//         console.log('entered is', typeof value);
//         readNumber();
//     } else {
//         console.log('number is', parsedValue);
//         return parsedValue;
//     }
// }

// readNumber();

///////////////////// Код из учебника /////////////////////////////

// function readNumber() {
//     let value;

//     do {
//         value = prompt('enter number', 0);
//     } while (!isFinite(value));

//     if (value === null || value === '') {
//         console.log('ok, bye!')
//         return null;
//     } else {
//         console.log('nice! number you entered is', +value);
//         return +value;
//     }
// }

// readNumber();

// let i = 0;

// while (i != 10) {
//     i += 0.2;
//     console.log(i);
// }

// Написать функцию которая генерирует случайное число из min, max
// пример работы alert(random(1, 5))

// function random(min, max) {
//     return min + Math.random() * (max - min);
// }

// console.log(random(10,20));

// Написать функцию которая генерирует случайное целое число от min
// до max включительно
// пример работы alert(random(1, 3))

// function randomInteger(min, max) {
//     let randomValue = min + Math.random() * (max - min);

//     return randomValue.toFixed(0);
// }

// console.log(randomInteger(2,10));

// Строки
// Спецсимволы
// перенос строки
// console.log('One\n\nTwo\nThree\n\n');
// //кавычки
// console.log('I\'m Ivan');

// Длина строки - str.length
// Это не фунцкия, это свойство (числовое), поэтому
// его нужно вызывать без кавычек
// let str = 'Hello,\nbitch';//12 - cgtцсимволы не учитываются в длине строки

// console.log('длина строки равна ', str.length);

// Доступ к символам
//Получить символ, который занимает определённую позицию можно
// при помощи str[pos] - это более современный способ

// console.log(str[0]); // индексация символов начинается с 0.

//также есть ещё один способ

// console.log(str.charAt()); // это менее современный способ

// Между ними есть разница - при отсутствии символа с необходимой позицией
// [] вернёт undefined, a charAt пустую строку

// console.log(
//     `способ [] - ${str[1000]}

// способ charAt() - ${str.charAt(1000)}
//     `
// );

// строку можно перебрать при помощи цикла for...of
// а ещё при помощи цикла for in (получилось случайно). Но тогда
// синтаксис будет немного другой (похоже на перебирание ключей объекта)

// for (let char in str) {
//     console.log(str[char]);
// }

// for (let char of str) {
//     console.log(char);
// }

// Строки неизменяемы - нельзя изменить символ строки
// str[1] = 'q'; // ошибка

// Но можно создать новую переменную и записать в неё новую
// строку вмсето старой (хуёвый пример, когда много символов)

// let hi = 'hi';
// let newHi = 'H' + hi[1];

// console.log(newHi);

// Изменение регистра

// let str = 'Пишу текст';

// console.log(
//     `
// исходный текст: ${str}
// нижний регистр: ${str.toLowerCase()}
// верхний регистр: ${str.toUpperCase()}

//     `
// );
// // для отдельного символа
//  console.log(
//     str[3].toUpperCase(), str
//  );

// Поиск подстроки - есть несколько способов

// str.indexOf(substr, pos) - ищет подстроку substr в строке
// str, начиная с позиции pos и возвращает позицию, на которой располагается
// совпадение, либо -1, если нет совпадений.

// let str = 'Здравствуйте, меня зовут Иван';

// console.log(str.indexOf('Иван')); //это слово начинается с 25 символа строки
// console.log(str.indexOf('ан', 10)); // поиск и с 10-го символа фрагмента 'ан'
// console.log(str.indexOf('здравствуйте', 0)); // не нашёл ничего -1
// console.log(str.indexOf('в')); // вернёт первую совпавшую позицию, но
// дальше не пойдёт. Чтобы найти все вхождения нужно запустить в цикле

// let str = 'Та тата тити ти та';

// let target = 'та';
// let pos = 0;

// while (true) {
//     let foundPos = str.indexOf(target, pos);

//     if (foundPos == -1) break;

//     console.log('Найдено тут', foundPos);
//     pos = foundPos + 1; // продолжаем со следующей позиции
// }

// Более короткая запись
// let target = 'та';
// let pos = -1;

// while((pos = str.indexOf(target, pos +1)) != -1) {
//     console.log('вот, что нашёл', pos);
// }

// Есть похожий метод, который ищет от конца к началу строки
// str.LastIndexOf(substr, pos) - он нужен тогда, когда нужно
// получить самое последнее вхождение - перед концом строки, или
// начинающееся до (включительно) определённой позиции.

//Есть интересная ситуация - совпадение есть, но indexOf ничего не находит:
// let str = 'hello';

// if(str.indexOf('hello')) { // возвращает 0
//     console.log('I found'); // поэтому код не сработает!
// } else {
//     console.log('Not found');
// }

// чтобы код сработал нужно изменить условие проверки на -1, вот так

// if(str.indexOf('hello') != -1) { // теперь всё работает
//     console.log('I found'); 
// }

// есть ещё старый трюк с побитовым оператором НЕ ~
// подробнее описано в учебнике
//  if(~str.indexOf('hello')) console.log('founded'); // работает
// этот трюк можно встретить только в старом коде, но его нужно помнить.
// в новом же есть метод .includes

// includes, startsWith, endsWith

// str.includes(substr, pos) - возвращает true, если в строке
// есть совпаление, false, если совпадения нет. Это правильный выбор,
// если мне нужно проверить только совпадение, а позиция не нужна.
// необязательный аргумент pos - для указания с какой позиции начать

// let str = 'hello world';

// console.log(str.includes('world'), // true
//             str.includes('bye') // false
// );

// startsWith, endsWith - проверяют, начинается ли строка
// с соответсвующей подстроки

// console.log(
// str.startsWith('hell'), // true - начало с hello
// str.endsWith('orld'), // true - окончание с orld и т.д.
// str.startsWith('hi'), // false
// str.endsWith('hi') // false
// );

// Получение подстроки
// В JS есть три метода получения подстроки substring, substr и slice
// str.slice(start, [, end]) - возвращает часть строки start до
// (не включая end).

// let str = 'stringify';

// console.log (str.slice(0, 5)); //strin

// console.log(str.slice(3)); // ingify - end отсутствует - строка возвращается до конца

// Также для start|end можно задать отрицательные значения, это
// означает, что позиция определена с конца строки

// console.log(
//     str.slice(-2), // fy
//     str.slice(-4, -1), //gif
// );

// Substring почти то же самое, что и  slice, но можно задавать
// start боьлше, чем end? тогда метод сработает, будто аргументы
// поменяны местами:

// console.log(str.substring(6,1)); //tring - slice вернёт пустую строку
// отрицательные значения substring не поддерживает и интерпретирует
// как 0.

// Substr(start, length) - возвращает часть строки от start длины length
// console.log(str.substr(-2, 6)); // fy
// если значение первого аргумента отрицательно, позиция определяется с конца.
// VS code метит его как устаревший, потому что он описан в приложении к
// спецификации, а не в самой спецификации (поэтому он зачёркнут). На практике
// он работает везде (не только в браузере). По итогу автор рекомендует
// запомнить только slice - он более гибкий и короткий для написания.

// Сравнение строк
// как я уже знаю, строки сравниваются посимвольно в алфавитном порядке.

// есть нюансы: строчные буквы больше заглавных
// console.log('a' > 'Z'); //true

// буквы, имеющие диакретические знаки, идут "не по порядку"
// console.log('Österreich' > 'Zealand'); // true

// это может приводить к неправильному результату при сортировке строк
// чтобы понять, что происходит нужно посмотреть внутренее представление строк
// str.codePointAt(pos)
// console.log('Ö'.codePointAt(0)); // 214
// console.log('Z'.codePointAt(0)); // 90
// console.log('O'.codePointAt(0)); // 79

// Можно создать символ по его коду
// console.log(String.fromCodePoint(3433)); // ൩

// сделаю  строку, содержащую символы от 65 до 220

// let str = '';

// for (let i = 65; i <= 220; i++) {
//     str += String.fromCodePoint(i);
// }

// console.log(str); // запусти, посмотри, там много символов
// вывод - строки сравниваются по кодам их символов, это нужно помнить всегда.

// Правильное сравнение
// правильный алгоритм сравнения строк сложнее, чем кажется, потому
// что разные языки используют разные алфавиты. Поэотму браузеру нужно понимать,
// какой язык использовать для сравнения. Все современные браузеры поддерживают
// стандарт ECMA-402, который позволяет правильно сравнивать строки с учётом
// языка, кроме IE10 - для него нужна специальная библиотека.

// Метод для сравнения строк
// str.locateCompare(str2)
// console.log(
//     'hello'.localeCompare('hello')
// );

// вернёт -1, если str < str2
// вернёт 0, если str = str2
// вернёт 1, если str > str2
// у этого метода есть два доп аргумента - 1 указывает язык,
// 2 дополнительные правила (чувствительность к регистру и т.д.)

// есть ещё полезные методы строк
// str.trim() - убирает пробелы в начале и конце строки
// let str = '   ebat\'              ';

// console.log(str, str.length);
// console.log(str.trim(), str.trim().length);

// str.repeat(n) - повторяет строку n раз
// let str = 'privet\n';

// console.log(str.repeat(5));

// Задачи после раздела
//написать ф-ю, которая возвращает любую строку с заглавной буквы

// function ucFirst(str) {
//     if (str === null) {
//         console.log('Bye!');
//         return null;
//     } else if (str.trim() === '') {
//         console.log('Nothing to Capitalize');
//         return null;
//     } else {
//         return str[0].toUpperCase() + str.slice(1).toLowerCase();
//     }
// }

// console.log(ucFirst('IVAN'));

// Написать ф-ю, которая возвращает true, если строка содержит
// 'viargra' или 'XXX' и false если совпадения не найдены. Ф-я
// должна быть не чувствительна к регистру

// let str = '123 sdvlsdvl   sdlvs    ssd;v/// XxX';

// function checkSpam(str) {
//     let modStr = str.toLowerCase();

//     if(modStr.includes('xxx') || modStr.includes('viagra')) {
//         return true;
//     } else {
//         return false;
//     }
// }

// console.log(checkSpam(str));

// Усечение строки

// let str = "Привет, меня зовут Иван Линник";

// function truncate(str, maxlength) {
//     let dots = ".".repeat(3);
//     let dotsLength = dots.length;

//     if(str.length > maxlength) {
//         return str.slice(0, (maxlength - str.length - dotsLength)) + dots;
//     } else {
//         return str;
//     }
// }

// console.log(truncate(str, 10));

// Выделить число

// let str = '$120';

// function extractCurrencyValue (str) {
//     if(isNaN(str[0])) {
//         return parseInt(str.slice(1));
//     } else {
//         return parseInt(str);
//     }
// }

// console.log(extractCurrencyValue(str));

// Массивы

// используются для хранения упорядоченных коллекций. Есть два способа, чтобы объявить пустой массив.
// let array = Array(); let array = [] - второй - самый популярный.
// можно сразу передать значения по умолчанию, вот так:
// let array = ['Иван', 'Виктория', 'Шапка'];

// массивы нумеруются с 0. Можно получить доступ к объектам массива через []
// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }
// console.log('');

// можно заменить элемент
// array[2] = 'Чоис';

// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }

// можно добавлять элементы массива, вот так
// array[3] = array.length;

// for (let i = 0; i < array.length; i++) {
//     console.log(array[i]);
// }

// console.log(array);

// можно заменить элемент
// array[3] = 'музыка';
// console.log(array);

// в массиве могут храниться элементы любого типа
// let array = [1, true, {name: 'Ivan', surname: 'Linnik,'}, function() {console.log('Hello');}];
// console.log(array);
// console.log(array[2].name); // Ivan
// array[3](); // Hello
// список элементов массива может заканчиваться запятой, это придаст идентичности строкам кода
// висячая запятая приветствуется также, как и при работе с объектами

// Получение последних строк при помощи at
// допустим, мне нужен последний элемент массива. В других языках я бы мог попробовать array[-1],
// в JS это не сработает, потому что индекс в скобках воспринимается буквально,  и будет undefined.
// Но можно явно вычислить позицию последнего элемента, вот так: array[array.length - 1].

// let array = ['khuy', 'pizda', 'zalupa'];
// console.log(array[array.length - 1]); //ебать писать ещё два раза имя переменной
// как видно, такая запись выглядит громоздко. Есть более короткий синтаксис:
// console.log(array.at(-1));

// Другими словами array.at[i] - то же самое, что и arr[i], если i >= 0.
// Для отрицательных значений он отступает от конца массива.

// Методы pop/push, shift/unsift

// Очередь - один из самых распространённых способов применения массива - когда приходит последний, то первый уходит. 
// метод push - добавляет элемент в конец массива
// метод shift - удаляет элементы в начале, сдвигая очередь так, что второй элемент становится первым
// массивы поддерживают обе операции

// Стек - поддерживает два вида операций - удаляет последний элемент (метод pop), помещает
// элемент в конец массива (метод push) - самый простой пример - колода карт.
// Массивы в JS могут работать и как очередь, и как стек, в компьютерных науках это называется двусторонняя очередь.

// Методы, работающие с концом массива

// POP - удаляет последний элемент из массива и возвращает его

// let array = ['slovo', 'ne', 'vorobey'];
// console.log(array);

// let lastWord = array.pop();
// console.log(array, lastWord);

//PUSH - помещает элемент в конец массива

// let fruits = ['apple', 'orange', 'cherry', 'kiwi'];
// console.log(fruits);

// fruits.push('pineaple', 'banana');
// console.log(fruits);

// Методы, работающие с концом массива

// SHIFT - удаляет из массива первый элемент и возвращает его

// let fruits = ['apple', 'orange', 'cherry',];
// let firstArryElem = fruits.shift();

// console.log(firstArryElem, fruits);

// // UNSHIFT - добавляет элемент в начало массива
// fruits.unshift('apricot');
// console.log(fruits);

// Внутреннее устройство массива
// массив это особый подвид объектов - но, в основе всё равно лежит объект
// массивы расширяют объекты, так как предоставляют возможность работать
// с упорядоченными коллекциями данных, а также свойство length.

// Массив ведёт себя как объект, например он также копируется по ссылке

// let array = ['privet', 'pidor'];
// let arrayCopy = array;
// console.log(array === arrayCopy); //true

// console.log('до изменения копии массива', arrayCopy);
// array[0] = 'hello';
// console.log('изменил копию этого массива', arrayCopy);

// Одна из особенностей массива, это то, что движок хранит элементы массива
// в непрерывной области памяти, один за другим. Есть и другие способы
// оптимизации, благодаря которым массивы работают очень быстро.
// НО все эти способы перестанут рабоать, если я начну работать с массивом,
// как собъектом, т.е. перестану работать с ним, как с упорядоченной коллекцией
// данных, например до/после

// let array = ['иван', 'линник'];
// console.log('before', array);

// array.age = 25; // я могу так сделать, потому что в основе массива лежит объект
// console.log('after', array);
// но движок перестанет применять способы оптимизации для массивов
// и начнёт работать с массивом, как с обычным объектом

// как неправильно использовать массив
// добавление нечислового свойства, например array.feaute = 'something'
// создание дыр, например добавление arr[0], а  затем arr[1000].

// Перебор элементов

// let array = ['a lot', 'of', 'items', 'are', 'here'];

// // цикл for
// for (let i = 0; i < array.length; i++) {
//     console.log(`element with index ${i} is`, array[i]);
// }

// // цикл for of
// // он не предоставляет доступ к индексу элемента, только к значению, но этого
// // но этого обычно достаточно
// for (let item of array) {
//     console.log('for of: ', item);
// }

// также можно использовать цикл for in, но есть подводные камни, поэтому
// не рекомендуется его использовать, к тому же он от 10 до 100 раз медленнее,
// чем for of.

// Length
// это не длина массива, а наибольший цифровой индекс + 1, например единственный элемент, имеющий больший индекс даёт большую длину

// let array = [];

// array[100] = 'apple';
// console.log(array.length); // 101

// свойство length можно перезаписать, и тогда изменится и содержимое
// массива, вот так

// let array = [1, 2, 3, 4, 5];
// array.length = 2;

// console.log(array);// [1, 2]

// array.length = 4; // пытаюсь восстановить элементы

// console.log(array);// [1, 2, empty x 2] - невозможно восстановить

// самый простой способ очистить массив это array.length = 0;

// Многомерные массивы

// их особенность в том, что в них можно хранить матрицы

// let arrayForMatrix = [
//     [0, 1, 2],
//     [3, 4, 5],
//     [6, 7, 8],
// ];

// console.log(
//     arrayForMatrix[1][1]
// );

// toString для массивов

// массивы по-своему реализуют метод toString - он возвращает список элементов,
// разделённых запятыми
// let array = [1, 2, 3, 4,];
// console.log(String(array));

// автор предлагает попробовать следуещее
// console.log(String([] + 1)); // 1

// console.log(String([1] + 1)); // 11

// console.log(String([1, 2] + 1)); // 1,21

// интересно. Так происходит, потому что массивы не имеют встроенного
// Symbol.toPrimitive, а также valueOf(), они реализуют только проеобразование
// toString, и вот как оно работает на примерах выше:
// [] - становится пустой строкой,
// [1] - становится '1',
// [1, 2] - становится 1,2 - соответственно, [1, 2] + 1 - бинарный плюс тоже
// преобразовывает к строке '1,2' + '1' = '1,21'.

// НЕ СРАВНИВАЙ МАССИВЫ ПРИ ПОМОЩИ ==

// два объекта равны друг другу, только если они ссылаются на один объект
// если сравнивать объект и примитив, объект будет приводиться к примитиву, за
// исключением null и undefined, они равны (==) только себе и ничему другому
// === лучше всего, потому что он не преобразует типы
// стало быть, два объекта никогда не будут == друг другу, только если это
// не 2 переменные, ссылающиеся на один объект (массив), например:
// console.log([] == [], [1] == [1]); // false false, это потому,
// что технически я сравниваю два разных массива, оператор == не выполняет
// поэлементное сравнение.

// Сравнение с примитивами тоже может дать казалось бы странные результаты

// console.log(0 == []); // true
// console.log('0' == []); // false
// здесь я сранвил массив с примитивами, и получается, что пустой массив
// преобразуется в примитив и становится пустой строкой, а пустая строка
// становится 0 при ==, а во втором примере нет преобразования строк - 
// разные типы данных.

// Задачи после раздела
/////////////////
// let styles = ['jazz', 'blues',]; // создал массив
// console.log(styles); // проверка
// styles.push('rock-n-roll'); // добавил рок-н-ролл в конец
// console.log(styles); // проверка
// // заменить значение в середине массива на "классика",
// // должно работать для массива любой длины
// styles[((styles.length - 1) / 2).toFixed(0)] = 'classic';
// console.log(styles); // проверка
// console.log(styles.shift()); // удалил первый элемент массива и показал его
// console.log(styles); // проверка
// styles.unshift('rap', 'reggae'); // всавил рэп и регги в начало массива
// console.log(styles); // проверка
////////////////
// let array = ['1', '2'];
// array.push(function(){console.log(this)});
// array[2](); // выведет сам массив, потому this ссылается на объект
////////////////

//ф-я, которая запрашивает у пользователя данные через propmpt и сохраняет
// их в массив. Если пользователь вводит не число, пустую строку или escape
// тогда перестать запрашивать. Ф-я подсчитывает и возвращает сумму значений
// ноль считается числом

// function sumInput() {
//     let arr = [];
//     let sum = 0;


//     while (true) {
//         let userInput = prompt('any number', '');

//         if (userInput === '' || userInput === null || !isFinite(userInput)) break;

//         arr.push(+userInput);
//     }

//     for (let item of arr) {
//         sum += item;
//     }
//     return sum;
// }

// console.log(sumInput());

//Подмассив наибольшей суммы
// (спиздил из книги - это не совсем корректное задание по словам Майсона, но мне просто интересно)
// let arr = [4, 5, 7, 8];
// let arr2 = [-1, 2, 3, -9];
// let arr3 = [-1, -2, -3, -4];
// let arr4 = [-1, 2, 3, 8];

// function getMaxSubSum(arr) {
//     let maxSum = 0; // максимальная сумма
//     let currentSum = 0; // текущая сумма

//     for (let item of arr) { // для каждого элемента массива
//         currentSum += item; // добавляю значение эл-та к текущей сумме
//         maxSum = Math.max(maxSum, currentSum); // запоминаю максимум на момент итерации
//         // благодаря этой переменной не нужно делать несколько проходов вложенным циклом
//         if(currentSum < 0) currentSum = 0;
//     }
//     return maxSum;
// }

// console.log(getMaxSubSum(arr2));

// Методы массивов

// Добавление, удаление элементов
// arr.push(elem, elem, ..) - помещает элементы в конец массива
// arr.pop() - удаляет последний элемент массива и возвращает его
// arr.unshift(elem, elem, ..) - помещает элементы в начало массива и меняет значение length
// arr.shift() - извлекает элемент из начала массива и возвращает его

// Как удалить элемент из массива?
// Можно использовать delete arr[2] - и элемент удалится, но вот длина массива не изменится.
// Это происходит потому что это работает как delete obj.key - удаляется пара ключ:значение, для
// объектов это нрмально, но я хочу, чтобы остальные элементы сместились и заняли освободившееся место
// а сам массив стал короче. Вот поэтому для массива необходимо использовать специальные методы.

// Метод arr.splice. Его синтаксис:

// arr.splice(index[, deleteCount, elem1, ..., elemN]), вот как он работает:
// let array = ['I', 'love', 'JavaScript'];
// array.splice(1, 1); // начиная с позиции 1 удалить 1 элемент
// console.log(array);

// теперь удалю элементы и заменю их другими
// let array = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// array.splice(0, 3, "Давай", "танцевать");
// console.log(array);

// splice() возвращает массив из удалённых объектов
// let deletedItems = array.splice(0, 1);
// если указать только одно значение, а не диапазон, то удалится всё, начиная с этой позиции до конца массива
// console.log(deletedItems);
// console.log(array);

// если я хочу не удалять, а просто вставить элементы на определённую позицию
// let arr = ['today', 'I\'m', 'lazy'];
// console.log(arr);
// arr.splice(2, 0, 'not'); // это буквально означает со второй позиции удалить 0 элементов, вставить 'not'
// console.log(arr);

// Отрицательные индексы разрешены -  в этом случае работа метода будет производиться с конца
// let arr = [1, 2, 5];
// console.log(arr);
// arr.splice(-1, 0, 3, 4); // начиная c индекса -1 (перед последним элементом (или после первого с конца)) удалить 0 элементов,
// затем вставить числа 3 и 4
// console.log(arr);

// Метод slice
// его синтаксис  arr.slice(start, end) - он возвращает новый массив, в который копирует элементы
// если вызвать его без аргументов, то он просто сделает копию массива, такое копирование не меняет исходный массив

// Метод concat - создаёт новый массив, в котрый копирует данные из других массивов и дополнительные значения
// arr.concat(arg1, arg2) - он принимает любое количество аргументов, которые могут быть как массивами, так и объектами
// в результате получаю arr c новыми аргументами.

// let arr = [1, 2];
// let arr2 = [5,6,7,8];
// let arr3 = arr.concat([3, 4], arr2);
// console.log(arr3);
// а запись arr.concat(arr[0, 2]) - буквально означает - скопировать в arr все элементы arr2 за исключением с 0 по 2 элементы.
// Обычно, этот метод копирует только элементы массива, всё остальное копируется как есть

// let arr = [1, 2];
// let obj = {
//     0: 'sas',
//     1: 12,
// }
// console.log(arr.concat(obj));

// // Но если массивоподобный объект имеет свойство Symbol.isConcatSpreadable, то он обрабатывается как массив с помощью concat
// let arr2 = [10, 11];
// let obj2 = {
//     0: '12',
//     1: '13',
//     [Symbol.isConcatSpreadable]: true,
//     length: 2, // наличие этой пары обязательно (без неё не происходит преобразования)
// }
// console.log(arr.concat(obj2));

// Перебор forEach
// запускает функцию для каждого элемента, его синтаксис
// arr.forEach(function(item, index, array)) {
// делать что-то
// }
// результат функции, если она что-то возвращает отбрасывается или игнорируется

// let arr = [23, 43, 5, 667, 89, 0];

// arr.forEach((item, index, array) => {
//     console.log(
//         `элемент ${item} с индексом ${index}`
//     )
// });

// let arr = [1,2,3,4,5];

// function decreaseElemByOne() {
//     let newArr = [];
//     arr.forEach((item, index, array) => {
//         newArr.push(item -= 1);
//     });

//     console.log(arr);

//     return newArr;
// }

// console.log(forElem())

// Поиск в массиве
// let arr = [];

// function createRandomArr(amount) {
//     let arr = [];
//     for (let i = 0; i < amount; i++) {
//         var item = (Math.random() * 100).toFixed(0);
//         arr.push(item);
//     }
//     console.log('Сгенерирован массив', arr);
//     return arr;
// }
// createRandomArr(12);

// let itemIndex = arr.indexOf('45', 0); // возвращает позицию элемента или -1

// let itemIndexByEnd = arr.lastIndexOf('45'); // то же самое, только с конца массива (ищет справа налево)

// let includes = arr.includes('45', 0); // true, если объект есть в массиве с указанного индекса (если не указать - с начала)



// console.log(`содержится?: ${includes}, под индексом: ${itemIndex}, а с конца: ${itemIndexByEnd}`);
// console.log(`Искомый элемент: ${arr[itemIndex]}`)
// console.log(arr);
// важно, что эти методы имеют строгое сравнение, поэтому false не будет 0
// а includes в отличие от других правильно работает с NaN - indexOf вернёт -1, а includes - true

// Методы find и findIndex

// А что если у меня массив объектов? Как мне найти объект с определённым условием?
// Метод arr.find(). Его синтаксис: let result = arr.find(function(item, index, array)) {
// если true - возвращается искомый элемент, все итерации прерываются
// если искомый элемент не найден, возвращается undefined;
// } - функция вызывается поочереди для каждого элемента массива
// Например

// let users = [
//     { id: 1, name: 'Vanya' },
//     { id: 2, name: 'Vika' },
//     { id: 3, name: 'Choice' },
// ];

// let user = users.find((item) => item.id == 1); // функции передан один аргумент (два передаётся редко)
// console.log(user.name, user.id, user);

// // можно передать аргумент без скобок.
// let vika = users.find(item => item.id == 2);
// console.log(vika)

// // Метод find принимает в cебя ф-ю колбэк, которая возвращает true или false.
// // А это я просто написал по сути тот же самый колбэк
// let param = (item) => {return (item.id == 3) ? true : false};

// let shap = users.find(param); // и использовал его
// console.log(shap);

// Метод findIndex() - по сути тоже самое, только возвращает индекс элемента, если найдет или -1, если ничего не найдёт.

// Метод filter()
// нужен тогда, когда найденных элементов может быть много. Синтаксис схож с find(), только метод filter()
// возвращает массив из найденных элементов. Синтаксис
// arr.filter(function(item, index, array){
// если true - элемент добавляется к результату, и перебор продолжается
// если ничего не найдено - возвращается пустой массив
// })

// let users = [
//     { id: 1, name: 'Vanya' },
//     { id: 2, name: 'Vika' },
//     { id: 3, name: 'Choice' },
//     { id: 4, name: 'Vanya' },
//     { id: 5, name: 'Vika' },
//     { id: 6, name: 'Choice' },
// ];

// let request = 'Choice';
// let someUsers = users.filter(item => item.name == request);
// console.log(someUsers);

// for (let elem of someUsers) {
//     console.log(` Идентификатор найденоого элемента: ${elem.id}, поиск по запросу ${request}`);
// }

// Преобразование массива
// метод arr.map() - один из наиболее часто используемых. Он вызывает функцию для каждого элемента
// и возвращает массив результатов выполнения этой функции. Его синтаксис
// let result = arr.map(function(item, index, array){
// возвращается новое значение вместо элемента
// })
//в примере из книги элемент в массиве преобразовывают в его длину.

// let arr = ['Frodo', 'Sam', 'Gandalf'];

// let result = arr.map(item => item = item.length);

// console.log(result);

// Сортировка массива
// метод sort(fn) выполняет сортировку массива на месте, меняя в нём порядок элементов

// let arr = [1, 2, 3, 45, 67, 4, 5, 21, 46];
// let sorted = arr.sort(); // 1, 2, 21, 3, 4, 45, 45, 5, 67
// по умолчанию, элементы сортируются как строки, т.е для них применяется лексографический порядок,
// и получается, что 3 > 21. Чтобы использовать собственный порядок, мне нужно предоставить ф-ю в качестве аргумента sort().
// И для пары значений ф-я должна возвращать:
// function compareNumeric(a, b) {
//     if (a > b) return 1;
//     if (a == b) return 0;
//     if (a < b) return -1;
// };

// let sortedRight = arr.sort(compareNumeric);
// console.log(sorted, sortedRight);

// а если я хочу узнать, какие элементы сравниваются, я могу вывести их на экран
// let arr2 = [12, 34, 1, 5, 6,];
// arr2.sort(function (a, b) {
//     console.log(a + '<>' + b);
// });

// для более аккуратного кода лучше использовать стрелочную функцию
// let secondSorted = arr.sort((a, b) => a - b);
// console.log('with arrow', secondSorted);

// Для строк лучше использовать метод str.localeCompare, чтобы избежать неправильного сравнения, ведь алгоритм сравнения строк
// сравнивает буквы по их кодам, и поэтому для многих алфавитов лучше использовать метод str.localeCompare.

// let nameArray = ["иван", "Виктория", "чоис"];
// let sortedNameArray = nameArray.sort((a, b) => a.localeCompare(b));
// console.log(nameArray, sortedNameArray);
// // или страны
// let countries = ['Österreich', 'Andorra', 'Vietnam'];
// console.log(countries);

// let sortedCountries = countries.sort((a, b) => a.localeCompare(b));
// console.log(sortedCountries);

// Метод reverse - меняет порядок на противоположный

// let numericAr = [1, 2, 3, 4]; // сортирует правильно только если элементы уже отсортированы правильно
// console.log(numericAr.reverse());

// Методы split и join
// метод str.split(delim) - разбивает строку на массив по заданномму разделителю (delim)

// let str = "Привет. Я твой рот ебал.";

// let arr = str.split(' ');
// console.log("получил массив из строки, delim - пробел", arr);

// for (let word of arr) {
//     console.log('перебираю массив > ', word);
// }

// // Разбивка по буквам - если не передать аргумент deli (передать ''), то строка разобьётся посимвольно
// let arrNoDelim = str.split('');
// console.log("получил массив из строки, delim - не указан", arrNoDelim);

// // Противоположный split(delim) метод join(glue)
// // он создаёт строку из элементов массива, вставляя glue между ними
// console.log(
//     'А вот я собрал строку обратно -> ', arrNoDelim.join('')
// );

// reduce и reduceRight - они используются для какого-нибудь вычисления на основе всего массива
// синтаксис: let value = arr.reduce(function(accumulator, item, index, array) {
// ...
// }, [initial]);
// эта функция применяется ко всем элементам массива, и "переносит" свой результат на следующий вызов
// например, можно получить сумму элементов массива одной строкой

// let arr = [1, 1, 1, 1, 1];

// let sumOfElems = arr.reduce((sum, current) => sum + current, 0);
// console.log(sumOfElems);

// если не передавать initial, то я получу тоже самое, потому что в этом случае метод примет за инициализацию первый элемент
// метод arr.reduceRight() работает точно также, но проходит по массиву справа налево.

// Array.isArray
// функция type of не может отличить массив от объекта, потому что в основе массива лежит объект
// поэтому был придуман специальные метод Array.isArray(arr) - он вернёт true, если arr является массивом, в противном случае false.
// let arrJoin = arr.join('>');
// console.log(
//     ` это массив?: ${Array.isArray(arr)}
//     а это?: ${Array.isArray(arrJoin)}, ${typeof arrJoin}`
// );

// Задачи после раздела
//1
// Напишите функцию camelize(str), которая преобразует строки вида «my-short-string» в «myShortString».
// То есть дефисы удаляются, а все слова после них получают заглавную букву.

// function camelize(str) {
//     let arrayFromString = str.split('');
//     let mapResult = arrayFromString.map((item, index, array) => {
//         if (item === '-') {
//             let nextItem = array[++index].toUpperCase();
//             array.splice(index, 1);
//             return nextItem;
//         } return item;
//     });
//     let finalStr = mapResult.join('');

//     return finalStr;
// }
// console.log(camelize('this-random-border-radius'));

// function camelize(str) {
//     return str
//     .split('-')
//     .map((word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1))
//     .join('');
// }
// console.log(camelize('this-random-border-radius'));

//2
// Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
// ищет элементы со значениями больше или равными a и меньше или равными b
// и возвращает результат в виде массива.
// Функция должна возвращать новый массив и не изменять исходный

// let originalArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// function filterRange(array, a, b) {
//    return array.filter(item => (item >= a && item <= b));
// }

// console.log(filterRange(originalArr, 0,3));

//3
// Напишите функцию filterRangeInPlace(arr, a, b), которая принимает массив arr и удаляет из него все значения
// кроме тех, которые находятся между a и b . НА МЕСТЕ. То есть,проверка имеет вид a ≤ arr[i] ≤ b .
// Функция должна изменять принимаемый массив и ничего не возвращать.

// let randomArray = createRandomArr(15);

// function filterRangeInPlace(arr, a, b) {
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] < a || arr[i] > b) {
//             arr.splice(i, 1);
//             i--;
//         };
//     }
//     console.log('диапазон от ', a, 'до ', b);
// }
// filterRangeInPlace(randomArray, 2, 17)
// console.log('после работы функции', randomArray);

//4
// Сортировать в порядке по убыванию
// let randomArray = createRandomArr(10);

// console.log('он же в порядке убывания', randomArray.sort((a, b) => { return a - b }).reverse());

//5
// Скопировать и отсортировать массив
// У нас есть массив строк arr. Нужно получить отсортированную копию, но оставить arr неизменённым.
// Создайте функцию copySorted(arr), которая будет возвращать такую копию.

// let arr = ["HTML", "JavaScript", "CSS", "Abeltone"];

// function copySorted(arr) {
//     return arr.slice('').sort(((a, b) => a.localeCompare(b)));
// }
// console.log(copySorted(arr), 'orig ->', arr);

//6
// Создать расширяемый калькулятор
// Создайте функцию конструктор Calculator, которая создаёт «расширяемые» объекты калькулятора.
// два этапа
// Во-первых, реализуйте метод calculate(str), который принимает строку типа "1 + 2" в формате «ЧИСЛО оператор ЧИСЛО»
// (разделено пробелами) и возвращает результат. Метод должен понимать плюс + и минус - .
// Во-вторых добавьте метод , который добавляет в калькулятор новые операции. Он принимает оператор   и функцию с двумя аргументами
// func(a,b) , которая описывает его.
// доделать
function Calculator() {
    this.methods = {
        '-': (a, b) => a - b,
        '+': (a, b) => a + b,
    };

    this.calculate = function (str) {
        let split = str.split(' '),
            a = +split[0],
            op = split[1],
            b = +split[2];

        if (!this.methods[op] || isNaN(a) || isNaN(b)) {
            return NaN;
        }
        return this.methods[op](a, b);
    };
    this.addMethod = function (name, func) {
        this.methods[name] = func;
    };
}
let anyCalc = new Calculator;





// Перебираемые объекты
// Symbol.iterator
// let range = { // хочу, чтобы здесь работал for of
//     from: 0,
//     to: 5,
// };
// чтобы работать с объектом как с итерируемым, нужно добавить ему специальный метод
// с именем Symbol.iterator - это специальный встроенный символ как раз для этого.
// range[Symbol.iterator] = function () {
//     return {
//         current: this.from,
//         last: this.to,
//         next() {
//             if (this.current <= this.last) {
//                 return { done: false, value: this.current++ };
//             } else {
//                 return { done: true };
//             }
//         },
//     }
// }

// for (let cou of range) {
//     console.log(cou);
// } // теперь это работает

// можно упростить код
// let rangeSimply = {
//     from: 6,
//     to: Infinity, // Infinity - будет итерировать бесконечно
//     [Symbol.iterator]() {
//         this.current = this.from;
//         return this;
//     },
//     next() {
//         if (this.current <= this.to) {
//             return { done: false, value: this.current++ };
//         } else {
//             return { done: true };
//         }
//     },
//     rangeId: 2,
// } // теперь метод [Symbol.iterator]() возвращает сам объект range, у него есть нужный метод next(),
// и он теперь запоминает текущее состояние итерации в this.current.
// Недостаток этого - нельзя использовать этот объект в двух параллельных циклах.

// for (let iterator of rangeSimply) {
//     if (iterator % 2 === 0) continue; // вывел только нечётные
//     console.log(iterator);
//     if (iterator >= 500) break; // остановил после 50 итераций
// }

// Можно использовать бесконечный итератор, например range будет бесконечным при range.to = Infinity.
// Прервать такой бесконечный цикл можно при пощи директивы break.

// Строка - это перебираемый объект
// let str = 'текст строки';

// for (let char of str) {
//     console.log(char.toLocaleUpperCase())
// }

// Явный вызов итератора
// Ниже я буду перебирать строку, как for of только вручную, прямыми вызовами.
// Ниже - получаю строковый итератор и беру из него значения

// 

// Итерируемые объекты - объекты, которые реализуют метод символ итератор
// Псеводмассивы - объекты, у которых есть length, индексированные свойства.
// ниже пример объекта, который является псевдомассивом, но его нельзя итерировать
// let pseudoAr = {
//     0: 'first',
//     1: 'second',
//     length: 2,
// };
// Общее между псевдомассивами и терируемыми объектами - методы массивов с ими не работают

// Array.from - принимает один из итер. объектов или псевдомассивов и делает из них массив.
// Методы массивов теперь будут работать
// Этот метод проверяет, является ли принимаемый объект итерируемым, а затем создаёт новый массив
// и копирует туда элементы.
// Метод также имеет необязательные аргументы - мап функцию - она позволяет изменять элементы перед
// добавлением в массив и зисАрг, который помогает правильно указать this для объекта
// Array.from(obj[, mapFn, thisArg])

// let arrayLike = {
//     0: 'first',
//     1: 'second',
//     length: 2,
// };
// let arrFrom = Array.from(arrayLike);
// console.log(arrFrom);

// for (let el of arrFrom) {
//     console.log(el);
// }
// arrFrom.push('third');
// console.log('after using push(\'third\')', arrFrom);

// let range = {
//     from: 1,
//     to: 5,
//     [Symbol.iterator]() {
//         this.current = this.from;
//         return this;
//     },
//     next() {
//         if (this.current <= this.to) {
//             return { done: false, value: this.current++ };
//         } else {
//             return { done: true };
//         }
//     },
// };

// let arrIter = Array.from(range, elem => (elem ** 0.5).toFixed(3));
// console.log(arrIter);

// Map и Set
// Map, в отличие от объекта не приводит ключи к строке, а хранит их как есть.
// то есть 1 и "1" = это разные ключи. Использовать Map стоит совместно с методами
// let someMap = new Map(); // создаёт коллекцию
// someMap.set(1, 'first value'); // записывает значение 'first value' по ключу 1 (цифра как ключ)
// someMap.set('1', 'second value');

// console.log(`
// возрващает значение по ключу 1: ${someMap.get(1)}, если нет ключа, то ${someMap.get(23)}.
// возвращает true, если ключ есть в коллекции: ${someMap.has('1')}.
// удаляет элемент по ключу ${someMap.delete('1')}
// теперь посмотрим размер: ${someMap.size}
// всё очистим: ${someMap.clear()}
// опять посмотрим размер: ${someMap.size}
// `)

// Можно использовать объекты в качестве ключей
// сохранить количество посещений
// let user = { name: 'John' };
// let visitCountMap = new Map();
// visitCountMap.set(user, 13);
// console.log(visitCountMap.get(user)); //13
// так вот, использование объектов в качестве ключей - одна из важных особенностей Map
// и если заменить Map на Object, то я получу [object Object] вместо ключей, то есть сам объект
// приведёт ключи к строке (что обычно и происходит).
// Сравнивание ключей происходит как при === (sameVaueZero), но при работе с Map NaN может быть равно NaN -
// получается, что NaN тоже может быть ключём.
// Цепочка вызовов - каждый раз вызов map.set() возвращает объект, поэтому можно делать последовательные вызовы
// этого метода:
// map.set(1, 'sosi').set('2', 'guboy').set(true, 'tryasi');

// Перебор Map
// для перебора коллекции Map есть три метода
// map.keys() - возвращает итерируемый объект по ключам
// map.values() - возвращает итерируемый объект по значениям
// map.entries() - возвращает итерируемый элемент по парам типа [ключ, значение] - этот вариант используется по умолчанию в for of

// let reciept = new Map([
//     ['cucumber', 500],
//     ['tomato', 300],
//     ['onion', 200],
// ]);

// // перебор по ключам (овощи)
// console.log('перебор по ключам (овощи)')
// for (let vegetable of reciept.keys()) {
//     console.log(vegetable);
// }

// // перебор по значениям (граммовка)
// console.log('перебор по значениям (граммовка)');
// for (let weight of reciept.values()) {
//     console.log(weight);
// }

// // перебор по элементам в формате [ключ, значение]
// console.log('перебор по элементам в формате [ключ, значение]');
// for (let elem of reciept.entries()) { // entries() можно не указывать
//     console.log(elem);
// }

// Используется порядок вставки, то есть, в отличие от объектов, перебор коллекции Map происходит в том порядке, в котором
// добавлялись пары. Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов
// reciept.forEach((value, key, map) => {
//     console.log(`${key} в количестве ${value} грамм (по рецепту ${map})`);
// });

// Object.entries: Map из Object
// // можно сделать Map при помощи метода entries
// let obj = {
//     name: 'John',
//     age: 30,
// };

// let mappy = new Map(Object.entries(obj));
// console.log(mappy);

// // и наоборот - Object из Map
// let objFromMap = Object.fromEntries(mappy);
// console.log(objFromMap);

// Set
// это особый вид коллекции, в котором значение может появиться только один раз, он не содержит ключей.
// его методы похожи на Map, а создаётся он так
// let mySet = new Set(iterable); // обычно, в качестве аргумента передаётся итерируемый объект (или массив), тогда значения
// копируются в новый Set.
// let arr = ['даров', 'заебал'];
// console.log('массив', arr);

// let mySet = new Set(arr);
// console.log('сет', mySet);

// mySet.add('hello').add('world').add('даров'); // даров - не добавится, т.к. уже есть в коллекции
// console.log('добавил элементы', mySet);

// // перебор Set

// for (let elem of mySet) {
//     console.log('перебор ', elem)
// }

// mySet.forEach((item, itemAgain, set) => {
//     console.log('элемент', item, 'в сете', mySet);
// }) // itemAgain нужен для совместимости с Map, в котором колбэк имеет 3 аргумента
// // Set имеет те же встроенные методы, что и Map set.keys(), set.values(), set.entries() (keys и values одно и то же).

// Задачи после раздела

// Допустим, у нас есть массив arr .
// Создайте функцию unique(arr) , которая вернёт массив уникальных, не повторяющихся
// значений массива arr .

// let values = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Krishna", "Hare", "Hare", ":-O"];

// function uniq(arr) {
//     return Array.from(new Set(arr));
// }

// let uniqValues = uniq(values);
// console.log(uniqValues);

// Напишите функцию   , которая возвращает массив слов, очищенный от анаграмм.
// Из каждой группы анаграмм должно остаться только одно слово, не важно какое.

// let anArr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
// let obj = {};

// function aclean(arr) {
//     for (let i=0; i < arr.length; i++) {
//         let sorted = 
//         arr[i].
//         toLowerCase().
//         split("").
//         sort().
//         join("");

//         obj[sorted] = arr[i];
//     }
//     return Object.values(obj);
// }
// console.log(aclean(anArr));

// Мы хотели бы получить массив ключей map.keys() в переменную и работать с ними, например, применить метод push().
// Но это не выходит:
// Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?

// let map = new Map();
// map.set('name', 'John');

// let keys = Array.from(map.keys());
// keys.push('more')
// console.log(keys);

// WeakMap и WeakSet

// основное отличие от Map в том, что ключами в WeakMap могут быть только объекты. Но если сделать объект
// недостижимым (например, obj = null, нет ссылок на объект), то этот объект удалится сборщиком мусора и из WeakMap.
// в WeakMap есть только следующие методы: weakMap.set(key, value), .get(key), .delete(key), .has.key. Эти ограничения
// связаны с тем, что движок может удалить элементы в любой момент, сразу или запланирует удаление на потом, получается
// что конечное число элементов в коллекции неизвестно, поэтому и нельзя перебрать все элементы.
// Это нужно, когда мне нужно временно хранить данные, например из какой-нибудь библиотеки - я положу сторонний объект, как
// ключ, и когда сам объект перестанет использоваться (станет недостижимым), он также удалится из weakMap.
// weakMap.set(obj, 'сектретные документы') - когда obj исчезнет, секретные документы удалятся.
// Пример реализации счётчика посещений с использованием Map:

// visitCounts.js
// let visitCountMap = new Map(); // map: пользователь => число визитов

// // увеличиваю счётчик
// function countUser(user) {
//     let count = visitCountMap.get(user) || 0;
//     return visitCountMap.set(user, count += 1);
// }

// // а это другая часть кода, возможно в другом файле, которая использует countUser
// // main.js
// let john = { name: 'John' };
// let bob = {name: 'Bob'}
// console.log(countUser(john)); // ведёт подсчёт посещений
// console.log(countUser(bob)); // ведёт подсчёт посещений

// bob = null; // теперь объект bob должен быть удалён из map, но этого не происходит. Такая коллекция может расти до бесконечности.
// чтобы этого избежать, нужно просто использовать weakMap
// let visitCountMap = new WeakMap();

// function countUser(user) {
//     let count = visitCountMap.get(user) || 0;
//     return visitCountMap.set(user, count += 1);
// }
// теперь, когда объект будет недостижим, кроме как из weakMap - вся информация о нём будет удалена, в том числе из weakMap

// Применение WeakMap для кэшироввания
// cache.js
// let cache = new WeakMap();

// // вычисляю и запоминаю результат
// function process(obj) {
//     if (!cache.has(obj)) {
//         let result = /* вычисляю что-то для объекта */ obj;
//         cache.set(obj, result);
//     }
//     return cache.get(obj);
// }

// // main.js
// let obj ={/* какой-то объект */};

// let result1 = process(obj);
// let result2 = process(obj);

// // ... позже, когда объект больше не нужен
// obj = null;

// нет возможности получить cache.size(), так как это WeakMap,
// но он равено 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кэша удаляются.

// WeakSet
// похожа на WeakMap - принимает в себя только объекты, когда объект становится недостижим вне WeakSet, удаляется из WeakSet.
// имеет тот же набор методов. Может пригодиться для определения, посещал ли пользователь сайт. Рекомендуют получать
// булевые значения.
// let visiteSet = new WeakSet();

// let sarah = {name:'Sarah'};
// let fred = {name:'Fred'};

// visiteSet.add(sarah);
// visiteSet.add(sarah);
// console.log('Сара заходила?:', visiteSet.has(sarah),'Фред заходил?:', visiteSet.has(fred));
// sarah = null; // теперь sarah ,eдет удалена из коллекции


// Задачи после раздела
// Хранение отметок непрочитано

// let messages = [
//     { text: "Hello", from: "John", },
//     { text: "How goes?", from: "John", },
//     { text: "See you soon", from: "Alice", },
// ];

// let readMessagesSet = new WeakSet();
// let isRead = Symbol('isRead');

// messages[1][isRead] = true;

// for (let i = 0; i < messages.length; i++) {
//     if (messages[i][isRead] === true) {
//         readMessagesSet.add(messages[i]);
//     } else continue;
// }

// console.log(readMessagesSet, messages[1][isRead] === true);

// Хранение времени прочтения
// let messages = [
//     { text: "Hello", from: "John" },
//     { text: "How goes?", from: "John" },
//     { text: "See you soon", from: "Alice" },
// ];

// let readMap = new WeakMap();

// let isRead = Symbol('isRead');
// let readDate = Symbol('readDate');

// messages[1][isRead] = true;
// messages[0][isRead] = false;

// for (let i = 0; i < messages.length; i++) {
//     if (messages[i][isRead] === true) {
//         readMap.set(messages[i], [readDate] = Date());
//     } else continue;
// }

// console.log(readMap);

// Object.keys(), .values(), .entries()
// существует общее соглашение использовать эти метода для структур данных, простые объекты тоже могут реализовать этот метод,
// но синтаксис отличается. Для простых объектов доступны следующие методы:
// Object.keys(obj), Object.keys(obj), Object.entries(obj). Важно, что прииспользовании с Map возвращается объект,
// а при использовании с простым объектом - "реальный" массив. Все объекты вида Object.* возвращают массив.
// let user = {
//     name: 'John',
//     age: 30,
// };
// console.log(Object.keys(user), Object.values(user), Object.entries(user), Object.entries(user)[0][1]);
// пример перебора значений объекта в цикле

// for (let value of Object.values(user)) {
//     console.log(value)
// }

// Object.keys/values/entries игнорируют символьные свойства. Обычно это удобно, но если они нужны
// для этого есть Object.getOwnPropertySymbols - возвращает массив только символьных ключей, а метод
// Reflect.ownKeys(obj) - вернёт все ключи.

// Трансформация объекта

// У объекта нет множества методов, которые есть у массива, но если я хочу их применить, то:
// можно использовать Object.entries с последующим вызовом Object.fromEntries. Пример с удвоением цен:
// let prices = {
//     banana: 1,
//     orange: 2,
//     meat: 4,
// };

// let doublePrices = Object.fromEntries(
// преобразовать в массив, применить метод map, затем снова преобразовать в массив
// Object.entries(prices).map(([key, value]) => ([key, value * 2]))
// ); // важно соблюдать баланс - сохранить читаемость таких преобразований
// console.log(doublePrices);

// Задачи после раздела

// Сумма свойств объекта
// let salaries = {
//     "John": 100,
//     "Pete": 300,
//     "Mary": 250,
// };

// function sumSalaries(salaries) {
//     let sum = 0;
//     for (let val of Object.values(salaries)) {
//         sum += val;
//     } 

//     return sum;
// }
// console.log(sumSalaries(salaries));

// // можно использовать reduce()
// function sumSalariesReduce(salaries) {
//     return Object.values(salaries).reduce((a, b) => a + b, 0);
// }
// console.log(sumSalariesReduce(salaries));

// Подсчёт количества свойств объекта
// игнорировать символьные, только обычные

// let obj = {
//     name: 'Jonh',
//     age: 30,
// };
// let symb = Symbol('symb');
// obj[symb] = "hasSymbol";

// function count(obj) {
//     return Object.keys(obj).length;
// }
// console.log(count(obj), obj);


// Деструктирующее присваивание

// это специальный синтаксис, который позволяет мне распаковать объекты или массивы в отдельные переменные.
// Так иногда проще. Деструктуризация также хорошо работает со сложными функциями, где много парметров и т.д.

// Деструктуризация массива
// есть массив
// let arr = ['Ivan', 'Linnik'];

// а вот деструктурирующее присваивание
// let [firstName, lastName] = arr; // записывает firstName = arr[0], lastName = arr[1]
// console.log(firstName, lastName); // Ivan Linnik

// можно использовать переменные вместе со split()
// let [firstName, lastName] = 'Ivan Linnik'.split(' ');
// console.log(firstName, lastName);

// Есть нюансы
// деструктуризация не разрушает массив, она не делает ничего с правой частью, лишь присваивает значения переменным
// это просто короткий ваирант записи
// let firstName = arr[0];
// let lastName = arr[1];

// можно пропускать ненужные элементы массива с помощью дополнительной запятой
// например второй элемент не нужен
// let [firstName, , title] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];
// console.log(title); // Consul

// // работает с любым перебираемым объектом с правой стороны
// let [a, b, c] = 'abc';
// console.log(b); // и

// let [one, two, three] = new Set([1, 2, 3]);
// console.log(three); // 3

// Цикл с .entries()
// в предыдущей главе я видел Object.entries(obj) -  теперь я могу использовать его для деструкткуризации
// let me = {
//     name: 'Ivan',
//     lastName: 'Linnik',
//     age: 28,
// };

// // цикл по ключам и значениям
// for (let [key, value] of Object.entries(me)) {
//     console.log(`${key} : ${value}`); // name : Ivan lastName : Linnik e.t.c.
// }

// // то же самое для Map
// let user = new Map();
// user.set('name', 'Ivan');
// user.set('age', 28);

// for(let [key, value] of user) {
//     console.log(`${key} : ${value}`);
// }

// Трюк обмена переменных
// let guest = 'Choice';
// let admin = 'Ivan';
// console.log(`before change > guest is ${guest}, admin is ${admin}`);

// [guest, admin] = [admin, guest]; // здесь я создаю временный массив из переменных и деструктурирую его
// // в порядке замены. Так я могу поменять более двух переменных.
// console.log(`after change > guest is ${guest}, admin is ${admin}`);

// Остаточные параметры
// Если массив длиннее, чем список слева, то лишние элементы опускаются. Но если я хочу их получить,
// я могу добавить ещё один параметр, который получает остальные значения, испоьзуя оператор "остаточные параметры" - 
// троеточие "...":

// let [name1, name2, ...residual] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];
// console.log(name1, name2);
// console.log(residual, residual.length); // 2 - rest - это массив, начиная с 3-го элемента
// console.log(residual[1]); // of the Roman Republic

// Значения по умолчанию
// если в массиве меньше параметров, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными.
// let [firstName, lastName] = [];
// console.log(firstName); // undefined

// // если я хочу, чтобы значение по умолчанию заменило существующее, то я могу указать его через "=":
// let [name = 'Choice', surname = 'Caesar'] = ['Julius'];
// console.log(name, surname); // Julius Caesar - Julius - из массива, Caesar - по умолчанию

// значения по умолчанию могут быть более сложными, и даже функциями, они выполняются только если значения отсутствуют.

// prompt запустится только для surname
// let [name = prompt('name?'), surname = prompt('surname?')] = ['Julius'];
// console.log(name, surname);

// Деструктуризация объекта

// деструктурирующее присваивание работает также с объектами, его синтаксис:
// let {var1, var2} = {var1: .., var2: ..,}

// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// let {title, width, height} = options;
// console.log(title, width, height); // menu 200 300
// console.log(options.title); // Menu

// все свойства options присваиваются тем же переменным, порядок не имеет значения. Вот так тоже работает
// let {width, height, title} = {title: 'Menu', height : 200, width: 100};
// console.log(height); // 200

// Шаблон левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
// Если я захочу присвоить свойство объекта переменной с другим названием, например свойство option.width
// присвоить переменной w, то я могу испоьлзовать двоеточие:
// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// // {sourceProperty: targetVariable}
// let {width: w, height: h, title} = options; // значение свойства width передать в переменную w и т.д.
// console.log(w, h, title); // 200 300 'Menu'

// Для потенциально остутствующих свойств я также могу использовать "=".
// let options = {
//     title: 'Menu',
// };

// let {width = 200, height = 300, title } = options;
// console.log(width, height, title); // 200 300 'Menu'

// Как и с массивами, значения по умолчанию могут быть любые, они применятся, если значения отсутствуют в объекте.
// prompt запросит width, но не title
// let options = {
//     title: 'Menu',
// };

// let {width = prompt('width?'), title = prompt('title?')} = options;
// console.log(width, title); // результат prompt 'Menu'

// также можно совмещать : и =
// let {width: w = 200, height: h = 300, title} = options;
// console.log(w, h, title); // 200 300 'Menu'

// если у меня большой объект, то я могу взять нужное и  отбросить остальное

// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// // let {title} = options;
// // console.log(title); // Menu

// // остаток свойств можно взять также, как и для массива "...", только обращаться нужно как свойству объекта

// let {title, ...rest} = options;
// console.log(rest, rest.width); // объект с остаточными значениями 200

// нюанс
// я мог бы сделать так: let = width, heihgt;
// {width, height} = {width: 200, height: 300}; - но так не будет работать!
// дело в том, что движок, видя {} воспринимает это в основном потоке, как блок кода.
// // Чтобы показать ему, что это не блок кода, нужно заключить всё выражение в скобки, и всё будет работать.
// let options = {
//     title: 'Menu',
//     width: 200,
//     height: 300,
// };

// let width, height;

// ({ width, height } = options);
// console.log(width, height); // 200 300

// Вложенная деструктуризация

// let options = {
//     size: {
//         width: 100,
//         height: 200,
//     },
//     items: ['Cake', 'Donut'],
//     extra: true,
// };

// шаблон в левой   части должен иметь такую же структуру, чтобы извлечь данные
// деструктуризация на несколько строк - для ясности

// let {
//     size: {
//         width,
//         height,
//     },
//     items: [item1, item2], // добавил элементы к items
//     title = 'Menu', // отсутствует в объекте, будет использовать как параметр по умолчанию
// } = options;
// заметим, что переменные для size и items отсутствуют, т.к. я сразу взял их содержимое
// console.log(width, height, item1, item2, title); // 100 200 'Cake' 'Donut' 'Menu'

// Умные параметы функций

// есть ситуации, когда когда функция имеет много параметров, большинство из которых не обязательны.
// проблемы в том - как запомнить эти параметры или вызвать функцию, когда большинство параметров передавать не надо
// можно передать параметры как объект и функция деструктуризирует его:

// передам этот объект в функцию
let options = {
    title: 'My menu',
    items: ['item_1', 'item_2'],
};

// и она извлечёт его параметры
// function showMenu({title = 'Untitled', width = 200, height =300, items = []}) {
//     console.log(title, width, height); // My menu 200 300
//     console.log(items); // ['item_1', 'item_2']
// }
// showMenu(options);

// можно использоватбь более сложное деструктурирование с вложенными объектами и двоеточием
// function showMenu({
//     title = 'Untitled',
//     width: w = 200, // присваиваю width в w
//     height: h = 300, // присваиваю height в h
//     items: [item1, item2], // первый элемент items присвоится item1, второй - item2
// }) {
//     console.log(title, w, h); // My menu 200 300
//     console.log(item1, item2); // item_1 item_2
// }
// showMenu(options);

// такое использование подразумевает, что в функцию должен быть передан аргумент!
// если мне нужны все значения по умолчанию - нужно передать пустой объект, иначе будет ошибка, но её можно исправить,
// сделав {} значением по умолчанию для всего объекта
// function showMenu({title = 'Untitled', width = 200, height = 300, items} = {}) {
//     console.log(title, width, height); // Untitled 200 300
// }
// showMenu();
// в примере выше всегда в функции есть объект, поэтому есть, что деструктуризировать

// Задачи после раздела

// деструктурирующее присваивание
// let user = {
//     name: 'John',
//     years: 30,
// };

// let { name, years: age, isAdmin = false } = user;
// console.log(name, age, isAdmin); // John 30 false

// Максимальная зарплата
// let salaries = {
//     "John": 100,
//     "Pete": 300,
//     "Mary": 250,
// };

// function getTopSarary(obj) {
//     let max = 0;
//     let maxName = null;

//     for (const [name, salary] of Object.entries(obj)) {
//         if (max < salary) {
//             max = salary;
//             maxName = name;
//         };
//     }
//     return maxName;
// }

// console.log(getTopSarary(salaries));

// Дата и время
// это новый встроенный объект, он содержит дату и время, а также предоставляет методы управления ими.
// для его содзания нужно вызвать конструктор new Date(). Если не передать аргументы, запишется текущие дата и время.
// let now = new Date();
// console.log(now);

// new Date(milliseconds)
// создать объект с временем, равным количеству миллисекунд(тысячная доля секунды), прошедших с 1 января 1970 года UTC+0
// 0 соответствует UTC+0
// let Jan01_1970 = new Date(0);
// console.log(Jan01_1970);

// теперь добавим 24 часа и получим 2 янаваря 1970
// let Jan02_1970 = new Date(24 * 3600 * 1000);
// console.log(Jan02_1970);

// целое число миллисекунд, прошедших с января 1970 года называется - таймстамп(timestamp  - отметка времени)
// это легковесное численное представление даты. Из него всегда можно получить дату new Date(timestamp) и преобразовать
// существующий объект Date в таймстамп, использую метод date.getTime().
// датам до 1 января 1970 будут соответствовать отрицательные таймстампы

// 31 декабря 1969 года
// let Dec31_1969 = new Date(-24 * 3600 * 1000);
// console.log(Dec31_1969);

// new Date(datestring)
// если аргумент всего один, и это строка, то из него прочитывается дата
// let date = new Date('2017-06-23');
// console.log(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу
// меняется в соответствии с часовым поясом места выполнения кода

// new Date (year, month, date, hours, minutes, seconds, ms)
// обязательны только первые два аргумента, year - должен состоять из 4 цифр, month - начинается с 0 (январь) и
// заканчивается 11 (декабрь).
// date означает день месяца, если не задан - принимается 1. Остальные параметры, если не заданы, то - 0.
// console.log(new Date(2020, 0));
// максимальная точность - 1 ms

// Получение компонентов даты
// методы получения компонентов даты: getFullYear() - получить год (4 цифры), getMonth(), getDate(), getHours(),
// getMinutes(), getSeconds(), getMilliseconds(), getDay() - получить день недели: 0 - воскресенье, 6 - суббота.
// все эти методы возвращают значения в соответсвтии с местным часовым поясом, однако существуют методы, которые
// возвращают значения в зоне UTC+0: getUTCFullYear(), getUTCMonth, getUTCDay().

// Если часовой пояс смещён относительно UTC, то код ниже покажет разные часы
// текущая дата
// let now = new Date();

// час в текущем часовом поясе
// console.log(now.getHours());

// час в лондонском времени без перехода на летнее время
// console.log(now.getUTCHours());

// Существуют также два особых метода без UTC варианта
// getTime() - для заданной даты возвращает таймстамп - количество миллисекунд, прошедших с 1 января 1970 года UTC+0
// getTimeZoneOffset() - возвращает разницу в минутах между UTC+0 и местным часовым поясом

// Установка компонетов даты
// методы установки:
// setFullYear(year, [month], [date]), setMonth([month], [date]), setDate(date), setHours(hour, [min], [sec], [ms]),
// setMinutes(minute, [sec], [ms]), setSeconds(second, [ms]), setMilliseconds(ms), setTimeMilliseconds - устанавливает
// дату в виде целого количества миллисекунд, прошедших с 01.01.1970. У всех этих методов, кроме setTime() есть UTC вариант.
// Методы позволяют указывать несколько компонентов даты, если компонент не указать - он не меняется.
// let today = new Date();
// today.setHours(0)
// console.log(today); // выведет сегодняшнюю дату, но количество часов будет 0, а вот минуты изменятся (от 00:00)
// today.setHours(0, 0, 0, 0);
// console.log(today); // всё время будет равно 0

// Автоисправление даты
// let date = new Date(2013, 0, 32); // 32 января 2013
// console.log(date); // 1 февраля 2013 - объект сам себя исправил!

// допустим нужно увеличить дату на 2 дня - нужно просто прибавить к дате 2 дня, а объект Date сам определит високосный
// это год или нет
// let date = new Date(2016, 1, 28); // 28 февраля
// date.setDate(date.getDate() + 2);
// console.log(date); // в зависимости от года будет 1 или 2 марта

// также возможность изменения используют, чтобы получить дату по прошествии заданного отрезка времени

// получить дату, спустя 70 секунд от текущего момента
// let date = new Date();
// date.setSeconds(date.getSeconds() + 70); // можно установить нулевые и отрицательные значения
// console.log(date);

// Преобразование к числу, разность дат

// если объект Date преобразовать к числу, то получу аналогичный таймстамп, возвращаемый .getTime()
// let date = new Date();
// console.log(date, '>', +date, date.getTime()); // количество миллисекнд
// побочный эффект от этого - разницу между датами можно вычислять в милисекундах

// let start = new Date(); // начало отсчёта времени

// выполняю некоторые действия
// for (let i = 0; i < 100000; i++) {
//     let doSomething = i * i * i;
// }

// let end = new Date(); // конец отсчёта времени

// console.log(`цикл отработал за ${end - start} миллисекунд`);

// Date.now()
// если нужно просто измерить время, объект Date мне не нужен. Date.now() эквивалентен new Date.getTime(),
// только он создаёт промежуточный объект Date. Этот сбособ работает быстрее и не нагружает сборщик мусора.
// можно переписать предыдущий пример так:

// let start = Date.now();

// for (let i = 0; i < 100000; i++) {
//     let doSomething = i * i * i;
// }

// let end = Date.now();
// console.log(`цикл отработал за ${end - start} миллисекунд`); // быстрее на 3-5 миллисекунд

// Бенчмаркинг

// протестируем скорость выполнения функций, какая быстрее?

// function diffSubstract(date1, date2) {
//     return date2 - date1;
// }

// function diffGetTime(date1, date2) {
//     return date2.getTime() - date1.getTime();
// }

// но эти функции простые, поэтому мне понадобится 100 000 повторений

// function bench(f) {
//     let date1 = new Date(0)
//     let date2 = new Date();
//     let start = Date.now();

//     for (let i = 0; i < 100000; i++) f(date1, date2);
//     return Date.now() - start;
// }
// console.log(`
// время diffSubstract: ${bench(diffSubstract)}, мс
// время diffGetTime: ${bench(diffGetTime)}, мс
// `); // getTime в 11 раз быстрее
// это потому что не производится преобразование типов и интерпретаторам так намного легче работать

// представим, что во время выполнения bench(diffSubstract) процессор делал что-то ещё, а к моменту начала 
// bench(diffGetTime) завершил - это нормально для многопроцессорных ОС - поэтому нужно делать много бенчмарков

// function diffSubstract(date1, date2) {
//     return date2 - date1;
// }

// function diffGetTime(date1, date2) {
//     return date2.getTime() - date1.getTime();
// }

// function bench(f) {
//     let date1 = new Date(0);
//     let date2 = new Date();

//     let start = Date.now();

//     for (let i = 0; i < 100000; i++) f(date1, date2);

//     return Date.now() - start;
// }

// let time1 = 0;
// let time2 = 0;

// предварительные запуски функций для "разогрева"
// bench(diffSubstract);
// bench(diffGetTime);

// запущу бенч каждой функции 10 раз
// for (let i = 0; i < 10; i++) {
//     time1 += bench(diffSubstract);
//     time2 += bench(diffGetTime);
// }
// console.log(`
// итоговое время diffSubstract: ${time1}
// итоговое время diffGetTime: ${time2}
// `);

// современные интерпретаторы не оптимизируют должным образом то, что выполняется 1 раз (или редко), оптимнизируют только то,
// что выполняется много раз. Поэтому делают предварительные запуски для "разогрева". Я напишу их выше.

// Разбор строки с датой
// метод Date.parse(str) - получает дату из строки.
// формат строки должен быть YYYY-MM-DDTHH:mm:ss.sssZ, где
// YYYY-MM-DD - год, месяц и день, символ Т - используется как разделительб HH:mm:ss.sss - часы, минуты, секунды, миллисекунды,
// Z - необязательная часть - обозначает часовой пояс в формате +- hh:mm, если указать просто букву Z - получу UTC+0.
// возможно сокращённое использование, тогда просто из аргумента убирается ненужное.
// Вызов этого метода возвращает таймстамп (количество миллисекунд с 1 янв 1970 UTC+0), если формат неправильный - NaN.

// let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
// console.log(ms); // 1327611110417

// можно создать объект Date из таймстампа
// let date = new Date(Date.parse('2012-01-26T13:51:50.417-07:00'));
// console.log(date); // Fri Jan 27 2012 00:51:50 GMT+0400 (Moscow Standard Time)
// let date2 = new Date(Date.parse('2012-01-26'));
// console.log(date2); // Thu Jan 26 2012 04:00:00 GMT+0400 (Moscow Standard Time)

// Задачи после раздела

// создать объект дата с нужной датой и временем
// let date = new Date(Date.parse('2012-01-20T03:12'));
// console.log(date);

//написать функцию, показывающую день недели
// let date = new Date(2012, 0, 3);

// function getWeekDay(date) {
//     let weekDays = ['ВС', 'ПН', 'ВТ', 'СР', 'ЧТ', 'ПТ', 'СБ',];

//     return weekDays[date.getDay()];
// }

// console.log(getWeekDay(date));

// день в европейской нумерации
// let date = new Date(2012, 0, 3);

// function getLocalDay(date) {
//     let day = date.getDay();

//     if (day == 0) {
//         day = 7;
//     }

//     return day;
// }

// console.log(getLocalDay(date));

// какой месяц был много дней назад
// let date = new Date(2015, 0 ,2);
// console.log(date);

// function getDateAgo(date, days) {
//     let dateCopy = new Date(date);

//     dateCopy.setDate(date.getDate() - days);

//     return dateCopy;
// }

// console.log(getDateAgo(date, 365));

// Последнее число месяца
// function getLastDayOfMonth(year, month) {
//     let date = new Date(year, month + 1, 0);

//     return date.getDate();
// }

// console.log(getLastDayOfMonth(2023, 1));

// // Сколько сегодня прошло секунд
// function getSecondsToday() {
//     let now = new Date();

//     let today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); // получил сегодняшний день с 00 часов, минут, секунд
//     let diff = now - today;

//     return +(diff / 1000).toFixed(0);

// }
// console.log(getSecondsToday());

// // Альтернативное решение
// function getSecondsTodayAlt() {
//     let d = new Date();

//     return d.getHours() * 3600 * d.getMinutes() * d.getSeconds(); // получил часы и минуты и преобразовал их в секунды
// }
// console.log(getSecondsTodayAlt());

// Сколько секунд осталось до завтра
// function getSecondsToTomorrow() {
//     let now = new Date();
//     let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);

//     let remainder = tomorrow - now;


//     return parseInt((remainder / 1e3).toFixed(0), 10);
// }
// console.log(getSecondsToTomorrow());

// Форматирование относительной даты
// let date = new Date(new Date - 58e5);

// function formatDate(date) {
//     let diff = new Date() - date; // разница в милисекундах

//     if (diff < 1e3) {
//         return 'прямо сейчас';
//     }

//     let secondsDiff = Math.floor(diff / 1e3); // преобразовал разницу в секунды

//     if (secondsDiff < 60) {
//         return secondsDiff + ' секунд назад';
//     }

//     let minutesDiff = Math.floor(secondsDiff / 6e1); // преобразовал разницу в минуты

//     if (minutesDiff < 60) {
//         return minutesDiff + ' минут назад';
//     }

//     // отформатировать дату
//     // добавить ведущие нули к единственной цифре дню/месяцу/часам/минуте
//     let d = date;
//     d = [
//         '0' + d.getDate(),
//         '0' + (d.getMonth() + 1),
//         '' + d.getFullYear(),
//         '0' + d.getHours(),
//         '0' + d.getMinutes(),
//     ].map(component => component.slice(-2)); // взять последние 2 цифры из каждого компонента

//     // соеденить компоненты в дату
//     return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
// }
// console.log(formatDate(date));

// Формат JSON, метод toJSON

// часто нужно преобразовать объект в строку, для этого подходит toString(){}, но если я имею дело со сложным объектом,
// подобные преобразования могут стать проблемой. Для этого есть специальные методы.
// JSON - общий формат для представления значений и объектов, он может использоваться, когда клиент использует JavaScript,
// а сервер написан на Ruby/PHP/Java или любом другом языке.

// JavaScript предоставляет методы: JSON.stringify - для преобразования объектов в JSON, JSON.parse - для преобразования
// JSON обратно в объект.

// let student = {
//     name: 'Ivan',
//     age: 28,
//     isAdmin: false,
//     courses: ['html', 'css', 'js'],
//     wife: null,
// };

// let json = JSON.stringify(student);
// console.log(json, typeof json); // {"name":"Ivan","age":28,"isAdmin":false,"courses":["html","css","js"],"wife":null} string
// полученная строка называется JSON-форматированным или сериализованным объектом. Его можно отправить по сети и т.д.

// Важной особенностью является то, что в отличие от объектного литерала, строки в JSON используют строго двойные кавычки,
// имена свойств также заключаются в двойные кавычки.

// JSON.stringify может быть применён для примитивов. Сам JSON поддерживает следующие типы данных:
// объекты, массивы, строки, числа, логические значения, null.
// пример:
// console.log(JSON.stringify(1)); // 1 - остаётся числом, но его тип текстовый
// console.log(JSON.stringify('text')); // "text" - остаётся текстом, но в двойных кавычках
// console.log(JSON.stringify(true)); // true - остаётся булевым, но его тип текстовый
// console.log(JSON.stringify([1, 2, 3,])); // остаётся массивом, но его тип текстовый

// JSON является независимой от языка спецификацией данных, поэтому может пропускать некоторые специфичные свойства,
// такие как свойства-функции(методы объекта), символьные ключи и значения, свойства, содержащие undefined. Но это
// поведение можно настроить.

// Замечательно то, что поддерживаются вложенные объекты, они конвертируются в строку автоматически.
// Важное ОГРАНИЧЧЕНИЕ - не должно быть циклических ссылок!
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: ['Johnn', 'Ann'],
// };

// meetup.place = room; // ссылается на room
// room.ocupiedBy = meetup; // ссылается на meetup

// JSON.stringify(meetup); // ERROR: Converting circular structure to JSON

// Исключаем и преобразуем replacer

// полный синтаксис JSON.stringify
// let json = JSON.stringify(value, [replacer, space]), где value - значение для кодирования,
// replacer - массив свойств для кодирования или функция соответствия function(key, value),
// space - дополнительное пространство (отступы), используемые для форматирования.

// в большинстве случаев обычного вызова достаточно, но если мне нужно отфильтровать циклические ссылки, то
// можно использовать второй аргумент.

// если передать массив свойств, то будут закодированны только они
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: [{ name: 'Johnn' }, { name: 'Ann' }],
//     place: room, // ссылается на room
// };

// room.occupedBy = meetup; // ссылается на meetup
// console.log(JSON.stringify(meetup, ['title', 'parcipiants'])); // {"title":"Conference","parcipiants":[{},{}]}

// Здесь список свойств строго определяется ко всей структуре объекта, и внутри parcipiants пустые объекты,
// потому что name нет в списке.

// включу в список свойств все, кроме occupedBy
// console.log(JSON.stringify(meetup, ['title', 'parcipiants', 'place', 'name', 'number'])); // {"title":"Conference","parcipiants":[{"name":"Johnn"},{"name":"Ann"}],"place":{"number":23}}

// теперь всё, кроме occupedBy сериализовано, но список действий довольно длинный
// но в качестве replacer я могу использовать функцию, а не массив. Она будет вызываться для каждой пары (key, value), и она
// должна возвращать заменённое значение, которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.

// в моём случае можно вернуть value "как есть" для всего, кроме occupedBy, occupedBy будет проигнорировано, так как функция
// вернёт undefined

// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     parcipiants: [{ name: 'Johnn' }, { name: 'Ann' }],
//     place: room, // ссылается на room
// };

// room.occupedBy = meetup; // ссылается на meetup
// console.log(JSON.stringify(meetup, function replacer(key, value) {
//     return (key === 'occupedBy') ? undefined : value;
// }, 2));

// важно что функция replacer получает каждую пару ключ-значение, включая вложенные объекты и элементы массива
// Значение this внутри replacer - это сам объект, который содержит теущее свойство.
// Первый вызов особенный - ему передаётся специальный "объект-обёртка" {"": meetup}, другими словами - первая пара
// ключ-значение будет иметь пустой ключ, а значением будет целевой объект в общем. Идея в том, чтобы дать replacer как
// можно больше возможностей - проанализировать весь объект, заменить или даже пропустить весь объект целиком.

// Форматирование space
// для передачи данных по сети этот аргумент не нужен, он нужен, чтобы выводить файл в удобочитаемом виде - для логирования
// и красивого вида.

// Пользовательский 'toJSON'
// как и toString() для преобразования строк, объект может предоставлять метод toJSON для преобразования в строку.
// JSON.srtingify автоматически вызывает его, если он есть, например:
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Conference',
//     date: new Date(Date.UTC(2017, 0, 1)),
//     room,
// };
// console.log(JSON.stringify(meetup)); // {"title":"Conference","date":"2017-01-01T00:00:00.000Z","room":{"number":23}}
// дата стала текстовой, потому что объект Date имеет встроееный метод toJSON, который возвращает строку.

// можно реализовать подобный метод toJSON
// let room = {
//     number: 23,
//     toJSON() {
//         return this.number;
//     },
// };

// let meetup = {
//     title: 'Conference',
//     room,
// };
// console.log(JSON.stringify(room)); // 23
// console.log(JSON.stringify(meetup)); // {"title":"Conference","room":23}

// как видно, toJSON используется как при прямом вызове JSON.stringify, так и когда room вложен в другой сериализуемый объект.

// JSON.parse

// чтобы декодировать строку, мне нужен другой метод - JSON.parse
// его синтаксис: let value = JSON.parse(str, [reviver]);
// str - JSON для преобразования в объект,
// reviver - необязательная функция, которая будет вызываться для каждой пары ключ/значение, может преобразоввывать значения

// пример
// let numbers = "[1, 2, 3, 4, 5, 6]"; // строковый массив
// numbers = JSON.parse(numbers);
// console.log(numbers, numbers[3]); // [1, 2, 3, 4, 5, 6] 4

// или для вложенных объектов
// let user = '{ "name": "Ivan", "age": 28, "isAdmin": false, "friends": [0, 1, 2, 3, 4, 5] }';
// user = JSON.parse(user);
// console.log(user.friends[1]); // 1

// JSON может быть настолько сложным, насколько это необходимо. Объекты могут включать массивы, другие объекты.
// Написанный от руки JSON может включать ошибки - иногда от руки пишут для отладки.
// let json = '{
//     name: "John", // здесь ошибка - ключ без двойных кавычек
//     "surname": 'Smith', // ошибка - одинарные кавычки
//     'isAdmin': false, // одинарные кавычки
//     "birthday": new Date(200,0,3), // нельзя использовать конструктор new, только значения объекта Date
//     "friends": [0,1,2,3,4], // здесь все в порядке
// }';

// Также JSON не поддерживает комментарии - если они есть - файл считается недействительным.
// есть формат JSON5, который поддерживает одинарные кавычки и комментарии, но это отдельная библиотека.
// а строгость обычного JSON нужна для легкой и надёжной и быстрой реализации алгоритма кодирования и чтения.

// Использование Reviver

// допустим, я получил с сервера объект meetup в виде строки данных, вот такой
// title: (meetup title), date: (meetup date)
// let str = '{"title": "Conference", "date": "2017-11-30T12:00:00.000Z"}';

// теперь мне нужно его десериализовать, т.е снова превратить в объект JavaScript
// let meetup = JSON.parse(str);
// console.log(meetup.date.getDate()); // ошибка
// потому, что значением meetup.date является строка, а не объект Date

// теперь я передам JSON.parse функцию восстановления, вторым аргументом, которая будет возвращать значения как есть,
// но date станет Date

// let meetup = JSON.parse(str, function (key, value) {
//     if (key == 'date') return new Date(value);
//     return value;
// });
// console.log(meetup.date.getDate(), meetup.date.getFullYear()); // 30 2017 - работает!

// кстати, это работает и для вложенных объектов
// let scedule = `{
//     "meetups": [
//         {"title": "Conference", "date":"2017-11-30T12:00:00.000Z"},
//         {"title": "bithday", "date":"2017-04-18T12:00:00.000Z"}
//     ]
// }`;

// scedule = JSON.parse(scedule, function (key, value) {
//     if (key == 'date') return new Date(value);
//     return value;
// });
// console.log(scedule.meetups[0].date.getMonth() + 1); // 11 - всё работает!

// Задачи после раздела

// преобразовать объект в JSON, а затем обратно в в обычный объект (прочитать его в другую переменную)
// let user = {
//     name: "Василий Иванович",
//     age: 35,
// };
// // user = JSON.stringify(user);
// // console.log(user, typeof user); // {"name":"Василий Иванович","age":35} string

// // let parseUser = JSON.parse(user);
// // console.log(parseUser.name, parseUser); // Василий Иванович {name: 'Василий Иванович', age: 35}

// // или так
// let parsedUser = JSON.parse(JSON.stringify(user));
// console.log(parsedUser, parsedUser.name); // {name: 'Василий Иванович', age: 35} 'Василий Иванович'

// Исключить обратные ссылки
//  написать функцию для JSON-преобразования, которая удалит свойства, ссылающиеся на meetup
// let room = {
//     number: 23,
// };

// let meetup = {
//     title: 'Совещание',
//     occupiedBy: [{ name: 'Иванов' }, { name: 'Петров' }],
//     place: room,
// };

// // цикличные ссылки
// room.occupiedBy = meetup;
// meetup.self = meetup;

// console.log(JSON.stringify(meetup, function replacer(key, value) {
//     return (key != '' && value == meetup) ? undefined : value;
// })); // {"title":"Совещание","occupiedBy":[{"name":"Иванов"},{"name":"Петров"}],"place":{"number":23}}

// Продвинутая работа с функциями - рекурсия и стек
// рекурсия - это приём программирования, полезный, когда задача может быть естественно разделена на несколько
// аналогичных более простых задач или когда задача может быть упрощена до несложных действих, плюс простой вариант той же задачи.
// Рекурсия - это когда функция в определённый момент вызывает сама себя.

// Два способа мышления
// рассмотрим два способа реализации функции возведения в степень
// 1 - итеративный способ
// function pow(x, n) {
//     let result = 1;

//     if (n === 1) return x;

//     for (let i = 1; i < n; i++) {
//         result *= x;
//     }

//     return result;
// }
// console.log(pow(2, 3));

// 2 - рекурсивный способ - упрощение задачи и вызов функцией самой себя
// function pow(x, n) {
//     if (n === 1) {
//         return x;
//     } else if (n === 0) {
//         return 1;
//     } else {
//         return x * pow(x, n - 1);
//     }
// }
// console.log(pow(4, 3));
// первые две ветви - база рекурсии, потому что они сразу приводят к очевидному результату,
// третья ветвь (else) - представляет pow(x, n) как x * pow(x, n - 1), эта ветвь является шагом рекурсии, в ней
// я свожу задачу к более простому действию (уможение на x) и более простой аналогичной задаче (pow с меньшим n),
// а последующие шаги всё больше упрощают задачу, пока n не достигает 1. - Иначе говоря, функция рекурсивно вызывает
// саму себя. пока n не станет 1.

// Рекурсивное решение обычно короче. Можно также сократить if (но без проверки на n === 0) - для примера.
// function pow(x, n) {
//     return (n ===1) ? x : (x * pow(x, n - 1));
// }
// общее количество вложенных вызовов называют глубиной рекурсии. В моём случае она равна n.
// Максимальная глубина рекурсии ограничена движком, точно можно расчитывать на 10 000, некоторые интерпретаторы допускают больше,
// но для большинства 100 000 вызовов - предел.

// Контекст выполнения и стек
// информация о запущенной функции хранится в  её контексте выполнения - специальная внутренняя структура данных,
// содержащая информацию о вызове функции.
// Один вызов функции имеет ровно один контекст выполнения, связанный с ним, на каждый вложенный вызов также создаётся свой контекст.
// Контекст вызова функции запоминается в специальной структуре данных - стеке контекста выполнения.
// После их завершения каждый контекст достаётся из стека и выполнения внешней функции возобновляется с того места, где она
// была остановлена.
// Когда функция завершается, её контекст больше не нужен - он удаляется из памяти, а из стека восстанавливается её
// предыдущий вызов.
// Глубина рекурсии равна максимальному числу контекстов, хранимых в стеке.
// Так как рекурсия хранит все выполнения функции в памяти, то реализация примера выше предпочтительна через итеративный подход,
// так как более экономна, так используется один контекст выполнения, при этом объём затрачивания памяти фиксированный на все итерации
// внутри функции.
// Любая рекурсия может быть передана в цикл - как правило, цикл более производителен, но часто рекурсию используют для
// удобства и читаемости кода.

// Рекурсивный обход
// это отличный способ применения рекурсии.

// Допустим, есть сложная компания с кучей подотделов, и нужно получить сумму всех зарплат.
// Использовать цикл с кучей вложенных циклов сложно, плюс подотделы могут добавляться.
// let company = {
//     sales: [{
//         name: 'John',
//         salary: 1000
//     }, {
//         name: 'Alice',
//         salary: 600
//     }],
//     development: {
//         sites: [{
//             name: 'Peter',
//             salary: 2000
//         }, {
//             name: 'Alex',
//             salary: 1800
//         }],
//         internals: [{
//             name: 'Jack', salary: 1300
//         }]
//     },
// };

// function sumSalaries(department) {
//     if (Array.isArray(department)) {
//         return department.reduce((prev, current) => prev + current.salary, 0)
//     } else {
//         let sum = 0;

//         for (let subdep of Object.values(department)) {
//             sum += sumSalaries(subdep);
//         }

//         return sum;
//     }
// }

// console.log(sumSalaries(company)); // 6700
// принцип такой - для объектов вызывается рекурсия, а массивы обрабатываются сразу

// Рекурсивные структуры
// Рекурсивная (рекурсивно определяемая) структура данных - структура, которая повторяет саму себя в своих частях
// (как в примере с company). В веб-разработке, это содержимое html-тега - текст, теги, комментарии.

// Связный список
// иногда нужно хранить упорядоченные списки объектов. Но операции с элементами массива, как удаление с начала массива,
// или добавление в начало массива слишком ресурсозатратны. Если мне нужно быстро удалить/вставить элементы,
// я могу использовать специальную структуру данных - связные списки - базовая динмаическая структура данных,
// состоящая из узлов, содержащих данные и ссылки на следующий или предыдущий узел списка. Преимущество перед массивом втом,
// что порядок расположения элементов внутри списка может не совпадать с порядком хранения этих элементов в памяти компьютера.

// Элемент связного списка определяется рекурсивно, как объект с:
// value и next - свойство, ссылающееся на следующий элемент связного списка или null, если это последний элемент.
// Например
// let list1 = {
//     value: 1,
//     next: {
//         value: 2,
//         next: {
//             value: 3,
//             next: {
//                 value: 4,
//                 next: null
//             }
//         }
//     }
// };
// console.log(list1);

// // альтернативный способ создания 
// let list2 = {value: 1};
// list2.next = {value: 2};
// list2.next.next = {value: 3};
// list2.next.next.next = {value: 4};
// console.log(list2); // в этом примере видно несколько объектов, каждый из которых имеет value и next

// список можно разделить на несколько частей и соеденить обратно
// let firstList = {value: 1};
// firstList.next = {value: 2};
// firstList.next.next = {value: 3};

// let secondList = {value: 4};
// secondList.next = {value: null};

// // объединяю
// firstList.next.next.next = secondList;
// console.log(firstList);

// вставляю и удаляю элементы в любом месте списка
// let list = { value: 1 };
// list.next = { value: 2 };
// list.next.next = { value: 3 };
// list.next.next.next = { value: 4 };

// list = {value: 'new item', next: list};
// console.log(list);

// // чтобы удалить значение в середине списка, нужно изменить значение next предыдущего элемента
// list.next = list.next.next; // удаляю элемент с value: 2 - он также удалится из памяти, если не хранится где-то ещё.
// console.log(list);

// основной недостаток связного списка в том, что я не могу получить элемент по его индексу
// списки можно улучшить, добавив свойство prev - ссылку, ведущую на предыдущий элемент, можно добавить переменную tail,
// которая будет ссылаться на последний элемент списка (и обновлять при добавлении элементов с конца).
// Самое важное - чтобы используемая структура данных соответствовала моей задаче в части производительности и удобства.

// Задачи после раздела

//вычислить сумму чисел до данного. Сделать три варианта решения: итеративный, рекурсивный, с использованием
// формулы арифметической прогрессии.
// итеративный
// function sumTo(n) {
//     let sum = 0;

//     if (n === 0 || n === 1) {
//         return n;
//     } else if (n < 0) {
//         return 'Try to use positive value';
//     } else {
//         for (let i = n; i > 0; i--) {
//             sum += i;
//         }

//         return sum;
//     }
// }
// console.log(sumTo(4)); // 4+3+2+1=10

// рекурсивный
// function sumTo(n) {
//     if (n === 0 || n === 1) {
//         return n;
//     } else if (n < 0) {
//         return 'Try to use positive value';
//     } else {
//         return (n + sumTo(n - 1));
//     }
// }
// console.log(sumTo(4));

// арифметическая прогрессия. Формула из решения: n*(n+1)/2
// function sumTo(n) {
//     return (n * (n + 1) / 2);
// }
// console.log(sumTo(4));

// вычислить факториал (использовать рекурсию)
// function factorial(n) {
//     return (n <= 1) ? n : (n * factorial(n - 1));
// }
// console.log(factorial(5));

// числа Фибоначчи (определяется формулой F = Fn-1 + Fn-2 ...) - т.e. следующее число - это сумма двух предыдущих
// написать функцию, которая возвращает n-е число Фибоначчи.Первые два числа равны 1, затем 2(1+1), 3(2+1), 4(3+1) и т.д.
// function fib(n) {
//     return (n <= 1) ? n : fib(n - 1) + fib (n - 2);
// }
// console.log(fib(7)); // 13
// если передать например 77 - то можно повесить браузер из-за огромного количества вложенных вызовов - я повесил.

// вывод односвязного списка
// использовать рекурсию и цикл, чтобы выводить элементы списка по одному
// let list = {
//     value: 1,
//     next: {
//         value: 2,
//         next: {
//             value: 3,
//             next: {
//                 value: 4,
//                 next: null
//             }
//         }
//     }
// };

// вариант с циклом
// function printList(obj) {
//     let tempObj = obj;

//     while (tempObj) {
//         console.log(tempObj.value);
//         tempObj = tempObj.next;

//         if (tempObj.next === null) {
//             console.log(tempObj.value);
//             break;
//         }
//     }
// }
// printList(list);

// вариант с рекурсией
// function printList(obj) {
//     console.log(obj.value);

//     if(obj.next) {
//         printList(obj.next);
//     }
// }
// printList(list);

// вывод связного списка в обратном порядке
// let list = {
//     value: 1,
//     next: {
//         value: 2,
//         next: {
//             value: 3,
//             next: {
//                 value: 4,
//                 next: null
//             }
//         }
//     }
// };

// вариант с циклом
// сначала получить элементы в массив, затем перебрать в обратном порядке
// function printReverseList(obj) {
//     let tempObj = obj;
//     let arr = [];

//     while(tempObj) {
//         arr.push(tempObj.value);
//         tempObj = tempObj.next;
//     }

//     for (let i = arr.length - 1; i >= 0; i--) {
//         console.log(arr[i]);
//     }
// }
// printReverseList(list);

// вариант с рекурсией
// function printReverseList(obj) {
//     if (obj.next) {
//         printReverseList(obj.next);
//     }

//     console.log(obj.value);
// }
// printReverseList(list);
// рекурсивное решение делает тоже самое - проходит список, запоминает элементы в цепочке вложенных вызовов, а затем выводит их.

// Остаточные параметры и оператор расширения

// вызвать функцию можно слюбым количесвтом параметров/аргументов, не зависимо от того, как она была определена
// function sum(a, b) {
//     return a + b;
// }
// console.log(sum(1, 2, 3, 4, 5)); // 3 - лишние аргументы не вызовут ошибку, но посчитаются только первые два

// Остаточные параметры могут быть указаны через ... - буквально это значит - собери оставшиеся и полжи в массив
// соберем аргументы в массив args
// function sumAll(...args) {
//     let sum = 0;

//     for (let arg of args) {
//         sum += arg;
//     }

//     return sum;
// }

// console.log(sumAll(1)); // 1
// console.log(sumAll(1, 2, 3)); // 6
// console.log(sumAll(1, 2, 3, 4, 5)); // 15

// можно положить первые несколько аргументов в переменные, а остальные положить в массив
// function showName(name, surname, ...titles) {
//     console.log(name + ' ' + surname);
//     console.log('>>>');
//     console.log(titles[0], titles[1]);
//     console.log(titles[2]);
// }
// showName("Юлий", "Цезарь", "Консул", "Император", "Римский");

// остаточные параметры должны располагаться в конце! иначе это вызовет ошибку

// Переменная arguments
// все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами
// function showName() {
//     console.log(arguments[0]);
//     console.log(arguments[1]);
//     console.log(arguments[2]);

//     // объект arguments можно перебирать
//     for (let arg of arguments) {
//         alert(arg);
//     }

//     alert(arguments[0]);
//     alert(arguments[1]);
// }
// showName('Ivan', 'Linnik', 'Web-developer');

// раньше не было остаточных параметров, был только псевдомассив arguments - его недостаток в том, что методы массивов
// к нему не применимы, а вот с остаточными параметрами такой проблемы нет - это массив.

// стрелочные функции не имеют argumens, если к ним обратиться, то стрелочная функция возьмёт их из внешней функции
// function f() {
//     let showArg = () => console.log(arguments[0]);
//     showArg(2);
// }
// f(1); // 1, а 2 - не будет выведено.
// получается, что у стрелочных функций нет собственного this, а также arguments.

// Оператор расширения
// я узнал, как получить массив из списка параметров, но иногда нужно сделать противоположное.
// Для этого есть оператор расширения ... - он пожох на остаточные параметры, но делает противоположное
// let arr = [1, 2, 3, 4, 5];

// console.log(Math.max(arr)); // NaN - не сработает
// console.log(Math.max(...arr)); // 5 - сработало - когда ...arr используется при вызове функции, он расширяется в список аргументов.

// таким же способом можно передать несколько итерируемых объектов
// let arr = [1, 2, 3, 4, 5];
// let arr2 = [1, 4, 3, 5, 6, 7];

// console.log(Math.max(...arr, ...arr2, 6)); // 7

// оператор расширения можно использовать для слияния массивов
// let arr1 = [1, 2, 3];
// let arr2 = [4, 5, 6, 7];
// let merged = [0, ...arr1, ...arr2, 8];
// console.log(merged); // [0, 1, 2, 3, 4, 5, 6, 7, 8]

// оператор расширения работает с любым перебираемым объектом
// превращу строку в массив символов
// let str = 'Hello';
// console.log([...str]); // ['H', 'e', 'l', 'l', 'o']
// под капотом оператора расширения находятся итераторы, работают также как for..of, он перебирает элементы последовательно,
// полученные элементы помещаются в массив при помощи []. Это же можно сделать при помощи Array.from()
// console.log(Array.from(str)); // ['H', 'e', 'l', 'l', 'o'], НО
// Array.from() работает как псевдомассивами, так и итерируемыми объектами, а оператор расширения только с итерируемыми
// объектами!

// Если я вижу ... в конце аргументов функции - это остаточные парметры - собирает оставшиеся элементы в массив,
// если в вызове функции - оператор расширения - получает список аргументов из массива.

// Остаточные параметры используются для создания функций с неопределённым количеством аргументов,
// Оператор расширения вставляет массив в функцию, которая по умолчанию работает с обычным списком аргументов.

// Замыкание

// рассмотрю пару примеров
// 1
// let name = 'Ivan';

// function showName() {
//     console.log('Hi, ' + name);
// }

// name = 'Choice';
// showName(); // Hi, Choice

// 2
// function makeWorker() {
//     let name = 'Pete';

//     return function() {
//         console.log(name);
//     }
// }

// let name = 'John';
// // создал новую функцию
// let worker = makeWorker();
// // вызвал новую функцию
// worker(); // Pete - использовалась переменная из тела функции


// Лексическое окружение
// в JavaScript у каждого блока кода, функции, переменной есть связанный с ними скрытый объект - лексическое окружение.
// Объект лексического окружения состоит из двух частей: Envoriment record - хранит все локальные свойства, как переменные,
// в нём например, хранится this, и ссылка на внешнее окружение - на то, что находится снаружи - оно связано со всем скриптом.
// У глобального лексического окружения нет внешнего окружения, поэтому оно ссылается на null, но оно менятся, например при
// присваивании переменной

// Когда код хочет получить доступ к переменной, он сначала ищет во внутреннем лексическом окружении, потом во внешнем, и так до
// глобального окружения. Если переменную найти не удаётся - то в строгом режиме будет ошибка, без него, для обратной
// совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.

// Функция получает текущее значение внешних переменных.

// Один вызов функции - одно лексическое окружение, то есть, при каждом новом вызове этой функции будет создаваться новое
// лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

// Вложенные функции
// функция называется вложенной, когда создаётся внутри другой функции. Это можно использовать для упорядочивания кода:
// function sayHiBye(firstName, lastName) {
//     // функция-помощник
//     function getFullName() {
//         return firstName + ' ' + lastName;
//     }

//     console.log('Hello, ' + getFullName());
//     console.log('Bye, ' + getFullName());
// }
// sayHiBye('Ivan', 'Linnik');

// Функция может быть возвращена: в качестве свойства нового объекта (если внешняя функция создаёт объект с методами),
// либо сама по себе.
// Например, присвою вложенную функцию новому объекту в конструкторе
// function User(name) {
//     // методом объекта станет вложенная функция
//     this.sayHi = function() {
//         console.log('Hi, I\'m' + ' ' + name);
//     };
// }

// let user = new User('Ivan');
// user.sayHi(); // у кода метода sayHi есть доступ к внешней для него переменной name.

// теперь создам и верну функцию-счётчик
// function makeCounter() {
//     let count = 0;

//     return function () {
//         return count++; // есть доступ к внешней переменной count
//     };
// }

// let counter = makeCounter();

// console.log(counter()); // 0
// console.log(counter()); // 1
// console.log(counter()); // 2

// важно, что извне нельзя получить доступ к локальной переменной функции, потому что для каждого нового вызова функции
// создаётся новое локальное окружение.
// Функция всегда запоминает место на её лексическое окружение, благодаря скрытому свойству Envoriment, которое ссылается
// на лексическое окружение места, где они были созданы. Проще говоря - Envoriment - это ссылка на лексическое окружение места,
// где была создана функция.

// В большинстве случаев объект лексического окружения существует до тех пор, пока есть функция, которая может его использовать!
// И только тогда, когда таких не остаётся - окружение уничтожается. Т.е. больше не хранится в памяти.

// Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// В JS - любая функция изначально является замыканием, потому что имеет доступ до глобального лексического
// окружения не зависимо от вложенности. За исключением синтаксиса new Function(о нём позже).

// Блоки кода и циклы, IIFE

// лексическое окружение существует не только для функций, но и для любых блоков кода. Лексическое окружение создаётся
// для при выполнении блока кода и содержит локальные переменные для этого блока.
// Если переменная объявлена в if, то она будет доступна только там.
// Для цикла - на каждую итерацию создаётся своё лексическое окружение. Если переменная объявлена внутри цикла, то она
// доступна только в нём, то есть она не будет доступна ниже цикла.

// Я также могу использовать простые блоки кода, чтобы изолировать переменные в локальной области - просто нужно
// заключить их в фигурные скобки {}. Для чего -> Например в браузере все скрипты, кроме type="module" разделяют
// одну общую глобальную область, и скрипты, ссылаясь на одну и ту же переменную могут менять её значение в глобальной области,
// это может произойти, если переменные имеют одно и то же название. Пробую фигурные скобки (блок кода):
// {
//     let txt = 'Text';
//     console.log(txt); // Text
// }
// console.log(txt); // Ошикба
// из-за того, что у блока есть своё лексическое окружение, код снаружи не видит переменные внутри этого блока.

// IIFE - immediately-invoked function expression - это функция, запускаемая сразу после объявления - может
// встречаться в старом коде. Использовалась раньше, когда не было лексического окружения на уровне блоков кода.
// Может встречаться в старых скриптах. Выглядит так:
// (function() {
//     let message = 'Hello';
//     alert(message);
// })();

// Сборка мусора
// обычно лексическое окружение очищается сразу после выполнения функции, но если например есть вложенная функция и она
// доступна из вне, например присвоена в переменную, то она остаётся достижимой, и не удаляется из памяти, то есть у неё
// остаётся её скрытый объект Invorement, который ссылается на внешнее окружение. Как и с объектом - пока он достижим,
// он остаётся в памяти, как только становится недостижимым удаляется.

// Оптимизация на практике
// Пока функция жива, все внешние переменные сохраняются, и зачастую движки пытаются оптимизировать это, они анализируют
// переменные и могут их удалять, если легко понять, что эта переменная не используется. Например такая переменная может
// стать недоступной при отладке.
// function f() {
//     let value = Math.random();

//     function g() {
//         debugger; // в консоли: напишите alert(value) - выведет, такой "переменной нет!"
//     }

//     return g;
// }

// let g = f();
// g();
// в теории - такая переменная должна быть, но она попала под оптимизацию движка.

// Задачи после раздела

// Независимы ли счётчики
// function makeCounter() {
//     let count = 0;

//     return function () {
//         return count++;
//     }
// }
// let counter1 = makeCounter();
// let counter2 = makeCounter();
// console.log(counter1()); // 0
// console.log(counter1()); // 1
// console.log(counter2()); // 0
// console.log(counter2()); // 1

// Объект счётчика
// function Counter() {
//     let count = 0;

//     this.up = function () {
//         return count++;
//     }

//     this.down = function () {
//         return --count;
//     }
// }

// let counter = new Counter();
// console.log(counter.up()); // 0
// console.log(counter.up()); // 1
// console.log(counter.down()); // 1

// Функция в if
// let phrase = 'Hello';

// if(true) {
//     let name = 'John';

//     function sayHi() {
//         alert(`${phrase}, ${user}`);
//     }
// }
// sayHi(); // is not defined!
// не будет рабоать, потому что переменные и функции объявленные внутри if доступны только в лексической области if (внутри if).

// Сумма с помощью замыканий
// function sum(a) {
//     return function (b) {
//         return a + b; // беррёт "а" из внешнего лексического окружения
//     };
// }
// console.log(sum(3)(4)); // 7, интересно
// console.log(sum(3)(-1)); // 2, интересно


// Фильтрация с помощью функции
// let arr = [1, 2, 3, 4, 5, 6, 7];
// console.log(arr.filter(inBetween(2, 5))); // [2, 3, 4, 5]
// console.log(arr.filter(inArray([1, 4, 7]))); // [1, 4, 7]

// function inBetween(a, b) {
//     return function (x) {
//         return x >= a && x <= b;
//     };
// }

// function inArray(arr) {
//     return function (x) {
//         return arr.includes(x);
//     };
// }

// Сортировать по полю
// есть массив объектов, который нужно отсортировать
// let users = [
//     { name: "John", age: 20, surname: "Johnson" },
//     { name: "Pete", age: 18, surname: "Peterson" },
//     { name: "Ann", age: 19, surname: "Hathaway" },
// ];
// обычный способ: по имени:
// console.log(users.sort((a, b) => { a.name > b.name ? 1 : -1 }));

// по возрасту
// console.log(users.sort((a, b) => a.age > b.age ? 1 : -1));

// написать функцию, чтобы использовать сортировку так users.sort(byField(fieldName))
// function byField(fieldName) {
//     return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
// }
// console.log(users.slice().sort(byField('age'))); // slice - чтобы скопировать объект, не менять его глобально
// console.log(users.sort(byField('name')));

// Армия стрелков
// починить код, чтобы у стрелков были разные номера

// Проблема была в том,что нужно положить i в сам цикл, чтобы лексическая область создавалась внутри цикла, 
// а не вне его, как в примере выше, иначе при каждом вызове функции i будет=10, потому что на момент вызова,
// цикл уже завершил свою работу, а лексическая облать осталась в памяти, и при каждом вызове я буду видеть конечный
// результат итерации.

// function makeArmy() {
//     let shooters = [];

//     for (let i = 0; i < 10; i++) {
//         let shooter = function () {
//             console.log('стрелок №', i);
//         }
//         shooters.push(shooter);
//     }

//     return shooters;
// }

// let army = makeArmy();
// army[0]();
// army[5]();


// Глобальный объект
// предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык программирования.
// В браузере он называется window, в Node.js - global.
// Ко всем свойствам глобального объекта можно обращаться напрямую: alert("Hi") = window.alert("Hi").
// Все переменные объявленные при помощи var становятся частью глобального объекта (для совместимости), но так уже никто не
// делает. С let и const это не сработает. Но если я всё-таки хочу сделать переменную частью глобального объекта, то:
// let any = 5; - не сработает, а window.any = 5; - сработает. НО, использовать глобальные переменные не рекомендуется.
// Универсальное имя глобального объекта - globalThis.

// Объект функции, NFE

// Как мне известно - фунция в JS - это значение. А функция это какой тип? - В JS функции - это объекты.
// Можно представить функцию, как объект, который может делать какое-то действие. Получается, что функции можно
// не только вызывать, но и использовать как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.

// Свойство name
// Объект функции содержит несколько полезных свойств. Нпример имя фунции доступно как свойство name
// function sayHi() {
//     console.log('Hi');
// }
// console.log(sayHi.name); // sayHi
// Логика значения name довольно умна - даже если функция создаётся без имени - оно ей присвоится, вот так:
// let someFunc = function () {
//     console.log('some');
// };
// console.log(someFunc.name); // someFunc

// Это будет рабоать даже в случае присваивания значения по умолчанию
// function f(sayHi = function() {}) {
//     console.log(sayHi.name);
// }
// f(); // sayHi
// Это называется контекстное имя - если функция не имеет name, то JS пытается взять его из контекста.
// Также имена имеют методы объекта.
// let user = {
//     sayHi() {
//         //
//     },
//     sayBye() {
//         //
//     },
// };
// console.log(user.sayHi.name); // sayHi
// console.log(user.sayBye.name); // sayBye

// Бывает так, что корректное имя определить невозможно, тогда свойство name имеет пустое значение.
// функция объявлена внутри массива
// let arr = [function(){}];
// console.log(arr[0].name); // ничего, пусто
// но это бывает редко

// Свойство length
// это встроенное свойсвто функции, которое содержит количество параметров функции в её объявлении.
// например
// function f1(a) { };
// function f2(a, b) { };
// function f3(a, b, ...more) { };
// console.log(f1.length, f2.length, f3.length); // 1 2 2 - как видно, остаточные параметры, не считаются.
// Свойство length часто используется для интроспекций (возможность запросить структуру данных объекта) в функциях,
// которые работают с другими функциями. В примере ниже функция ask принимает в качестве параметров вопрос question
// и произвольное количество функций-обработчиков ответа handler.
// Когда пользователь отвечает на вопрос, функция вызывает обработчики. Я могу передать два типа обработчиков:
// функцию без аргументов, которая будет вызываться в случае положительного ответа и функцию с аргументами, которая будет
// вызываться в обоих случаях и возвращать ответ.
// Чтобы вызвать обработчик handler правильно, буду проверять свойство handler.length.
// Идея в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов(наиболее частый случай),
// но также и возможность передавать универсальные обработчики.
// function ask(question, ...handlers) {
//     let isYes = confirm(question);

//     for (let handler of handlers) {
//         if (handler.length == 0) {
//             if (isYes) handler();
//         } else {
//             handler(isYes);
//         }
//     }
// }
// ask("Вопрос?", () => console.log('Вы ответили да'), result => console.log(result));
// Это частный случай так называемого ad-hoc полиморфизма - обработки аргументов в зависимости от их типа или
// как в моём случае - от свойства length. Эта идея имеет применение в библиотеках JS.

// Пользовательские свойства
// Я могу добавлять такжее пользовательские свойства
// function sayHi() {
//     console.log('Hi');

//     // посчитаю, сколько вызовов я сделал
//     sayHi.counter++;
// }
// sayHi.counter = 0; // начальное значение

// for (let i = 0; i < 5; i++) {
//     sayHi();
// }
// console.log(sayHi.counter);

// Свойство не есть переменная! let counter и sayHi.counter - две независимые вещи. При создании свойства функции
// не создаётся переменная counter.
// Иногда свойство функций могут использоваться вместо замыканий.
// Перепишу счётчик, который использовал ранее
// function makeCounter() {
//     // вместо let count = 0
//     function counter() {
//         return counter.count++;
//     }

//     counter.count = 0;

//     return counter;
// }

// let counter = makeCounter();
// console.log(counter()); // 0
// console.log(counter()); // 1
// Свойство count теперь хранится прямо в функции, а не в её внешнем лексическом окружении.
// Основное отличие в том, что если count объявлено во внешней переменной, то оно недоступно для внешнего кода,
// и изменить его могут только вложенные функции, а если оно присвоено как свойство функции, то я могу его получить.
// function makeCounter() {
//     function counter() {
//         return counter.count++;
//     }

//     counter.count = 0;

//     return counter;
// }
// let newCounter = makeCounter();
// newCounter.count = 10;
// console.log(newCounter()); // 10


// Named Function Expression или NFE
// это термин для function expression, у которого есть имя.
// Объявлю function expression
// let sayHi = function(who) {
//     console.log(`Hi, ${who}`);
// };

// и присвою ему имя
// let sayHi = function func(who) {
//     console.log(`Hi, ${who}`);
// };
// и что мне это дало? Для начала - замечу, что добавление func после function никак ничего не ломает, и не
// превращает выражение в declaration, потому что она всё ещё является выражением присваивания. Функция всё ещё доступна
// как sayHi. Но есть 2 важные особенности ради которых даётся второе имя func:
// Оно позволяет функции ссылаться на себя же; Оно не доступно за пределами функции.

// Например ниже, функция sayHi вызывает себя с Guest, если не передан параметр who
// let sayHi = function func(who) {
//     if (who) {
//         console.log(`Hi, ${who}`);
//     } else {
//         func('Guest'); // использует func, чтобы вызвать себя же
//     }
// }
// sayHi('Ivan'); // Hi, Ivan
// sayHi(); // Hi, Guest

// func(); // вот так не сработает - func не определена(недоступна за пределами функции)/func is not defined

// Зачем использовать func, почему нельзя просто использовать sayHi для вложенного вызова?
// Так сделать можно
// let sayHi = function(who) {
//     if (who) {
//         console.log(`Hi, ${who}`);
//     } else {
//         sayHi("Guest");
//     }
// }
// sayHi('Ivan'); // Hi, Ivan
// sayHi(); // Hi, Guest

// Однако есть проблема, если функция будет присвоена другой переменной, код начнёт выдавать ошибки
// let welcome = sayHi;
// welcome(); // Hi, Guest
// sayHi = null;
// welcome(); // Ошибка! sayHi is not a function
// Так происходит, потому что функция пытается взять sayHi из внешнего лексического окружения, но на момент вызова
// sayHi уже равно null. Поэтому присвоение имени в фанкшн экспрешн как раз призвано решать такие проблемы.
// Исправлю мой код
// let sayHi = function func(who) {
//     if (who) {
//         console.log(`Hi, ${who}!`);
//     } else {
//         func('Guest');
//     }
// }
// sayHi(); // Hi, Guest!
// let welcome = sayHi;
// sayHi = null;
// welcome(); // Hi, Guest! - вложенный вызов работает!
// Теперь всё работает, потому что имя func - локальное, и находится внутри функции. Теперь оно взято не снаружи
// (оттуда недоступно). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.
// Внешний код всё ещё содержит sayHi и welcome, но теперь func - это внутреннее имя функции, таким образом она может
// вызывать себя изнутри.
// !!! это не работает с function declaration, только с function expression. Если я хочу использовать такую возможность,
// то лучше переписать function declaration на named function expression - именованым функциональным выражением.

// Задачи после раздела

// Установка и уменьшение значения счётчика
// function makeCounter() {
//     function counter() {
//         counter.set = function (value) {
//             return counter.count = value;
//         };

//         counter.decrease = function () {
//             return --counter.count;
//         };

//         return counter.count++;
//     }

//     counter.count = 0;

//     return counter;
// }

// let counter = makeCounter();

// console.log(counter()); // 0
// console.log(counter.set(10)); // 10
// console.log(counter.decrease()); // 9
// console.log(counter.decrease()); // 8
// console.log(counter()); // 8
// console.log(counter()); // 9

// Сумма с произвольным количеством скобок
// чтобы это заработало, sum ljkжен возвращать функцию. Между этими вызовами aeyкция должна удерживать в памяти
// текущее значение счётчика. Согласно заданию (нет) функция должна преобразовываться в число, когда используется
// с оператором ==. Т.к. функции - это объекты, можно создать собственный метод, возвращающий число.
// function sum(a) {
//     let currentSum = a;

//     function f(b) {
//         currentSum += b;

//         return f;
//     }

//     f.toString = function () {
//         return currentSum;
//     };

//     return f;
// }
// console.log(sum(2)(3)); // 5
// console.log(sum(1)(2)(3)); // не работает


// Синтакис new Function
// используется редко, но иногда можно использовать толькоо его.
// Синтаксис: let funс = new Function([arg1, arg2, ...argN], 'functionBody'); Например
// let sum = new Function('a', 'b', 'return a + b');
// console.log(sum(2, 3)); // 5

// let sayHi = new Function("console.log('Hello')");
// sayHi(); // Hello

// Главное отличие от привычных способов в том, что функция создаётся "на лету" из строки, переданной во время выполнения.
// Данный синтаксис позволяет превратить любую строку в функцию. Например строку, полученную с сервера, и выполнить её.
// Это используется в очень специфичных случаях, например когда получают код с сервера для динамической компиляции функции
// из шаблона, в сложных веб-приложениях.

// Замыкание
// Обычно функция запоминает, где родилась, эта информация записывается в специальном свойстве Envoriment. 
// Это ссылка на лексическое окружение Lexical  Envoriment, в котором она создана. Но когда функция записана при помощи
// new Function, в её Envoriment записывается ссылка не на внешнее лексическое окружение(где она была создана),
// а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.
// Это полезно, ведь имей она доступ к внешним переменным - были бы проблемы с минификаторами кода.


// Планирование: setTimeout и setInterval
// Я могу вызвать функцию не в данный момент времени, а через время. Это называется планирование вызова.
// Для этого есть специальные методы.
// setTimeout - вызвать функцию один раз через определённое время. setTimeOut(function/code, delay, [arg1], [arg2], ...)
// func/code - обычно это функция, но по историческим причинам можно вызвать строку кода(не рекомендуется).
// delay - задержка перед вызововом в миллисекундах, по умолчанию - 0.
// arg1, arg2 - аргументы, передаваемые в функцию.
//Примеры
// function sayHi() {
//     console.log('Hi!');
// }
// setTimeout(sayHi, 1e3);

// с аргументами
// function sayHi(phrase, who) {
//     console.log(phrase + ', ' + who);
// }
// setTimeout(sayHi, 1e3, 'Hi', 'Ivan');

// Если первый аргумент является строкой, то JS создаст из неё функцию, вот так
// setTimeout('alert("Привет")', 1e3); // это плохо, лучше тогда использовать функцию, вот так
// setTimeout(() => alert('Привет'), 1e3);

// Важно передавать просто ссылку на функцию, а не запускать её (вызывать нужно без скобок, просто sayHi)!

// Отмена через clearTimeout
// вызов setTimeout возвращает идентификатор таймера timerId, который можно использовать для отмены дальнейшего выполнения.
// Синтаксис для отмены: let timerId = setTimeout(...); clearTimeout(timerId);
// Планирую вызов функции, а затем отменяю его (ничего не произойдёт - отменю же)
// let timerId = setTimeout(() => console.log('Nothing happens'), 1e3);
// console.log(timerId); // идентификатор таймера - 1

// clearTimeout(timerId);
// console.log(timerId); // 1 - тот же идентификатор, не принимает значение null после отмены

// В браузере идентификатором таймера является число, в других средах это может быть что-то ещё, Node.js например, возвращает
// объект таймера с дополнительными методами. Нет единой спецификации на метода setTimeout и setInterval, поэтому такое
// поведение нормально.

// setInterval
// синтаксис такой же, как и у setTimeout, аргументы те же. Отличие в том, что setInterval запускает код через указанный
// интервал времени. Остановить запуск можно при помощи clearInterval(timerId).
// повторить с интервалом в 2 секунды
// let timerId = setInterval(() => console.log('tick'), 2e3);
// остановить через 5 секунд
// setTimeout(() => {clearInterval(timerId); console.log('stop');}, 5e3);

// Во время показа alert/prompt/confirm счётчик продолжает тикать, так работает в большинстве браузеров.

// Вложенный setTimeout
// есть два способа запускать что-то регулярно: setInterval и вложенный setTimeout.

// вместо let timerId = setInterval(() => console.log('tick), 2e3);
// let timerId = setTimeout(function tick() {
//     console.log('tick');
//     timerId = setTimeout(tick, 2e3); // *
// }, 2e3);
// метод setTimeuot выше планирует следующий вызов прямо после окончания текущего (*).
// Получается, что вложенный setTimeout более гибкий, чем setInterval, потому что можно запланировать следующий вызов
// по-разному, в зависимости от результатов предыдущего.
// Например нужно написать код, который отправляет запрос на сервер каждые 5 секунд, но если сервер перегружен, то
// необходимо увеличить интервал запросов до 10, 20, 40 секунд. Вот псевдокод:
// let delay = 5e3;
// let isRequest = false;

// let timerId = setTimeout(function request() {
//     // типа отправил запрос на сервер
//     console.log('request has been send with delay: ', delay);

//     if (!isRequest) {
//         delay *= 2;
//     }
//     timerId = setTimeout(request, delay);

// }, delay);

// А если функции, выполнение которых я планирую ресурсоёмкие и требуют больше времени на выполнение, то я могу измерить время,
// затраченное на выполнение и спланировать следующий вызов раньше или позже. Вложенный setTimeout позволяет задать
// задержку между вызовами более точно, чем setInterval.

// Если выполнение функции занимает больше времени, чем задержка, то при использовании setInterval функции будут вызываться
// без задержек, тоже самое произойдёт если функция выполняется быстрее, чем заданный интервал - реальный интерввал выполнения
// будет меньше, чем указано в коде.
// При использовании вложенного setTimeout планирование следующего вызова всегда осуществляется в конце предыдущего,
// это гарантирует чёткий заданный интервал при любом результате выполнения предыдущей функции.

// Сборка мусора и колбэк setTimeout и setInterval
// когда функция передаётся в эти методы, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает
// попадание функции в сборщик мусора, даже если на неё нет других ссылок. Для setInterval функция будет доступна, пока
// не будет вызван clearInterval.
// Побочный эффект в том, что функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные
// существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если функция больше не нужна, то лучше отменить
// её вызов, даже если она очень маленькая.

// setTimeout с нулевой задержкой
// setTimeout(func, 0) = setTimeout(func) - это особый вызов setTimeout, предполагающий, что код будет выполнен
// настолько быстро, насколько это возможно, но планировщик будет вызывать функцию только после завершения выполнения текущего кода.
// setTimeout(() => console.log('Мир'));
// console.log('Привет'); // в итоге - Привет Мир

// В браузере есть задержка на то, как часто внутренние счётчики могут выполняться. В стандарте HTML5 говорится:
// "после 5 вложенных таймеров интервал должен составлять не менее 4 миллисекунд". Пример ниже:
// let start = Date.now();
// let times = [];

// setTimeout(function run() {
//     times.push(Date.now() - start); // запомнил задержку от предыдущего вызова

//     if(start + 100 < Date.now()) console.log(times); // показываю задержку через 100 мс
//     else setTimeout(run, 0); // если нужно ещё запланировать
// }, 0); // [0, 1, 3, 3, 15, 19, 24, 82, 87, 91, 96, 101]
// первый таймер запускается сразу(как и указано в спецификации), а затем задержка вступает в игру, и я вижу 15, 19, 24 и т.д.
// Аналогичное произойдёт и с setInterval - первые несколько раз код внутри выполнится с нулевой задержкой, а затем с 
// задержкой 4+ мс.
// Это существует давно и многие скрипты полагаются на такое поведение, поэтому оно до сих пор сохраняется. Но такого ограничения
// нет в серверном JS, там есть другие способы планирования асинхронных задач. Ограничение в 4 мс относится только к браузерам.

// Важно помнить, что ни один из этих методов не гарантирует точную задержку выполнения по ряду причин, типа перегружен процессор,
// вкладка браузера в фоновом режиме, работа ноутбука от аккумулятора и т.д - всё это может увеличивать минимальный
// интервал срабатывания таймера (минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек
// производительности ОС.


// Задачи после раздела

// Вывод каждую секунду
// использую setInterval
// function printNumbers(from, to) {
//     printNumbers.current = from;

//     let timerId = setInterval(function () {
//         console.log(printNumbers.current);

//         if (printNumbers.current == to) {
//             clearInterval(timerId);
//         };
//         printNumbers.current++;
//     }, 1e3);
// }
// printNumbers(1, 5);

// использую вложенный setTimeout
// function printNumbers(from, to) {
//     printNumbers.current = from;

//     let timerId = setTimeout(function go() {
//         console.log(printNumbers.current);

//         if (printNumbers.current < to) {
//             setTimeout(go, 1e3);
//         }
//         printNumbers.current++;
//     }, 1e3);
// }
// printNumbers(1, 5);

// Замечу, что в обоих случаях есть задержка перед первым запуском, чтобы её убрать нужно вывести первый запуск в отдельную строку,
// вот так
// function printNumbers(from, to) {
//     printNumbers.current = from;

//     function go() {
//         console.log(printNumbers.current);
//         if (printNumbers.current < to) {
//             setTimeout(go, 1e3);
//             printNumbers.current++;
//         }
//         clearTimeout(printNumbers.timerId);
//     }
//     go();
//     printNumbers.timerId = setTimeout(go, 1e3);
// }
// printNumbers(1, 5);



// Декораторы и переадресация вызова call/apply

// Прозрачное кэширование
// допустим у меня есть ресурсоёмкая функция, возвращающая стабильный результат для одного и того же "х".
// и если она вызывается часто, то я могу кэшировать результат для экономии на повторных вычислениях. И вместо того, чтобы
// расширять/усложнять функционал самой функции, я могу обернуть её в функцию-обёртку, которая добавит кэширование.
// Код с пояснениями
// function slow(x) {
//     // ресурсоёмкие вычисления
//     console.log(`Called with x = ${x}`);

//     return x;
// }

// function cachingDecorator(func) {
//     let cache = new Map();

//     return function (x) {
//         if(cache.has(x)) { // если кэш содержит такой х
//             return cache.get(x); // читаем результат из него
//         }

//         let result = func(x); // иначе, вызываем функцию

//         cache.set(x, result); // и кэшируем (запоминаем) результат

//         return result;
//     };
// }

// slow = cachingDecorator(slow);
// console.log(slow(1)); // кэширую 1
// console.log('Again ' + slow(1)); // возвращаю из кэша
// console.log(slow(2)); // кэширую 2
// console.log('Again ' + slow(2)); // возвращаю из кэша

// В коде выше - cachingDecorator - это специальная функция-декоратор, которая принимает в себя другую функцию
// и меняет её поведение. Идея в том, чтобы использовать эту обёртку с любой функцией.
// Результат вызова cachingDecorator является обёрткой, т.е. function(x) оборачивает вызов func(x) в кэширующую логику.

// Применение func.call для передачи контекста
// упомянутый выше декоратор не подходит для работы с методами объекта. Попробую ниже:
// let worker = {
//     someMethod() {
//         return 2;
//     },
//     slow(x) {
//         // очень тяжёлая задача для процессора
//         console.log('Called with x = ' + x);
//         return x * this.someMethod(); // (*)
//     },
// };

// использую такой же декоратор
// function cachingDecorator(func) {
//     let cache = new Map();

//     return function (x) {
//         if (cache.has(x)) {
//             return cache.get(x);
//         }

//         let result = func(x); // (**)

//         cache.set(x, result);

//         return result;
//     };
// }
// console.log(worker.slow(2)); // оригинальный метод работает
// worker.slow = cachingDecorator(worker.slow); // теперь я сделал его кэширующим
// console.log(worker.slow(3)); // Ошибка - Cannnot read properties of undefined (reading 'someMethod')

// Ошибка возникает в строке (*). Функция пытается получить доступ к this.someMethod и завершается ошибкой. Причина в том,
// что в строке (**) cacheDecorator вызывает оригинальную функцию как func(x) и она в данном случае получает this = undefined.
// Получается, что декоратор передаёт вызов оригинальному методу без контекста, поэтому ошибка.
// Так вот, существует встроенный метод, позволяющий вызывать функцию и явно устанавлиать this. Синтаксис:
// func.call(context, arg1, arg2, ...) - он запускает функцию func, используя первый аргумент как её контекст this, а последующие
// как её аргументы.
// Например ниже, я вызову sayHi в контексте разных объектов
// function sayHi() {
//     console.log(`Hi, ${this.name}!`);
// }

// let user = { name: 'John' };
// let admin = { name: 'Admin' };

// sayHi.call(user); // Hi, John!
// sayHi.call(admin); // Hi, Admin!

// // теперь я использую call для вызова функции с контекстом и фразой
// function say(phrase) {
//     console.log(phrase + ', ' + this.name);
// }

// say.call(user, 'Hello'); // Hello, John

// В моём случае я могу использовать call в обёртке для передачи контекста в исходную функцию
// let worker = {
//     someMethod() {
//         return 2;
//     },
//     slow(x) {
//         console.log('Called with x = ' + x);
//         return x * this.someMethod();
//     }
// };

// function cachingDecorator(func) {
//     let cache = new Map();

//     return function(x) {
//         if(cache.has(x)) {
//             return cache.get(x);
//         }

//         let result = func.call(this, x);

//         cache.set(x, result);

//         return result;
//     }
// }
// worker.slow = cachingDecorator(worker.slow); // делаю кэширующую обёртку
// console.log(worker.slow(2)); // всё работает
// console.log(worker.slow(2)); // работает, не вызывает функцию заново, кэшируется

// Переходим к нескольким аргументам. Func.apply
// Как кешировать метод с несколькими аргументами?
// let worker = {
//     slow(min, max) {
//         return min + max; // здесь может быть тяжелая задача
//     }
// };
// во-первых, как теперь использовать оба аргумента для ключа в коллекции cache? Есть несколько способов:
// 1 - Реализовать новую или использовать сторонню структуру данных, более универсальную, чем Map.
// 2 - Использовать вложенные коллекции: cache.set(min) будет Map, которая хранит пару (max, result). Тогда получить
// result можно, вызвав cache.get(min).get(max).
// 3 - Соеденить два значения в одно. В моём случае, можно использовать строку "min,max" как ключ для Map. Для гибкости
// можно передавать хеширующую функцию в декоратор, которая знает, как сделать одно значение из многих. В учебнике говорят,
// что 3-й вариант хорош для многих практических применений, поэтому буду использовать его.
// Также мне нужно заменить func.call(this, x) на func.call(this, ...args), чтобы передавать все аргументы, а не только
// первый.

// let worker = {
//     slow(min, max) {
//         console.log(`Called with: min = ${min}, max = ${max}`);

//         return min + max;
//     },
// };

// более мощный декоратор
// function cacheDecorator(func, hash) {
//     let cache = new Map();

//     return function () {
//         let key = hash(arguments); // (*)

//         if (cache.has(key)) {
//             return cache.get(key);
//         }

//         let result = func.call(this, ...arguments); // (**)

//         cache.set(key, result);

//         return result;
//     };
// }

// function hash(args) {
//     return args[0] + ',' + args[1];
// }

// worker.slow = cacheDecorator(worker.slow, hash);
// console.log(worker.slow(3, 5)); // работает
// console.log(worker.slow(3, 5)); // берёт ответ из кэша
// в строке (*) вызываю функцию hash, которая создаёт один ключ из arguments. Она делает из (3, 5) ключ "3,5"
// в более сложных функциях могут понадобиться более сложные функции хеширования
// затем в строке (**) передаю контекст и все аргументы, полученные обёрткой, не зависимо от их количества в исходную функцию.

// Вместо func.call я мог написать func.apply(this, arguments) - он выполняет func, устанавливая this = context, и принимая
// в качестве аргументов превдомассив args. Единственным отличием от func.call то, что apply вместо списка аргументов (как call),
// apply ожидает псевдомассив.
// Есть небольшая разница - оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call,
// а apply принимает только псевдомассив args. Эти методы дополняют друг друга - для перебираемых объектов сработает call, а для
// псевдомассивов - apply.
// Но если я использую и то, и другое (например массив), то apply будет работать быстрее, потому что движок оптимизирует его
// работу.

// Передача контекста вместе со всеми аргументами другой функции называется перенаправлением вызова.
// вот простейший вид такого перенаправления
// let wrapper = function() {
//     return func.apply(this, arguments);
// }; // при вызове wrapper из внешнего кода его не отличить от вызова исходной функции


// Заимствование метода 

// function hash(args) {
//     return args[0] + ',' + args[1]; // всего два аргумента, а что если больше
// }

// пробую улучшить функцию хеширования
// function hash(args) {
//     return args.join(); // не сработает, потому что args это перебираемый объект и псевдомассив, а не реальный массив
// }
// Но есть простой способ соединения массива
// function hash() {
//     console.log([].join.call(arguments));
// }
// // это называется заимствование метода
// hash(1, 2); // '1,2'
// я заимствую метод join из обычного массива [], вот так [].join. И использую его, чтобы выполнить в контексте arguments - 
// [].join.call(arguments) - это работает, потому что алгоритм встроенного метода очень прост. Он технически принимает this 
// и объединяет this[0], this[1] и т.д. Он намеренно написан так, что допускает любой псевдомассив.

// Задачи после раздела

// Декоратор-шпион
// function work(a, b) {
//     return a + b;
// }

// function spy(func) {

//     function wrapper(...args) { // ...args вместо arguments для хранения реального массива во wrapper
//         wrapper.calls.push(args);
//         return func.apply(this, args);
//     }

//     wrapper.calls = [];

//     return wrapper;
// }

// work = spy(work);

// console.log(work(1, 2)); // 3
// console.log(work(4, 3)); // 7

// for (let launch of work.calls) {
//     console.log(launch);
// }

// Задерживающий декоратор
// function f(x) {
//     console.log(x);
// }

// function delay(func, delay) {
//     return function() {
//         setTimeout(() => func.apply(this, arguments), delay);
//     }
// }

// let f2000 = delay(f, 2e3);
// let f2500 = delay(f, 25e1);

// f2000('test');
// f2500(15);

// Декоратор debounce
// function debounce (func, delay) {
//     debounce.isCoolDown = false;

//     return function () {
//         if (debounce.isCoolDown) return;

//         func.apply(this, arguments);

//         debounce.isCoolDown = true;

//         setTimeout(() => debounce.isCoolDown = false, delay);
//     };
// }

// function alert(x) {
//     console.log('alert', x);
// }

// let f = debounce(alert, 1e3);
// f(1); // выполнится
// f(2); // не выполнится, потому что не прошло  1000 мс
// setTimeout(() => f(3), 100); // не выполнится, потому что не прошло  1000 мс
// setTimeout(() => f(4), 2e3); // выполнится через 2 сек, потому что 2 сек больше 1 сек

// Тормозящий (throttling) декоратор
// function any() {
//     console.log('any');
// }

// function throttle(func, delay) {
//     let isThrottled = false,
//         savedArgs, savedThis;

//     function wrapper() {
//         if (isThrottled) {
//             savedArgs = arguments;
//             savedThis = this;

//             return;
//         }

//         func.apply(this, arguments);

//         isThrottled = true;

//         setTimeout(function () {
//             isThrottled = false;

//             if (savedArgs) {
//                 wrapper.apply(savedThis, savedArgs);
//                 savedArgs = savedThis = null;
//             }
//         }, delay);
//     }

//     return wrapper;
// }

// let f1e3 = throttle(any, 1e3);
// f1e3();
// f1e3();
// f1e3();
// f1e3();
// f1e3();
// f1e3();



// Привязка контекста к функции
// При передаче методов объекта в качестве колбэков, как например для setTimeOut, возникает проблема - потеря this.
// Когда метод передаётся отдельно от объекта - this теряется. Ниже - пример, как это происходи с setTimeout
// let user = {
//     name: 'Ivan',
//     sayHi() {
//         console.log(`Hi, ${this.name}!`);
//     },
// };
// user.sayHi(); // Hi, Ivan!
// setTimeout(user.sayHi, 2e3); // Hi, !

// У setTimeout есть особенность: в браузере он устанавливает this = window, получается, что в примере выше я пытаюсь получить
// window.sayHi - естественно, это undefined.

// 1-е решение - обернуть вызов в анонимную функцию, тем самым создать замыкание:
// setTimeout(function () {
//     user.sayHi();
// }, 1e3); // Hi, Ivan!

// тот же код, но короче:
// setTimeout(() => user.sayHi(),2e3);

// Но теперь в коде появилась уязвимость - что произойдёт, если до момента срабатывания setTimeout в переменную user будет
// записано другое значение? - Тогда вызов неожиданно будет совсем не тот, нужно.
// let user = {
//     name: 'Ivan',
//     sayHi() {
//         console.log(`Hi ${this.name}`);
//     },
// };

// setTimeout(() => user.sayHi(), 1e3);

// user = {sayHi() {console.log('Any user');}};
// Any user

// 2-е решение гарантирует, что это не случится. Нужно использовать bind. Таким образом я привяжу контекст при помощи bind.
// Bind - это встроенный метод, который позволяет зафиксировать this. Его базовый синтаксис: let boundFunc = func.bind(context);
// Результатом вызова func.bind(context) является специальный "экзотический объект", который вызывается как функция и прозрачно
// передаёт вызов в func, при этом устанавливая this = context. Другимим словами, вызов boundFunc подобен вызову func
// с фиксированным this. Например ниже, funcUser передаёт вызов в func, фиксируя this = user.
// let user = {
//     name: 'Ivan',
// };

// function func() {
//     console.log(this.name);
// }
// let funcUser = func.bind(user); // это связаннй вариант func с фиксированным this=user 
// funcUser(); // Ivan

// // Все аргументы передаются исходному методу func как есть, например:
// function funcPhr(phrase) {
//     console.log(phrase + ', ' + this.name);
// }

// let funcUs = funcPhr.bind(user); // привязка this к user
// funcUs('Zdravstvuyte'); // Zdravstvuyte, Ivan

// Теперь попробую с методами объекта
// let user = {
//     name: 'Vika',
//     sayHi() {
//         console.log(`Salut, ${this.name}`);
//     },
// };

// let sayHi = user.sayHi.bind(user); // здесь я беру метод user.sayHi и привязываю его к user
// теперь sayHi это связанная функция, которая может быть вызвана отдельно или передана setTimeout 
// sayHi(); // Salut, Vika

// setTimeout(sayHi, 3e3); // Salut, Vika

// bind исправляет только this (user), а аргументы передаются как есть, ещё пример:
// let user = {
//     name: 'Choice',
//     say(phrase) {
//         console.log(`${phrase}, ${this.name}`);
//     },
// };

// let say = user.say.bind(user);
// say('Hey'); // Hey, Choice
// say('Opa'); // Opa, Choice

// Есть удобный метод bindAll - он нужен, когда у объекта есть множество методов и я планирую их активно передавать.
// Для этого я могу привязать контекст для них в цикле, вот так:
// for (let key in user) {
//     if (typeof user[key] == 'function') {
//         user[key] = user[key].bind(user);
//     }
// }


// Частичное применение
// можно привязать не только this, но и аргументы, но это делается крайне редко, поэтому я просто прочту этот раздел.


// Задачи после раздела
// Связная функция как метод (что выведет функция)
// function f() {
//     console.log(this);
// }

// let user = {
//     g: f.bind(null),
// }

// user.g() // null


// Повторный bind
// function f() {
//     console.log(this.name);
// }
// f = f.bind({ name: 'first' }).bind({ name: 'second' });
// f(); // first - потому что контекст запоминается во время создания, можно сделать новую привязку, но изменить существующую нельзя.

// Свойство функции после bind
// function sayHi() {
//     console.log(`Hi, ${this.name}`);
// }
// sayHi.test = 5;

// let bound = sayHi.bind({
//     name: 'Ivan',
// });

// console.log(bound.test); // undefined

// Исправить функцию, теряющую this
// есть функция, вызов которой даёт ошибку - нужно его исправить. Код самой функции не трогать.
// function askPassword(ok, fail) {
//     let password = prompt('password?', '');

//     if (password === 'rockstar') ok();
//     else fail();
// }

// let user = {
//     name: 'Vasya',
//     loginOk() {
//         console.log(`${this.name} logged in.`)
//     },
//     loginFail() {
//         console.log(`${this.name} failed to log in.`);
//     },
// };

// // askPassword(user.loginOk.bind(user), user.loginFail.bind(user));
// askPassword(() => user.loginOk(), () => user.loginFail()); // - альтернативное решение

// Использование частично применённой функции
// можно изменять только строку с вызовом функции
// function askPassword(ok, fail) {
//     let password = prompt('Password?', '');

//     if (password === 'rockstar') ok();
//     else fail();
// }

// let user = {
//     name: 'Vanya',
//     login(result) {
//         console.log(
//             this.name + (result ? ' logged in' : ' failed to log in')
//         );
//     },
// };

// askPassword(user.login.bind(user, true), user.login.bind(user, false));
// askPassword(() => user.login(true), () => user.login(false)); // альтернативное решение



// Повторяем стрелочные функции
// У стрелочной функции нет this, и я могу это использовать, например для итерации внутри метода объекта.
// let group = {
//     title: 'Any group',
//     students: ['John', 'Pete', 'Alice', 'Patrick'],
//     showList() {
//         this.students.forEach(student => {
//             console.log(this.title + ': ' + student);
//         }); // this.title имеет здесь такое же значение, как group.title. Если бы я использовал обычную функцию,
//         // то была бы ошибка, потому что по умолчанию forEach работает с this = undefined, то есть, я бы пытался
//         // вызвать undefined.title.
//     }
// };
// group.showList();

// Стрелочные функции нельзя использовать в конструкторе new.

// Есть тонкое отличие от bind(this): bind(this) создаёт связанную версию функции, а стрелочная функция ничего не привязывает,
// она просто берёт this из внешнего лексического окружения.

// Стрелочные функции не имеют arguments
// Это отлично подходит для декораторов, когда мне нужно пробросить вызов с текущими this и arguments. Пример ниже:
// defer принимает функцию и возвращает обёртку над ней, которая откладывает вызов на ms:
// function defer(func, ms) {
//     return function() {
//         setTimeout(() => func.apply(this, arguments), ms);
//     }
// }

// function sayHi(who) {
//     console.log(`Hi, ${who}`);
// }

// let darova = defer(sayHi, 2e3);
// darova('Ivan');
// без использования стрелочной функции мне пришлось бы дополнительно объявлять две переменные - для this и arguments, чтобы
// setTimeout могла их получить


// Свойства объекта, их конфигурация
// Флаги свойств
// Помимо value свойства объекта имеют 3 специальных свойства, по умолчанию все они true:
// writable - true - свойство можно изменить, иначе только для чтения,
// enumerable - true - можно перебирать в циклах, иначе при переборе будет игнорироваться,
// configurable - true - можно удалять это свойство, а эти атрибуты можно изменять, иначе ничего нельзя.
// Все эти атрибуты скрыты, но я могу получить и настроить их при помощи Object.getOwnPropertyDescriptor(obj, propertyName).
// Вернётся объект - так называемый дескриптор свойства, он содержит значение свойства и все его флаги
// let user = {
//     name: 'Ivan',
//     age: 28,
// };

// let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
// console.log(descriptor); // {value: 'Ivan', writable: true, enumerable: true, configurable: true}....
// console.log(
//     Object.getOwnPropertyDescriptor(user, 'age')
// );

// Чтобы изменять флаги, я могу использовать метод Object.defineProperty(obj, propertyName, decriptor).
// Если свойство существует, то defineProperty обновит его флаги,  противном случае - метод создаст новое свойство
// с указанным значением и флагами. Если какой-либо флаг не указан явно, ему присвоется значение false.
// let user = {};

// Object.defineProperty(user, "name", {
//     value: 'Vika',
//     enumerable: true,
// });

// console.log(Object.getOwnPropertyDescriptor(user, 'name')); // {value: 'Vika', writable: true, enumerable: false, configurable: false}
// console.log(JSON.stringify(Object.getOwnPropertyDescriptor(user, 'name'))); // {"value":"Vika","writable":true,"enumerable":false,"configurable":false}

// Примеры

// Только для чтения
// let user = {
//     name: 'John',
// };
// // сделаю свойство только для чтения
// Object.defineProperty(user, 'name', {
//     writable: false,
// });

// user.name = 'Pete'; // Uncaught TypeError: Cannot assign to read only property 'name' of object '#<Object>'
// теперь изменить свойсвто можно только обновив флаг, нужно повторно вызвать Object.defineProperty().
// Ошибки появляются в строгом режиме, в нестрогом режиме они игнорируются, но флаги всё равно не изменяются.

// Тот же пример, но свойсвто создано с нуля
// let user = {};

// Object.defineProperty(user, 'name', {
//     value: 'John',
//     // для нового свойсвта нужно явно указать все флаги, значения которых true
//     enumerable: true,
//     configurable: true,
// });

// console.log(user.name); // John
// user.name = 'Pete'; // Ошибка

// Неперечислимое свойсвто
// теперь добавлю собственный метод toString объекту user
// let user = {
//     name: 'John',
//     toString() {
//         return this.name;
//     },
// };

// по умолчанию все свойства выведутся
// for (let prop in user) {
//     console.log(prop); // name  toString
// }
// если я этого не хочу, то мне нужно установить флаг enumerable: false, вот так
// Object.defineProperty(user, 'toString', {
//     enumerable: false,
// });

// // теперь оно не появится
// for (let proper in user) {
//     console.log(proper); // name
// }

// неперечисляемые свойства также не возвращаются в Object.keys
// console.log(Object.keys(user)); // >['name']

// Неконфигурируемое свойсвто
// Флаг неконфигурируемого свойства (configurable: false) иногда предустановлен для некотоорых встроенных объектов и свойств.
// Неконфигурируемое свойство не может быть удалено. Например свойство Math.PI - неконфигурируемое и только для чтения
// let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');
// console.log(descriptor); 

// Определение свойства как неконфигурируемого - это дорога в один конец. Нельзя отменить это действие, потому что
// defineProperty не работает с такими свойствами.
// сделаю свойство навечно запечатанным в константе
// let user = {};

// Object.defineProperty(user, 'name', {
//     value: 'Ivan',
//     configurable: false,
// });

// // console.log(user.name); // Ivan
// for (let prop in user) {
//     console.log(prop); // нихуя, пустая консоль
// }

// user.name = 'Pete'; // Cannot assign to read only property 'name' of object

// И опять, ошибки появляются только в строгом режиме, в нестрогом режиме все подобные действия над неконфигурируемым
// свойством просто игнорируются.

// Метод Object.defineProperties(obj, descriptors)
// он позволяет задать сразу несколько свойств, например
// let user = {};

// Object.defineProperties(user, {
//     name: {value: 'Ivan', configurable: true, iterable: true},
//     surname: {value: 'Linnik', writable: false},
// });

// console.log(user); // >{name: 'Ivan', surname: 'Linnik'}

// Метод Object.getOwnPropertyDescriptors
// позволяет получить получить все десвкрипторы свойств сразу
// console.log(Object.getOwnPropertyDescriptors(user)); // >{name: {…}, surname: {…}}

// Вместе с Object.defineProperties можно использовать этот метод для клонирования объекта вместе с его флагами
// let cloneUser = Object.defineProperties({}, Object.getOwnPropertyDescriptors(user));

// console.log(cloneUser); // >{name: 'Ivan', surname: 'Linnik'}

// Обычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства
// let clone = {};
// for (let key in user) {
//     clone[key] = user[key];
// }
// Но это не клонирует флаги. А если мне нужен клон "получше", предпочтительнее использовать defineProperties.
// Другое отличие в том, что присваивание в цикле игнорирует символьные и неперечисляемые свойства, а
// Object.getOwnPropertyDescriptors возвращает дескрипторы всех свойств.


// Глобальное запечатывание объекта
// Дескрипторы свойств работают на уровне одного конкретного свойства, но ещё есть методы, которые ограничивают доступ ко
// всему объекту. На практике эти методы используются редко. Поэтому я просто с ними бегло ознакомился.


// Свойсвта - геттеры и сеттеры
// Есть два типа свойств объекта: 1 - свойства-данные - обычные свойства объекта, с которыми я уже работал;
// 2 - свойсвта-аксессоры - по своей сути, это функции, которые позволяют получить или присвоить значение свойства, но
// во внешнем коде выглядят они как обычные свойства объекта.
// При литеральном объявлении объекта они обозначаются, как get и  set.
// let obj = {
//     get propName() {
//         // геттер, срабатывает при чтении obj.propName
//     },
//     set propName(value) {
//         // сеттер, срабатывает при записи obj.popName = value
//     }
// };
// рассмотрю пример: есть объект
// let user = {
//     name: 'John',
//     surname: 'Smith',
// };
// теперь добавлю в него свойсвто полного имени fullName. Само собой, я не хочу дублировать код
// let user = {
//     name: 'John',
//     surname: 'Smith',
//     get fullName() {
//         return `${this.name} ${this.surname}`;
//     },
// };
// console.log(user.fullName); // John Smith
// смысл в том, чтобы не вызывать fullName как функцию, а прочитать, как обычное свойство всё, произойдёт за кулисами.
// на данный момент у fullName  есть только геттер, и если присвоить ему значение произойдёт ошибка:
// user.fullName = 'Test'; // Cannot set property fullName of #<Object> which has only a getter
// поэтому
// let user = {
//     name: 'John',
//     surname: 'Smith',
//     get fullName() {
//         return `${this.name} ${this.surname}`;
//     },
//     set fullName(value) {
//         [this.name, this.surname] = value.split(' ');
//     },
// };
// console.log(user.fullName); // John Smith
// user.fullName = 'Ivan Linnik';
// console.log(user.fullName); // Ivan Linnik
// console.log(user.name); // Ivan
// console.log(user.surname); // Linnik
// в итоге я получил виртуальное свойство, его можно получить и изменить


// Дескрипторы свойств доступа
// Свойства-аксессоры не имеют value и writable, но взамен предлагают get и set. Получается, что дескриптор аксессора
// может иметь: get, set, enumerable, configurable. Например:
// let user = {
//     name: "John",
//     surname: "Smith"
// };

// Object.defineProperty(user, 'fullName', {
//     get () {
//         return `${this.name} ${this.surname}`;
//     },
//     set (value) {
//         [this.name, this.surname] = value.split(" ");
//     },
//     enumerable: true,
//     configurable: true
// });

// console.log(user.fullName);

// for (let key of Object.entries(user)) {
//     console.table(key); 
// }
// важно помнить, что свойство объекта может быть либо данными, либо аксессором, при попытке указать например геттер и value
// будет ошикба.


// Умные геттеры сеттеры
// Геттеры и сеттеры можно использовать как обёртки над реальными значениями свойств, чтобы получить больше контроля над операциями
// с этими значениями.В примере ниже - я хочу запретить устанавливать короткое имя для user, поэтому буду использовать для проверки
// сеттер name, а само значение хранить в отдельном свойстве _name:
// let user = {
//     get name() {
//         return this._name;
//     },
//     set name(value) {
//         if (value.length < 4) {
//             console.log('Need more than 3 letters at name');
//             return;
//         }
//         this._name = value;
//     },
// };
// user.name  = 'Pete';
// console.log(user.name); // Pete

// for (let key of Object.entries(user)) {
//     console.table(key); // выведет и name, и _name
// }

// user.name = 'Tom'; // Need more than 3 letters at name

// Таким образом само имя сохранится в _name, доступ к которому производится только через геттер или сеттер.
// Технически внешний код всё ещё может получить доступ к имени напрямую через _name, но существует соглашение, которое гласит,
// что свойства, которые начинаются c символа '_' являются внутренними, и к ним не стоит обращаться за пределами объекта.

// Использование для совместимости
// У геттеров и сеттеров есть необычное свойство - они позволяют в любой момент взять обычное свойство и изменить его поведение,
// поменяв на геттер и сеттер.
// Например, я начал реализовывать объект user:
// function User(name, age) {
//     this.name = name;
//     this.age = age;
// }

// let ivan = new User('Ivan', 28);

// Но теперь, взамен возраста я хочу использовать дату рождения. Что делать со старым кодом, особенно если я хочу сохранить
// свойство age, ведь для пользователя свойство вполне нужное? Можно переписать конструктор с использованием геттера для age

// function User(name, birthday) {
//     this.name = name;
//     this.birthday = birthday;

//     Object.defineProperty(this, 'age', {
//         get() {
//             let todayYear = new Date().getFullYear();
//             return todayYear  - this.birthday.getFullYear();
//         }
//     });
// }

// let john = new User('John', new Date(1994, 8, 18));

// console.log(john.birthday); // Sun Sep 18 1994 00:00:00 GMT+0400 (Moscow Summer Time)
// console.log(john.age); // 29


// Прототипы, наследование. Прототипное наследование.
// В JS объекты имеют специальное скрытое свойство [[Prototype]], которое либо равно null, либо ссылается на другой объект.
// Этот объект называется "прототип". Одним из способов задать прототип является свойство __proto__:
// let animal = {
//     eats: true,
// };

// let rabbit = {
//     jumps: true,
// };

// console.log(rabbit.eats); // undefined

// rabbit.__proto__ = animal;
// console.log(rabbit.eats); // true - если я ищу свойство в rabbit, а его там нет, то теперь оно возьмётся из прототипа.
// Такие свойства называются унаследованными.
// теперь вызову метод в rabbit:
// let animal = {
//     eats: true,
//     walk() {
//         console.log('I\'m walking animal');
//     },
// };

// let rabbit = {
//     jumps: true,
//     __proto__: animal,
// };

// rabbit.walk(); // I'm walking animal - метод автоматически берётся из прототипа

// Цепочка прототипов может быть длиннее
// let animal = {
//     eats: true,
//     walk() {
//         console.log('I\'m walking animal.');
//     },
// };

// let rabbit = {
//     jumps: true,
//     __proto__: animal,
// };

// let longEar = {
//     earLength: 10,
//     __proto__: rabbit,
// };

// longEar.walk(); // I'm walking animal. - взято из цепочки прототипов
// console.log(longEar.jumps); // true - взято из rabbit

// НО есть 2 ограничения: 1 - ссылки не могут идти по кругу - иначе будет ошибка. 2 - значение __proto__ может быть только
// объектом или null, другие типы игнорируются. И ещё - может быть только один __proto__, объект не может
//  наследоваться от двух других объектов.

// Свойство __proto__ - это исторически обусловленный геттер/сеттер для [[Prototype]]. Современный JS предлагает использовать
// Object.getPrototypeOf/Object.setPrototypeOf - я рассмотрю эти функции позже.


// Операция записи не использует прототип

// Прототип используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом.
// let animal = {
//     eats: true,
//     walk() {
//         console.log('Main animal walk');
//     }
// };

// let rabbit = {
//     __proto__: animal,
// };

// rabbit.walk = function() {
//     console.log('Only rabbit walk');
// };

// rabbit.walk(); // Only rabbit walk -  теперь вызов walk() находит метод непосредственно в объекте и не использует прототип

// Свойства аксессоры - исключение,т.к. запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.
// По этой причине admin.fullNmae работает корректно в приведёном ниже коде:
// let user = {
//     name: 'John',
//     surname: 'Smith',

//     set fullName(value) {
//         [this.name, this.surname] = value.split(' ');
//     },
//     get fullName() {
//         return `${this.name} ${this.surname}`;
//     }
// };

// let admin = {
//     __proto__: user,
//     isAdmin: true,
// };

// console.log(admin.fullName); // John Smith - здесь свойство имеет геттер в прототипе user, поэтому вызывается он (геттер)

// admin.fullName = 'Ivan Linnik'; // а здесь будет вызван сеттер, который есть в прототипе

// console.log(admin.name); // Ivan
// console.log(admin.surname); // Linnik
// console.log(admin); // {isAdmin: true, name: 'Ivan', surname: 'Linnik'} - всё работает


// Значение this
// Прототипы никак не влияют на this. Неважно, где находится метод - в объекте или прототипе. При вызове метода this - 
// всегда объект перед точкой. Например:
// let user = {
//     name: 'default',
//     sayHi() {
//         if (this.name === 'default') {
//             console.log('default');
//         } else {
//             console.log(this.name);
//         }
//     },
// };

// let anyUser = {
//     __proto__: user,
// };

// let ivan = {
//     name: 'Ivan',
//     __proto__: user,
// };

// anyUser.sayHi(); // default
// ivan.sayHi(); // Ivan

// В итоге получается, что сами методы являются общими, а состояние объекта - нет.

// Цикл for...in проходит не только по собственным свойствам, но и по унаследованным свойствам объекта.
// let animal = {
//     eats: true,
//     drinks: true,
// };

// let rabbit = {
//     jumps: true,
//     __proto__: animal,
//     longEar: 10,
// };

// console.log(Object.keys(rabbit)); // ['jumps'] - возвращает только собственные ключи

// for (let prop in rabbit) {
//     console.log(prop); // jumps eats - проходит сначала по своим свойствам, затем по унаследованным
// }

// for (let property of Object.keys(rabbit)) {
//     console.log(property); // jumps - тоже только свои свойства
// }

// Также если унаследованные свойства мне не нужны, я могу их отфильтровать при помощи встроенного метода
// obj.hasOwnProperty(key) - он возвращает true, если у объекта есть собственное, не унаследованное свойство с именем key.

// for (let prop in rabbit) {
//     let isOwn = rabbit.hasOwnProperty(prop);

//     if (isOwn) {
//         console.log(`Our: ${prop}`);
//     } else {
//         console.log(`Inherited: ${prop}`);
//     }
// }

// Важная деталь - я не определял метод hasOwnProperty - он был унаследован у Object.prototype.hasOwnProperty.
// В цикле он не появился, потому что у него стоит флаг enumerable: false,  как и у других свойств объекта prototype.


// Задачи после раздела
// Работа с прототипами - ответил устно.

// Алгоритм поиска
// let head = {
//     glasses: 1
// };

// let table = {
//     pen: 3,
//     __proto__: head,
// };

// let bed = {
//     sheet: 1,
//     pillow: 2,
//     __proto__: table,
// };

// let pockets = {
//     money: 2000,
//     __proto__: bed,
// };

// console.log(pockets.pen); // 3
// console.log(bed.glasses); // 1

// function protoTest() {
//     return pockets.glasses;
// }

// function directRequest() {
//     return head.glasses;
// }

// function bench(func) {
//     let start = Date.now();

//     for (let i = 0; i < 1e6; i++) func();

//     return Date.now() - start;
// }

// console.log(bench(protoTest)); // 4-6
// console.log(bench(directRequest)); // 9-11
// При оптимизации движкам неважно, откуда берётся свойство, они достаточно умны, чтобы запомнить, где они его уже нашли.
// Но на моих тестах поиск в прототипах оказался быстрее даже при очисте кеша и жёсткой перезагрузке.

// Куда будет произведена запись? (в rabbit)
// let animal = {
//     eat() {
//         this.full = true;
//         return this.full;
//     }
// };

// let rabbit = {
//     __proto__: animal,
// };
// console.log(rabbit.eat());

// Почему наедаются оба хомяка?
// let hamster = {
//     stomach: [],
//     eat(food) {
//         this.stomach.push(food);
//     },
// };

// let speedy = {
//     __proto__: hamster,
//     stomach: [],
// };

// let lazy = {
//     __proto__: hamster,
//     stomach: [],
// };

// speedy.eat('apple');
// console.log(speedy.stomach); // ['apple']

// console.log(lazy.stomach); // []
// у них один желудок на двоих - таким образом наполняется желудок прототипа

// также можно использовать присваивание вместо push
// let hamster = {
//     stomach: [],
//     eat(food) {
//         this.stomach = [food];
//     },
// };

// let speedy = {
//     __proto__: hamster,
// };

// let lazy = {
//     __proto__: hamster,
// };

// speedy.eat('apple');
// console.log(speedy.stomach); // ['apple']

// console.log(lazy.stomach); // []

// это работает, потому что this.stomach= не ищет свойство stomach, занчение записывается непосредственно в объект this.
// ну и моё решение тоже сработало - я добавил каждому хомяку свой желудок.



// F.prototype
// Как я помню, объекты можно создавать при помощи функции-конструктора new F().
// Если в F.proptotype содержится объект, то оператор new устанавливает его как прототип [[Prototype]] для нового объекта.
// F.prototype всё ещё означет обычное свойство с именем "prototype" для F. Это ещё не прототип объекта, а обычное свойство
// с таким именем. Например:
// let animal = {
//     eats: true,
// };

// function Rabbit(name) {
//     this.name = name;
// }

// Rabbit.prototype = animal;

// let rabbit = new Rabbit('White rabbit'); // rabbit.__proto__ = animal
// console.log(rabbit.eats); // true

// Что здесь произошло:
// при установке Rabbit.prototype = animal я буквально говорю интерпретатору: "При создании объекта через new Rabbit запиши
// ему animal в прототипы".

// Важно помнить, что F.prototype используется только один раз - при создании объекта и присваивается только в качестве
// свойства нового объекта, это стоит воспринимать, как единоразовый подарок объекту. В дальнейшем свойство prototype может
// измениться, как и сама функция-конструктор, но это коснётся только вновь созданных объектов, старых это не коснётся.


// F.prototype по умолчанию, свойство constructor

// У каждой функции по умолчанию уже есть свойство prototype.
// По умолчанию "prototype" - объект с единственным свойством constructor, которое ссылается на единственную функцию-конструктор.
// function Rabbit(
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }
// ) { }

// console.log(Rabbit.prototype.constructor == Rabbit); // true
// console.log(Rabbit.prototype); // {constructor: ƒ}

// Получается, что если я ничего не менял, то свойство конструктор будет доступно всем кроликам через [[Prototype]]
// let rabbit1 = new Rabbit();
// console.log(rabbit1.constructor === Rabbit); // true

// Получается, что я могу использовать свойство constructor существующего конструктора для создания нового.
// function Rabbit(name) {
//     this.name = name;
//     console.log(name);
// }

// let tony = new Rabbit('Tony');
// let ammy = new tony.constructor('Ammy');

// Это удобно, когда у меня есть объект, но я не знаю, какой именно коструктор использовался для создания объекта (например 
// из сторонней библиотеки), а мне нужно создать ещё один такой же объект.

// НО самое важное в свойстве constructor то,что JS сам по себе не гарантирует правильное значения свойства constructor.
// Да, оно является свойством по умолчанию [[Prototype]] у функций, но что случится с ним позже зависит только от меня. В частности,
// если я изменю прототип по умолчаню на другой объект, то значения constructor в нём не будет:
// function Rabbit() {}
// Rabbit.prototype = {
//     jumps: true,
// };

// let rabbit = new Rabbit();
// console.log(rabbit.constructor === Rabbit); // false
// console.log(rabbit.constructor); // ƒ Object() { [native code] }

// Таким образом, чтобы сохранить верное свойство constructor я должен обращаться к прототипу по умолчанию, и менять свойства там,
// а не перезаписывать его целиком.

// function Rabbit() {}

// не перезаписываю Rabbit.protoype полностью, а добавляю к нему свойство
// Rabbit.prototype.jumps = true; // прототип по умолочанию сохраняется, и я всё ещё имею доступ к prototype.constructor
// или я могу заново задать свойство constructor
//  Rabbit.ptototype = {
//     jumps: true,
//     constructor: Rabbit,
//  };
//  console.log(Rabbit.prototype); // 


// Задачи после раздела

// Изменяем "prototype"
// function Rabbit() { }
// Rabbit.prototype = {
//     eats: true,
// };

// let rabbit = new Rabbit();
// console.log(rabbit.eats); // true - бёрет из прототипа функции-конструктора

// теперь меняю код
// Rabbit.prototype = {};
// console.log(rabbit.eats); // true - потому что изменения коснулись только новых объектов, созданных через этот конструктор

// снова меняю код
// Rabbit.prototype = {
//     eats: true
// };
// console.log(rabbit.eats); // true - потому что изменения коснулись только новых объектов, созданных через этот конструктор

// и вот так
// Rabbit.prototype.eats = false;
// console.log(rabbit.eats); // true - потому что изменения коснулись только новых объектов, созданных через этот конструктор

// и все ответы будут такими


// Создайте новый объект при помощи уже существующего
// function User(name) {
//     this.name = name;
//     this.isAdmin = false;
// }

// let obj = new User('Ivan');

// let obj2 = new obj.constructor('Pete');
// console.log(obj2); // сработало


// Встроенные прототипы
// Свойство prototype широко используется внутри самого языка JS. Все встроенные функции-конструкторы используют его.
// Сначала я рассмотрю детали, а затем использую prototype для добавления встроенным объектам новой функциональности.

// Object.prototype
// Давайте выведем пустой объект
// let obj = {};
// console.log(obj); // литеральная нотация и создание объекта через конструктор - это одно и то же, поэтому 
// созданный объект унаследует от глобально прототипа объекта все его методы, а также конструктор глобального объекта и т.д.
// можно проверить это так
// console.log(
//     obj.__proto__ === Object.prototype
// ); // true

// также моё внимание обращают на то, что выше прототипа Object.prototype больше ничего нет, поэтому ниже будет null:
// console.log(
//     Object.prototype.__proto__
// ); // null


// Другие встроенные прототипы
// другие встроенные прототипы, такие как Array, Date, Function и прочие, также хранят свои методы в прототипах.
// Например при создании массива внутренне используется конструктор массивов, поэтому прототипом массива становится Array.prototype,
// предоставляя ему свои методы. Это позволяет эффективно использовать память.

// Согласно спецификации, наверху иерархии встроенных прототипов находится Object.prototype, поэтому и говорят, что всё наследуется
// от объектов.
// ниже я проверю некоторые прототипы, для наглядности
// let arr = [1, 2, 3];

// console.log(arr.__proto__ === Array.prototype); // true
// console.log(arr.__proto__.__proto__ === Object.prototype); // true
// console.log(arr.__proto__.__proto__.__proto__); // null - на вершине иерархии, за ним ничего нет

// Некоторые методы в прототипах могут пересекаться, например toString() - у Object.pototype есть такой метод, но и у Array.prototype
// есть такой же метод, поэтому при преобразовании массива к строке будет использоваться метод именно массива, так как он ближе
// расположен в цепочке прототипов.
// console.log(String(arr)); // 1,2,3

// В браузерных инструментах, типа консоли разработчика можно посмотреть цепочку наследования, ингода для этого нужно воспользоваться
// console.dir()
// console.dir([1, 2, 3]); // Array(3) - и далее просто раскрывать цепочку через [[Prototype]]
// Любые другие встроенные объекты устроены аналогично.
// function f() {
//     //some code
// }
// console.dir(f); // ƒ f()

// Примитивы
// как я уже знаю, они не объекты, если я получаю доступ к их методам создаётся (под капотом) объект-обёртка со встроенным
// конструктором для каждого отдельно типа примитива (String, Number, Boolean), который предоставит методы и исчезнет. Методы
// этих объектов также находятся в прототипах, это описано в спецификации.
// console.log(String.prototype); // String {'', constructor: ƒ, anchor: ƒ, at: ƒ, big: ƒ, …} - и так далее.

// У null и undefined нет объектов-обёрток, нет прототипов.


// Изменение встроенных прототипов
// встроенные прототипы можно изменять, но это очень плохая идея, потому что прототипы глобальны, т.е. изменения коснуться
// всех объектов в коде - это очень легко и быстро приведёт к конфликтам в коде.
// Единственный случай, когда одобряется изменение встроенных прототипов - это создание полифилов.
// Полифил - -это термин, означающий эмуляцию метода, который существует в спецификации, но ещё не поддерживается текущим движком.
// Например:
// if (!String.prototype.repeat) { // если такого метода нет
//     // добавляю его в прототип
//     String.prototype.repeat = function (n) {
//         // повторить строку n раз

//         // на самом деле, код должен быть немного более сложным
//         // (полный алгоритм можно найти в спецификации)
//         // но даже неполлный полифил зачастую достаточно хорош для использования

//         return new Array(n + 1).join(this);
//     }
// }

// console.log('sosi-'.repeat(3)); // sosi-sosi-sosi-


// Заимствование у прототипов
// В главе декораторы и переадресация я заимствовал методы у объектов и применял их в других объектах.
// Также можно позаимствовать и у встроенных прототипов (это частая практика). Например я могу создать псевдомассив и скопировать
// в него некоторые методы массива

// let obj = {
//     0: 'Hello',
//     1: 'World',
//     length: 2,
// };

// console.log(obj.join(',')); // obj.join is not a function - не работает

// obj.join = Array.prototype.join;

// console.log(obj.join(', ')); // Hello, World - всё работает (охуенно)

// Это работает потому, что для алгоритма встроенного метода join важны только корректность индексов и свойсвто length, он не
// проверяет, является ли объект массивом. И многие встроенные методы работаеют также.

// Альтернативная возможность - я могу унаследовать все методы от Array, и они станут доступны в obj. НО это будет недоступно,
// если obj уже наследует от другого объекта - важно это помнить!

// let obj = {
//     0: 'Hello',
//     1: 'World',
//     length: 2,
//     __proto__: Array.prototype,
// };
// console.log(obj.join(', ')); // Hello, World


// Задачи после раздела
// Добавить функциям метод 'f.defer(ms)'
// Function.prototype.defer = function (ms) {
//     setTimeout(f, ms);
// }

// function f() {
//     console.log('Hello!')
// }
// f.defer(2e3); // вывела Hello! через 2 секунды

// Добавить функциям декорирующий метод defer(ms)
// Function.prototype.defer = function (ms) {
//     let f = this;
//     return function (...args) {
//         setTimeout(() => f.apply(this, args), ms)
//     }
// };

// function f(a, b) {
//     console.log(a + b);
// }

// f.defer(1e3)(1, 2); // выведет 3 через 1 секунду


// Методы прототипов, объекты без свойства __proto__
// В начале этого раздела, я узнал, что свойство __proto__ считается устаревшим, и должно поддерживаться только браузерами.

// А вот современные методы, их нужно использовать вместо __proto__:

// Object.create(proto, [descriptors]) - создаёт пустой объект со свойством [[Prototype]], указанным как proto и необязательными
// дескрипторами свойств descriptors.

// Object.getPrototypeOf(obj) - возвращает свойство [[Prototype]] объекта obj.

// Object.setPrototypeOf(obj, proto) - устанавливает свойство [[Prototype]] объекта obj как proto.

// пробую на практике
// let animal = {
//     eats: true,
// };

// let rabbit = Object.create(animal); //  создаю новый объект с прототипом animal

// console.log(rabbit.eats); // true
// console.log(Object.getPrototypeOf(rabbit) === animal); // true - получаю прототип объекта rabbit и проверяю animal ли это

// Object.setPrototypeOf(rabbit, {}); // заменяю прототип объекта rabbit на {}

// У Object.create есть необязательный второй аргумент - дескриптор свойств, с его помощью я могу добавить дополнительное свойство
// объекту, вот так:
// let animal = {
//     eats: true,
// } ;

// let rabbit = Object.create(animal, {
//     jumps: {
//         value: true,
//         enumerable: true,
//     },
// });

// console.log(rabbit.jumps); // true

// for (let i in rabbit) {
//     console.log(i); // jumps eats
// }

// Также я могу использовать Object.create для продвинутого клонирования объекта, более мощного, чем for..in:
// клон obj с тем же прототипом (с поверхностным копированием свойств):
// let obj = {
//     value1: 1,
//     value2: 2,
// };

// Object.defineProperty(obj, 'value3', {
//     value: 3,
//     writable: true,
//     enumerable: true,
//     configurable: true,
// });

// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// такой вызов создаёт точную копию объекта obj со всеми свойствами (перечисляемыми и неперечисляемыми), геттерами,
// сеттерами для свойств - и всё это с правильным свойством [[Prototype]].


// console.log(clone); // {value1: 1, value2: 2, value3: 3} ...
// console.dir(clone); // Object - если конкретно, то прототипом является именно obj

// Не следует менять [[Prototype]] существующих объектов, если важна скорость. Обычно устанавливают проттотип при создании объекта,
// и этот механизм хорошо оптимизирован движком, но вот изменение "на лету" - это сильно медленная операция, которая "ломает"
// оптимизационные процессы.


// "Простейший" объект - здесь описано, как можно при использовании объектов, как ассоциативных массивов случайно получить доступ
// к __proto__, и вместо значения из пары "ключ-значение" получить не __proto__ как значение, а [Object Object] - собственно
// сам прототип объекта. Это решается созданием объекта через Object.create(null), но тогда у такого объекта не будет никаких
// встроенных методов, например toString, и их придётся задавать вручную, а ещё можно использовать Map.


// Задачи после раздела

// Добавьте toString в словарь
// let dictionary = Object.create(null);

// Object.defineProperty(dictionary, 'toString', {
//     configurable: true,
//     writable: true,
//     enumerable: false,
//     value () {
//         return Object.keys(this).join(', ');
//     },
// });

// dictionary.apple = 'Apple';
// dictionary.__proto__ = 'test';

// for (let key in dictionary) {
//     console.log(key); // тут всё ок
// }

// console.log(String(dictionary));


// Разница между вызовами
// function Rabbit(name) {
//     this.name = name;
//     this.type = 'animal';
// }

// Rabbit.prototype.sayHi = function() {
//     console.log(`Hello, I\'m ${this.name}.`);
// };

// let rabbitTod = new Rabbit('Tod');

// все эти вызовы делают одно и то же?
// rabbitTod.sayHi(); // вызывает метод прямо из объекта rabbitTod, this == rabbitTod
// Rabbit.prototype.sayHi(); // this == Rabbit.prototype, поэтому функция вернёт undefined. И внизу везде тоже.
// Object.getPrototypeOf(rabbitTod).sayHi();
// rabbitTod.__proto__.sayHi();


// Классы
// Класс: базовый синтаксис

// В ООП класс - это раширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства)
// и реализацию поведения (методы).
// Я уже умею создавать объекты при помощи конструктора new, но в JS есть конструкция 'class', которая предоставляет новые
// возможности, полезные для ООП.

// Синтаксис class (базовый)
// class MyClass {
//     // методы класса
//     constructor() {... }
//     method1() {... }
//     method2() {... }
//     method3() {... }
//     ...
// }
// Затем используется вызов new ClassName для создания нового объекта со всеми перечисленными методами. При этом автоматически
// вызывается метод constructor(), в нём я могу инициализировать объект, например:

// class User {
//     constructor(name) {
//         this.name = name;
//     }

//     sayHi() {
//         console.log(`Hi, my name is ${this.name}`);
//     }
// }

// использование
// let user = new User('Иван'); // здесь сначала создаётся новый объект, потом constructor() запускаетя с данным аргументом
// и сохраняет его в this.name

// user.sayHi(); // Hi, my name is Иван

// Итак, класс, это не полностью языковая сущность. В JS класс - это разновидность функции. Посмотрю ещё раз:
// class User {
//     constructor(name) {this.name = name;}

//     sayAny() {console.log(this.name);}
// }
// console.log(typeof User); // function

// Вот, что на самом деле делает конструкция class User {}:
// 1. Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor,
// он будет пустой, если такого метода нет.
// 2. Сохраняет все методы (типа sayHi()) в User.prototype.

// При вызове метода объекта new User  методы будут взяты из прототипа, как это описано в главе F.prototype. Таким образом
// объекты User имеют доступ к методам класса. Можно это проверить:
// class User {
//     constructor(name) { this.name = name; }

//     sayAny() { console.log(this.name); }
// }
// // класс - это функция
// console.log(typeof User); // function

// // или если точнее - это метод constructor
// console.log(User === User.prototype.constructor); // true

// // методы находятся в User.prototype:
// console.log(User.prototype.sayAny); // ƒ sayAny() { console.log(this.name); }

// // в прототипе ровно два метода
// console.log(User.prototype); // {constructor: ƒ, sayAny: ƒ}


// Не просто синтаксический сахар
// иногда говорят, что классы - это просто синтаксический сахар, потому что можно сделать всё тоже самое без них, вот так:
// function User(name) { this.name = name; }

// добавляю метод в прототип
// User.prototype.sayAny = function () { console.log(this.name) };

// смотрю, что получилось:
// let user = new User('Ivan');
// user.sayAny(); // Ivan

// И да, результат этого кода очень похож, но есть отличия:
// 1. Во-первых, функция, созданная при помощи класса помечена специальным внутренним свойством [[isClassConstructor]]: true - 
// поэтому это не тоже самое, что создавать её вручную.
// В отличие от обычных функций, констуктор класса не может быть вызван без new. Кроме того, строковое представление констуктора
// класса в большинстве движков начинается с class.
// 2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable: false для всех методов в prototype.
// И это хорошо, потому что в большинстве случаев мне не нужно перебирать все методы объекта, когда я прохожу по нему for..in.
// 3. Классы всегда используют use strict, то есть код в них всегда находится в строгом режиме.

// Class Expression
// Классы, как и функции можно определять внутри другого выражения, передавать, присваивать, возвращать и т.д.
// Пример по аналоги с FE:
// let User = class {
//     sayHi() {
//         console.log('Hello');
//     }
// }

// Аналогично с NFE Class Expression может иметь имя, но оно будет видно только внутри класса:
// let User = class MyClass {
//     sayHi() {
//         console.log(MyClass); // имя MyClass видно только внутри класса
//     }
// }

// new User().sayHi(); // выводит определение MyClass (видно даже комментарий выше, потому что он внутри класса)

// console.log(MyClass); // MyClass is not defined - не видно за пределами класса

// Я могу динамически создавать классы по запросу
// function makeClass (phrase) {
//     // объявляю класс и возвращаю его
//     return class {
//         sayHi() {
//             console.log(phrase);
//         };
//     };
// }

// создаю новый класс
// let User = makeClass('Hello phrase');

// new User().sayHi(); // Hello phrase


// Геттеры/сеттеры, другие сокращения
// Как и в литеральных объектах в классах можно объявлять вычисляемые свойства типа геттеров/сеттеров и т.д., например:
// class User {
//     constructor(name) {
//         // вызывает сеттер
//         this.name = name;
//     }

//     get name() {
//         return this._name;
//     }

//     set name(value) {
//         if (value.length < 4) {
//             console.log('Name is too short');
//             return;
//         }

//         this._name = value;
//     }
// }

// let user = new User('Thomas');
// console.log(user.name); // Thomas

// let user2 = new User('Tom'); // Name is too short

// console.log(user2.name); // undefined
// console.log(user2); // User... -  но сам объект создался (интересно)

// При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
// Object.defineProperties(User.prototype, {
//     name: {
//         get() {
//             return this._name;
//         },
//         set(name) {
//             //...
//         }
//     }
// });

// Пример с вычисляемым свойством в скобках [...]
// class User {
//     ['say' + 'Hi'] () {
//         console.log('Hi!');
//     }
// }

// new User().sayHi(); // Hi!


// Свойства классов
// старым браузерам может понадобиться полифил, потому что возможность добавлена не так давно.
// Ранее у класса User были только методы, теперь добавлю им свойство:
// class User {
//     name = 'Anonim';

//     sayHi() {
//         console.log(`Hello, ${this.name}`);
//     }
// }

// new User().sayHi(); // Hello, Anonim

// Получается, что свойство name не устанавливается в прототип (User.prototype). Вместо этого оно создаётся оператором new
// перед запуском конструктора, а это именно свойство объекта.


// Задачи после раздела

// Перепишите класс
// class Clock {
//     constructor({ template }) {
//         this.template = template;
//     }

//     render() {
//         let date = new Date();

//         let hours = date.getHours();
//         if (hours < 10) hours = '0' + hours;

//         let mins = date.getMinutes();
//         if (mins < 10) mins = '0' + mins;

//         let secs = date.getSeconds();
//         if (secs < 10) secs = '0' + secs;

//         let output = this.template
//             .replace('h', hours)
//             .replace('m', mins)
//             .replace('s', secs);

//         console.clear(); // я добавил, чтобы не плодить сотни строк в консоли
//         console.log(output);
//     }

//     stop() {
//         clearInterval(this.timer);
//         console.log('Timer is stopped.')
//     };

//     start() {
//         this.render();
//         this.timer = setInterval(() => this.render(), 1000);
//     };

// }

// let clock = new Clock({ template: 'h:m:s' });
// clock.start();

// setTimeout(() => clock.stop(), 10e3);


// Наследование классов
// наследование классов - это способ расширения одного класса другим классом. Я могу добавить новый функционал уже существующему.

// Ключевое слово "extends"

// допустим, у меня есть класс животного
// class Animal {
//     constructor(name) {
//         this.speed = 0;
//         this.name = name;
//     }
//     run(speed) {
//         this.speed = speed;
//         console.log(`${this.name} runs with speed ${this.speed} km/h.`);
//     }
//     stop() {
//         this.speed = 0;
//         console.log(`${this.name} stands still.`);
//     }
// }

// let animal = new Animal('My pet');

// и я бы хотел создать ещё один класс Rabbit. Он должен быть основан на Animal. Синтаксис для расширения следующий:
// class Child extends Parent.
// Пробую:
// class Rabbit extends Animal {
//     hide() {
//         console.log(`${this.name} hiding from anyone.`);
//     }
// }

// let rabbit = new Rabbit('Roger');
// rabbit.run(30); // Roger runs with speed 30 km/h.
// rabbit.stop(); // Roger stands still.
// rabbit.hide(); // Roger hiding from anyone.

// Ключевое свово extends работает по механике прототипов, оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype.
// Таким образом, если метода не оказалось в Rabbit.prototype, он возьмётся из Animal.prototype.

// После extends разрешены любые выражения, например можно вызвать функцию, которая генерирует родительский класс.
// function f(phrase) {
//     return class {
//         sayHi() {
//             console.log(phrase);
//         }
//     }
// }

// class User extends f('Zdravstvuyte') {}

// new User().sayHi(); // Zdravstvuyte

// здесь класс User наследует от результата вызова f('Zdravstvuyte'). Это может быть полезно для продвинутых приёмов проектирования,
// где я могу использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.


// Переопределение методов
// по умолчанию, все методы, не указанные в классе Rabbit берутся из родителя как есть. Но если я укажу собственный метод в классе
// Rabbit, то он будет использован вместо родительского. Обычно не нужно полностью заменять родительский метод, скорее создать новый
// на его основе, возможно расширить или частично изменить функционал. У классов для этого есть ключевое слово 'super':
// super.method(...) - вызывает родительский метод;
// super(...) - для вызова родительского конструктора (работает только внутри моего конструктора).

// пусть кролик автоматически прячется при остановке

// class Animal {
//     constructor(name) {
//         this.speed = 0;
//         this.name = name;
//     }
//     run(speed) {
//         this.speed = speed;
//         console.log(`${this.name} runs with speed ${this.speed} km/h.`);
//     }
//     stop() {
//         this.speed = 0;
//         console.log(`${this.name} stands still.`);
//     }
// }

// class Rabbit extends Animal {
//     hide() {
//         console.log(`${this.name} is hiding from anyone.`);
//     }
//     // и теперь внимание!:
//     stop() {
//         super.stop(); // вызываю родительский метод
//         this.hide(); // и затем hide
//     }
// }

// let rabbit = new Rabbit('Some rabbit');
// rabbit.run(50); // Some rabbit runs with speed 50 km/h.
// rabbit.stop(); // Some rabbit stands still. - и затем - Some rabbit is hiding from anyone.

// теперь у класса Rabbit есть свой собственный метод stop, который вызывает родительский super.stop() в процессе выполнения.

// У стрелочных функций нет super, он берётся из внешней функции:
// class Rabbit extends Animal {
//     stop() {
//         setTimeout(() => super.stop(), 1e3);
//     }
// }
// new Rabbit('Rabbit').stop(); // Rabbit stands still. - выведено через 1 секунду
// в этом примере значение super стрелочной функции то же, что и в stop(), поэтому всё работает.

// А если в этом же примере указать обычную функцию, то будет ошибка:
// class Rabbit extends Animal {
//     stop() {
//         setTimeout(function () { super.stop() }, 1e3); // 'super' keyword unexpected here
//     }
// }

// Переопределение конструктора
// согласно спецификации - если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой пустой
// конструктор. То есть дочерний класс будет просто вызывать конструктор родительского класса, пока я не создам свой конструктор
// для дочернего класса.

// class Animal {
//     constructor(name) {
//         this.name = name;
//         this.speed = 0;
//     }
//     run(speed) {
//         this.speed = speed;
//         console.log(`${this.name} runs with speed ${this.speed} km/h.`);
//     }
//     stop() {
//         this.speed = 0;
//         console.log(`${this.name} stands still.`);
//     }
// }

// Что сразу ВАЖНО отметить: конструкторы в наследуемых классах должны обязательно вызывать super(...), и делать это
// перед использованием this!
// Потому что в JS есть отличие между функцией наследующего класса и всеми остальными. В наследующем классе соответствующая
// функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]: 'derived'.
// Если коротко, то когда я создаю собственный конструктор, я должен вызвать super(...) до использования this, в противном случае
// объект для this не будет создан и я получу ошибку. Поэтому ниже делаю сразу правильно:

// class Rabbit extends Animal {
//     constructor(name, earLength) {
//         super(name);
//         this.earLength = earLength;
//     }
// }

// let rabbit = new Rabbit('Roger', 15);
// console.log(rabbit.name); // Roger
// rabbit.run(20); // Roger runs with speed 20 km/h.
// console.log(rabbit.earLength); // 15


// Переопределение полей класса
// я могу переопределять не только методы, но и поля класса
// class Animal {
//     name = 'Animal';

//     constructor(){
//         console.log(this.name);
//     }
// }

// class Rabbit extends Animal {
//     name = 'Rabbit';
// }

// new Animal(); // Animal
// new Rabbit(); // Animal - так происходит, потому что в Rabbit нет собственного конструктора, и используется конструктор Animal

// Другими словами - родительский конструктор всегда использует своё собственное значение поля, а не определённое.

// Теперь тот же код, но вместо this.name  я буду вызывать метод this.showName():
// class Animal {
//     showName() {
//         // вместо this.name = 'Animal'
//         console.log('Animal');
//     }

//     constructor() {
//         // вместо console.log(this.name)
//         this.showName();
//     }
// }

// class Rabbit extends Animal {
//     showName() {
//         console.log('Rabbit');
//     }
// }

// new Animal; // Animal
// new Rabbit(); // Rabbit
// причина, по которой это работает - порядок инициализации полей. Это и есть особенность JS. Подробнее об этом в книге.


// Задачи после раздела

// Ошибка создания экземпляра класса
// (пишу уже исправленный код)

// class Animal {
//     constructor(name) {
//         this.name = name;
//     }
// }

// class Rabbit extends Animal {
//     constructor(name) {
//         super(name);
//         this.created = Date.now();
//     }
// }

// let rabbit = new Rabbit('Roger');
// console.log(rabbit.name); // Roger
// console.log(rabbit.created); // 1685786247759 - вернул таймстамп - работает

// причина была в том, что у Rabbit усть свой конструктор, но он использует свойство из конструктора Animal, и нужно было
// использовать super(это свойство) перед использованием this самого Rabbit.

// Улучшеные часы
// class Clock {
//     constructor({ template }) {
//         this.template = template;
//     }
//     render() {
//         let date = new Date();

//         let hours = date.getHours();
//         if (hours < 10) hours = '0' + hours;

//         let mins = date.getMinutes();
//         if (mins < 10) mins = '0' + mins;

//         let secs = date.getSeconds();
//         if (secs < 10) secs = '0' + secs;

//         let output = this.template
//             .replace('h', hours)
//             .replace('m', mins)
//             .replace('s', secs);

//         console.clear();
//         console.log(output);

//         return output;
//     }

//     start() {
//         this.render();
//         this.timer = setInterval(() => this.render(), 1e3);
//     }

//     stop() {
//         clearInterval(this.timer);
//         console.log(`Timer was stopped with ${this.render()}`);
//     }
// }

// class ExtendClock extends Clock {
//     constructor(options) {
//         super(options);
//         let { precision = 2e3 } = options;
//         this.precision = precision;
//     }

//     start() {
//         this.render();
//         this.timer = setInterval(() => this.render(), this.precision);
//     }
// }

// let extClock = new ExtendClock({ template: 'h:m:s' });
// extClock.start();
// extClock.stop();


// Статические свойства и методы классов
// я также могу присвоить  метод самому классу - такой метод будет называться статическим. В объявлении класса они добавляются
// при помощи ключевого слова static, например:
// class User {
//     static staticMethod() {
//         console.log(this === User);
//     }
// }
// User.staticMethod(); // true

// Это фактически тоже самое, что и присвоить метод как свойство функции
// class User { }

// User.staticMethod = function () {
//     console.log(this === User)
// }

// User.staticMethod(); // true

// Значением this при вызове User.staticMethod является сам конструктор класса User (правило "объект до точки").
// console.log(User.prototype); // constructor: class User

// Обычно статические методы используют для реализации функций, принадлежащих классу целиком, вообще. При этом, не относящимися
// к каким-то отдельным объектам. Например: есть объекты статей, и нужна функция для их сравнения. Естественное решение - 
// сделать для этого статический метод Article.compare:

// class Article {
//     constructor(title, date) {
//         this.title = title;
//         this.date = date;
//     }

//     static compare(articleA, articleB) {
//         return articleA.date - articleB.date;
//     }
// }

// использование
// let articles = [
//     new Article('HTML', new Date(2021, 1, 1)),
//     new Article('CSS', new Date(2024, 2, 4)),
//     new Article('JS', new Date(2023, 3, 15))
// ];

// for (let one of articles) { // до
//     console.log(one.title); // HTML, CSS, JS
// }
// console.log('--------------------------')

// articles.sort(Article.compare);

// for (let one of articles) { // после
//     console.log(one.title); // HTML, JS, CSS
// }
// В этом примере метод Article.compare стоит "над" статьями, как средство их сравнения. Это не метод отдельной статьи,
// а всего класса целиком.

// Другой пример: так называемый "фабричный" метод. Допустим, мне нужно несколько способов создания статьи:
// 1. Создание через заданные параметры title, date. 2. Создание пустой статьи с сегодняшней датой. 3. Как-то ещё.
// Первый способ может быть реализован через конструктор, а для второго подойдёт статический метод класса, например:
// class Article {
//     constructor(title, date) {
//         this.title = title;
//         this.date = date;
//     }
//     // вот тот самый статический метод
//     static createToday() {
//         // держу в уме, что this = Article
//         return new this('Сегодняшний дайджест', new Date());
//     }
// }

// let article = Article.createToday();
// console.log(article.title); // Сегодняшний дайджест

// Теперь каждый раз, когда мне нужно создать сегодняшний дайджест, мне нужно вызывать Article.createToday(). Ещё раз - 
// это не метод отдельной статьи, это метод всего класса в целом.

// Статические методы также используются в классах, относящихся к базам данных, для поиска/хранения/удаления вхождений
// в базу данных, например:

// предположим, что Article - это специальный класс для управления статьями
// тогда статический метод для удаления статьи по id:
// Article.remove({ id: 12345 });

// Статические методы недоступны для отдельных объектов!
// Статические методы могут вызываться для классов, но не для отдельных объектов. Например, такой код не будет работать:
// article.createToday(); // ошибка - article.createToday is not a function



// Статические свойства (новая возможность)
// они выглядят, как свойства класса, но перед ними также указывается ключевое слово static:
// class Article {
//     static publisher = 'Ivan Linnik';
// }
// console.log(Article.publisher); // Ivan Linnik

// это тоже самое, что и прямое присваивание: Article.publisher = 'Ivan Linnik'


// Наследование статических свойств и методов
// статические свойства и методы наследуются. Пример ниже:
// class Animal {

//     constructor(name, speed) {
//         this.name = name;
//         this.speed = speed;
//     }

//     run(speed = 0) {
//         this.speed += speed;
//         console.log(`${this.name} runs with speed ${this.speed} km/h.`);
//     }

//     static compare(animalA, animalB) {
//         return animalA.speed - animalB.speed;
//     }
// }

// // наследует от Animal
// class Rabbit extends Animal {
//     hide() {
//         console.log(`${this.name} is hiding.`);
//     }
// }

// let rabbits = [
//     new Rabbit('1 Rabbit', 25),
//     new Rabbit('2 Rabbit', 20),
// ];

// for (let rab of rabbits) {
//     console.log(rab.name); // 1 Rabbit  2 Rabbit
// }

// rabbits.sort(Rabbit.compare); // здесь я вызвал Rabbit.compare, но при этом был унаследован Animal.compare

// for (let rab of rabbits) {
//     console.log(rab.name); // 2 Rabbit  1 Rabbit
// }

// rabbits[0].run(); // 2 Rabbit runs with speed 20 km/h.

// Всё это работает снова с использованием прототипов. Extends даёт Rabbit ссылку [[Proptotype]] на Animal.

// Так что Rabbit extends Animal создаёт две ссылки на прототип:
// 1. Функция Rabbit прототипно наследует от функции Animal.
// 2. Rabbit.prototype прототипно наследует от Animal.prototype.

// В результате - наследование работает как для обычных, так и для прототипных методов.


// Задачи после раздела

// Класс расширяет объект?
// class Rabbit extends Object {
//     constructor(name) {
//         super();
//         this.name = name;
//     }
// }

// let rabbit = new Rabbit('Koll');
// console.log(rabbit.name); // Kroll
// console.log(rabbit.hasOwnProperty('name')); // true


// Приватные и защищённые свойства
// один из важнейших методов ООП - разделение внутреннего и внешнего интерфейсов.

// Внутренние и внешние интерфейсы
// в ООП все свойства и методы разделены на 2 группы:
// Внутренний интерфейс - методы и свойства доступные из других методов класса, но недоступные снаружи класса.
// Внешний интерфейс - методы и свойства доступные снаружи класса.

// Теперь к делу: в JS есть два типа полей:
// Публичные - доступны отовсюду. Они составляют внешний интерфейс. До этого момента я использовал только такие.
// Приватные - доступны только внутри класса. Они для внутреннего интерфейса.

// Интересно, что в JS защищённые поля не реализованы на уровне языка. Но они очень полезны, поэтому их эмулируют.

// Ниже я реализую немного упрощённую модель кофеварки.
// Защищённое свойство waterAmount

// создаю простой класс для описания кофеварки
// class CoffeeMachine {
//     waterAmount = 0; // количесвто воды внутри

//     constructor(power) {
//         this.power = power;
//         console.log(`Создана кофеварка мощностью ${power} Вт`);
//     }
// }

// создаю новую кофеварку, мощностью 100 Вт
// let coffeeMacine = new CoffeeMachine(100);
// // добавляю воды
// coffeeMacine.waterAmount = 200;

// И сейчас все свойства и методы публичные. Я изменю свойство количества воды, чтобы никто не мог устанавливать его ниже 0.
// Защищённые свойства обычно начинаются с префикса "_". И это не сиснтаксис языка, это соглашение программистов - такие свойства 
// и методы не должны быть доступны извне.

// class CoffeeMachine {
//     _waterAmount = 0;

//     set waterAmount(value) {
//         if (value < 0) throw new Error('Отрицательное количество воды');
//         this._waterAmount = value;
//         console.log(`Объём бака с водой ${this.waterAmount} мл`);
//     }

//     get waterAmount() {
//         return this._waterAmount;
//     }

//     constructor(power) {
//         this.power = power;
//         console.log(`Создана кофеварка мощностью ${power} Вт`);
//     }
// }

// let coffeeMacine = new CoffeeMAchine(200);
// coffeeMacine.waterAmount = -10; // Uncaught Error: Отрицательное количество воды
// coffeeMacine.waterAmount = 300; // Объём бака с водой 300 мл
// console.log(coffeeMacine.waterAmount); // 300

// Свойство только для чтения 'power'
// Иногда нужно, чтобы свойство устанавливалось при создании, и больше никогда не менялось. Для этого нужно установить только
// геттер, без сеттера.
// class CoffeeMachine {
//     constructor(power) {
//         this._power = power;
//     }

//     get power() {
//         return this._power;
//     }
// }

// let coffeeMacine = new CoffeeMachine(200);
// console.log(coffeeMacine.power); // 200
// coffeeMacine.power = 100; // Cannot set property power of #<CoffeeMachine> which has only a getter

// В этих примерах я использовал синтаксис геттеров и сеттеров. Но в большинстве случаев, использование функций get.../set...
// предпочтительнее:
// class CoffeeMachine {
//     _waterAmount = 0;

//     setWaterAmount(value) {
//         if (value < 0) throw new Error('Отрицательное количество воды');
//         this._waterAmount = value;
//     }

//     getWaterAmount() {
//         return this._waterAmount;
//     }

//     constructor(power) {
//         this._power = power;
//     }

//     getPower() {
//         return this._power;
//     }
// }

// let coffeeMacine = new CoffeeMachine(100);
// coffeeMacine.setWaterAmount(200); 
// console.log(coffeeMacine); // CoffeeMachine {_waterAmount: 200, _power: 100}

// Это выглядит немного длиннее, зато функции более гибкие. Они могу принимать больше аргументов, даже если они мне сейчас не
// нужны. Итак, на будущее - если мне нужно что-то отрефакторить - функции, это наиболее бесопасный выбор. Но, с другой стороны,
// синтаксис геттеров/сеттеров короче. Выбор всегда за мной.

// Защищённые поля наследуются! ( в отличие от приватных)

// Приватное свойство
// это новая возможность - понадобится полифил. Его суть:
// Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.

// class CoffeeMachine {
//     #waterLimit = 400;

//     #checkWater(value) {
//         if (value < 0) throw new Error('Нет такого количества воды');
//         if (value > this.#waterLimit) throw new Error(`Нельзя залить больше объема бака. Его объём: ${this.#waterLimit}`);
//     }
// }

// let newCoffeeMac = new CoffeeMachine();

// снаружи нет доступа к приватным методам
// newCoffeeMac.#checkWater(); // Private field '#checkWater' must be declared in an enclosing class
// newCoffeeMac.#waterLimit = 500; // Private field '#waterLimit' must be declared in an enclosing class

// это означает, что поле приватное. Я не могу получить к нему доступ извне или из наследуемых классов.
// Приватные поля не конфликтуют с публичными. Например, у меня будет два поля #waterAmount и waterAmount

// class CoffeMachine {
//     #waterAmount = 0;

//     get waterAmount() {
//         return this.#waterAmount;
//     }

//     set waterAmount(value) {
//         if (value < 0) throw new Error ('Setter\'s rule: Can\'t be less than zero!');
//         this.#waterAmount = value;
//     }
// }

// let machine = new CoffeMachine();
// machine.waterAmount = -100;
// console.log(machine.#waterAmount); // Private field '#waterAmount' must be declared in an enclosing class

// В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

// Но если я унаследую от CoffeMachine, то не получу прямого доступа к #waterAmount. Я буду вынужден полагаться на геттер/сеттер
// waterAmount.

// class MegaMachine extends CoffeMachine {
//     method() {
//         console.log(this.#waterAmount); // Private field '#waterAmount' must be declared in an enclosing class
//     }
// }

// Получается, что во многих случаях такое ограничение слишком жёсткое. И если я уж расширяю класс, то вполне возможно захочу
// иметь доступ к внутренним свойствам и методам. Поэтому защищённые поля используются чаще, хоть и не поддерживаются синтаксисом
// языка.
// Важно помнить, что приватные поля особенные. Обычно я могу получить доступ к к полям объекта при помощи this[fieldName], но
// с приватными полями такое невозможно. Это ограничение синтаксиса нужно для обеспечения приватности.


// Расширение встроенных классов

// от встроенных классов Array и Map тоже можно наследовать.
// class PowerArray extends Array {
//     isEmpty() {
//         return this.length === 0
//     }
// }

// let arr = new PowerArray(1, 2, 3, 4, 5, 6, 7);
// console.log(arr.isEmpty()); // false
// console.log(arr.includes(7), arr.indexOf(7)); // true 6 - встроенные методы массива работают

// let filteredArr = arr.filter(item => item >= 4);
// console.log(filteredArr); // [4, 5, 6, 7] - тут тоже всё работает

// filteredArr.length = 0; // очищаю массив
// console.log(
//     filteredArr,
//     filteredArr.length,
//     filteredArr.isEmpty()
// ); // [] 0 true - всё работает, включая мой метод

// Интересный момент, что встроенные методы (includes(), filter(), indexOf() ит.д.) возвращают новые объекты унаследованного
// класса PowerArray. То есть, используется конструктор PowerArray, и я могу использовать все его методы.
// console.log(arr.constructor === PowerArray); // true

// Более того, я могу настроить это поведение при помощи специального статического геттера, и с его помощью можно вернуть,
// конструктор, который JS  будет использовать в filter, map, includes и других методах для создания новых объектов.
// Если бы я хотел, чтобы эти методы возвращали обычные массивы, то мог бы прописать вот так:
// class PowerArray extends Array {
//     isEmpty() {
//         return this.length === 0;
//     }

//     // теперь встроенные методы массива будут использовать этот метод как конструктор
//     static get [Symbol.species]() {
//         return Array;
//     }
// }

// let arr = new PowerArray(1, 2, 3, 4);
// console.log(arr.isEmpty()); //false

// let filteredArr = arr.filter(item => item >= 2);
// console.log(filteredArr); // [2, 3, 4]

// теперь проверю, работает ли мой метод в новом экземпляре класса
// console.log(filteredArr.isEmpty()); // Uncaught TypeError: filteredArr.isEmpty is not a function - нет!

// а всё потому, что
// console.log(filteredArr.constructor); // Array() - теперь объект массива является прототипом, а не PowerArray, в котором был
// мой пользовательский метод. Проще говоря - теперь filter() возвращает Array, а не PowerArray, то есть расширенная
// функциональность не будет передаваться далее.
// Этот статический геттер актуален и для других объектов, типа Map, Set. Они также используют [Stymbol.species].


// ВСТРОЕННЫЕ КЛАССЫ НЕ НАСЛЕДУЮТ СТАТИЧЕСКИЕ МЕТОДЫ
// например Array и Date наследуют от Object, так что в их экземплярах доступны методы из Object.prototype. Но Array.[[Prototype]]
// не ссылается на Object, поэтому нет методов типа Array.keys() или Date.keys().

// В этом и есть главное отличие наследования встроенных объектов от того, что я получаю с использованием extends.


// Проверка класса: "instanceof"
// данный оператор позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.
// Пишут, что такие проверки могут потребоваться во многих случаях. Поэтому изучу.

// Ниже, я напишу код полиморфной функции, которая интерпретирует аргументы по-разному в зависимости от их типа.
// Синтаксис instanceof: object instanceof Class - вернёт true, если объект принадлежит классу или наследующему от него.

// class Rabbit {}
// let rabbit = new Rabbit();

// console.log(rabbit instanceof Rabbit); // true

// Также это работает с функциями-конструкторами
// function Rabbit() { }
// let rabbit = new Rabbit();

// console.log(rabbit instanceof Rabbit); // true

// И со встроенными классам
// let arr = [1, 2, 3];
// console.log(arr instanceof Array, arr instanceof Object, arr instanceof Number); // true true false
// обращаю внимание, что arr принадлежит классу Object, потому Array наследует от Object

// Обычно оператор instanceof просматривает для проверки цепочку прототипов, но это поведение можно изменить при помощи 
// статического метода Symbol.hasInstance.
// Это работает так: 
// 1. Если имеется статический метод hasInstance, то вызвать его class[Symbol.haInstance](obj). Он должен вернуть
// либо true, либо false - и всё. Это как раз и даёт возможность ручной настройки.

// здесь проверка будет полагать, что всё со свойством canEat является животным Animal
// class Animal {
//     static [Symbol.hasInstance] (obj) {
//         if (obj.canEat) return true;
//     }
// }

// let obj = {canEat: true};

// console.log(obj instanceof Animal); // true

// 2. Большая часть классов не имеет метода [Symbol.hasInstance] (obj), поэтому используется стандартная логика - проверяется
// равен ли Class.prototype одному из прототипов в прототипной цепочке obj.
// И если после зоздания объекта изменить ему прототип, то проверка вернёт false.


// Бонус: Object.prototype.toString возвращает тип
// Я уже знаю, что обычные объекты преобразуются к строке как [object Object]
// let obj = {};
// console.log(String(obj)); // [object Object] - в книге использовался alert (он неявно приводит к строке, а console.log - нет)
// console.log(obj.toString()); // [object Object]

// Но у toString есть более мощные возможности. Я могу использовать его как расширенную версию typeof или как альтернативу для
// instanceof.
// Согласно спецификации, метод toString может быть позаимствован у объекта и вызван в контексте любого значения. Результат будет
// зависеть от типа этого значения.

// скопирую метод toString в переменную для удобства
// let objToString = Object.prototype.toString;

// let arr = [];

// console.log(objToString.call(arr)); // [object Array]
// выше я использовал call, чтобы выполнить toString  в контексте объекта arr.

// больше примеров
// console.log(objToString.call(null)); // [object Null]
// console.log(objToString.call('hey')); // [object String]
// console.log(objToString.call(undefined)); // [object Undefined] и так далее


// Symbol.toStringTag
// поведение метода объектов toString можно настраивать, используя это специальное свойство объекта, например:
// let user = {
//     [Symbol.toStringTag]: 'Linnik',
// }

// console.log(user.toString()); // [object Linnik]
// Такое свойство есть у большей части объектов, специфичных для определённых окружений. Вот несколько примеров для браузера:
// console.log(window[Symbol.toStringTag]); // Window
// console.log(XMLHttpRequest.prototype[Symbol.toStringTag]); // XMLHttpRequest

// console.log({}.toString.call(window)); // [object Window]
// console.log({}.toString.call(new XMLHttpRequest())); // [object XMLHttpRequest]

// Как видно - результат, это значение Symbol.toStringTag обёрнутое в [object].
// В итоге я получил typeof на стероидах, который не только работает спримитивными типами данных, но также и со встроенными
// объектами, и даже может быть настроен.
// Можно использовать {}.toString.call вместо instanseof для встроенных объектов, когда я хочу получить тип в виде строки,
// а не просто сделать проверку.

// Обобщю, какие я знаю проверки типов:
// 1. typeof - проверяет примитивы - возвращает строку
// 2. {}.toString - проверяет примитивы, встроенные объекты, объекты с Symbol.toStringTag - возвращает строку
// 3. instanceof - проверяет объекты - возвращает true/false.

// Очевидно, что {}.toString технически более продвинут, чем typeof. А оператор instanceof отлично подходит для проверки иерархии
// классов, когда я хочу делать проверки с учётом наследования.


// Задачи после раздела

// Странный instanceof - решается устно. Решением стало то, что instanceof при проверке учёл только прототип, который был
// переопределён для двух функций, он был одним для них обеих, поэтому true.


// Примеси
// Позволяют копировать методы в объект класса без наследования. Просто прочитал пару раз, сильно не ковырял по совету Майсона.


// Обработка ошибок
// Обработка ошибок "try...catch"
// Обычно скрипт в случае ошибки сразу падает, а сама ошибка выводится в консоль. Но конструкция try...catch позволяет делать
// что-то более осмысленное при возникновении ошибок.

// Синтаксис:
// try {
//     // код
// } catch (err) {
//     // обработка ошибки
// }

// Как это работает:
// 1. Сначала выполнится код внутри блока try. 
// 2. Если в нём нет ошибок, то блок catch игнорируется, выполнение доходит до конца try и далее.
// 3. Если есть ошибка, то происходит выход из try и переход в начало catch. Переменная err (можно использовать любое имя)
// содержит объект ошибки с подробной информацией о произошедшем.
// Таким образом, скрипт не падает, и я получаю возможность обработать ошибку внутри catch.

// Пример без ошибок
// try {
//     console.log('Try block has been started here');
//     console.log(Object.getPrototypeOf(window));
//     console.log('Try block has been ended here');
// } catch (err) {
//     console.log('Will be ignore because is not error here');
// }

// Пример с ошибками
// try {
//     console.log('Try block has been started here');  // выполнится
//     khuy;                                           // не сработает, потому что переменная не определена
//     console.log('Try block has been ended here');  // не выполнится
// } catch (err) {
//     console.log('An error was found'); // выполнится
// }

// Try..catch работает только для ошибок, возникающих во время выполнения кода.
// Чтобы конструкция сработала, код должен быть выполнимым - это должен быть корректный JS-код. Конструкция не сработает, если
// код синтаксически неверен.
// JS-движок сначала читает код, а потом исполняет его. Ошибки, которые возникают в момент чтения, называются ошибками парсинга.
// Их нельзя обработать изнутри этого кода, потому что движок не понимает код. Поэтому конструкция обрабатывает только ошибки,
// которые возникают в корректном коде. Такие ошибки называются "ошибками во время выполнения", а иногда "исключениями".

// Try...catch работает синхронно
// если запланированное выполнение находится внутри конструкции - то конструкция не сработает. Потому что, само запланированное выполнение уже будет находиться вне конструкции на момент выполнения.
// Чтобы сработал запланированный код с обработкой ошибок, нужно поместить try...catch вовнутрь запланированного кода. Примерно вот так:
// setTimeout(function () {
//     try {
//         noSuchVariable; // try...catch обрабатывает ошибку
//     } catch (err) {
//         console.log('Error has been catched');
//     }
// }, 2e3);


// Объект ошибки
// Когда возникает ошибка, JS генерирует объект, содержащий её детали и передаёт его как аргумент в блок catch.

// Для всех встроенных ошибок этот объект имеет два основных свойства:
// name - имя ошибки, например для неопределённой переменной это "ReferenceError",
// message - текстовое сообщение о деталях ошибки.

// В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых - 
// это stack - текущий стек вызова - это строка, содержащая информацию о последовательности вложенных вызовов, которые привели
// к ошибке. Используется в целях отладки. Например:
// try {
//     lalalalala;
// } catch (err) {
//     console.log(err.name); // ReferenceError
//     console.log(err.message); // lalalalala is not defined
//     console.log(err.stack); // ReferenceError: lalalalala is not defined at script.js:7998:5

//     // можно также просто вывести ошибку целиком
//     console.log(err); // ReferenceError: lalalalala is not defined at script.js:7998:5
// }


// Блок catch без переменной (возможность появилась недавно)
// суть в том, что если мне не нужны детали ошибки в catch, я могу просто её пропустить, не указав аргумент err.


// Использование try...catch
// Как я знаю, JS поддерживает метод JSON.parse(str) для чтения данных формата JSON, полученных по сети от сервера или другого
// источника. Я получаю их и вызываю JSON.pase(str), вот так:

// let json = '{"name": "John", "age": 30}'; // данные с сервера

// let user = JSON.parse(json); // преобразовал данные в JS-объект

// // теперь user, это объект со свойствами
// console.log(user); // {name: 'John', age: 30}


// Если код некорректен, JSON.parse генерирует ошибку, и скрипт падает. Использую try...catch

// let json = "{хуёвый JSON}";

// try {
//     let user = JSON.parse(json); // тут будет ошибка
//     console.log(user.name); // любой код - не сработает
// } catch (err) {
//     alert('An error was found in data. We\'re sorry. We\'ll try again.');
//     console.log(err.stack);
// }
// alert('Hello'); // далее код работает, ничего не упало
// И да, здесь я просто вывожу пользователю сообщение, но я могу попробовать выполнить например повторный запрос и т.д.


// Генерация собственных ошибок

// А что если json синтаксически корректен, но не содержит необходимого мне свойства name? Например:
// let json = '{"age": 30}';

// try {
//     let user = JSON.parse(json); // выпонится без ошибок
//     console.log(user.name); //undefined - нет свойства name
// } catch (err) {
//     alert('Нет имени'); // не выполнится, потому что технически всё в порядке
// }

// Для того, чтобы унифицировать работу с ошибками нужно использовать оператор throw - он генерирует ошибку.
// Его синтаксис: throw <объект ошибки>
// Технически в качестве объекта ошибки можно передать что угодно, даже примитив. Но лучше, чтобы это был объект, с name и
// message - это нужно для совместимости со встроенными ошибками.
// В JS есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError etc.
// Их можно использовать для создания объектов ошибки. Их синтаксис:
// let error = new Error(message);
// или let error = new SyntaxError(message);

// Для встроенных объектов ошибок (ТОЛЬКО ДЛЯ НИХ) свойство name - это в точности имя конструктора, а свойство message берётся
// из аргумента. Например:
// let error = new Error('Ебать, ошибка');
// console.log(error); // Error: Ебать, ошибка  at script.js:8062:13

// посмотрю, какую ошибку генерирует JSON.parse
// try {
//     JSON.parse("bad JSON");
// } catch (err) {
//     console.log(err.name); // SyntaxError
//     console.log(err.message); // Unexpected token 'b', "bad JSON" is not valid JSON
// }

// Итак, в моём случае отсутствие name это ошибка, поэтому сгенерирую её

// let json = '{"age": 30}';
// let user = {};
// try {
//     user = JSON.parse(json);

//     if (!user.name) {
//         throw new SyntaxError('Отсутствует имя'); // здесь опреатор throw генерирует ошибку
//     }

//     alert(user.name);

// } catch (err) { // объект сгенерированной ошибки передаётся в качестве аргумента

//     alert('JSON Error: ' + err.message); // JSON Error: Отсутствует имя
//     user.name = 'UnknownUser'; // сам добавил имя пользователя
// }

// console.log(user); // {age: 30, name: 'UnknownUser'} -  сработало, имя добавилось в блоке catch

// Проброс исключения
// Что если в блоке try возникнет другая непредсказуемая ошибка или какая-то ошибка, связанная с некорректными данными?
// Пример ниже

// let json = '{"name": "Ted"}'; // данные неполны

// try {
//     user = JSON.parse(json); // забыл написать let

//     // .. какой-то код
// } catch (err) {
//     console.log("JSON Error: " + err.message); // JSON Error: user is not defined - как видно, на самом деле не JSON ошибка
// }

// Моя проверка сейчас работает на некорректные данные в json. Но своей природе catch получает все ошибки из try.
// Получается, что catch получает неожиданную ошибку, но выводит тоже самое сообщение, что и для json. Это неправильно и затрудняет
// отладку кода. Но я могу выяснить, какую ошибку я получил, например при помощи свойства name.

// Есть простое правило:
// ! Блок catch должен обрабатывать только те ошибки, которые ему известны, остальные ошибки он должен пробрасывать.

// Техника проброса выглядит так:
// 1. Блок catch получает все ошибки.
// 2. В блоке catch (err) {...} я анализирую объект ошибки err.
// 3. Если я не знаю, как её обработать - делаю throw err.

// Ниже я использую проброс исключения, catch обрабатывает только SyntaxError.

// let json = '{"age": 30}'; // данные неполны

// try {
//     let user = JSON.parse(json);

//     if (!user.name) throw new Error('Нет имени, данные неполны');

//     blabla; // неожиданная ошибка

//     console.log(user.name);
// } catch (err) {
//     if (err.name == 'Error') {
//         console.log('JSON Error: ' + err.message); // JSON Error: Нет имени, данные неполны
//     } else {
//         throw err; // здесь "неожиданная" ошибка выпадает наружу. Она может быть поймана другой внешней конструкцией try..catch
//         // (если она есть)или убъёт скрипт.
//     }
// }

// Таким образом, конструкция обрабатывает только те ошибки, с которыми знает, как справляться, и пропускает остальные.
// Ниже я отловлю пропущенную ошубку второй конструкцией try..catch, типа вторым уровнем обработки.

// function readData() {
//     let json = '{"age": 30}';

//     try {
//         // ..
//         blabla(); // тут ошибка
//     } catch (err) {
//         //..
//         if (err.name != "SyntaxError") {
//             throw err; // проброс исключения (не знаю, как это обработать)
//         }
//     }
// }

// try {
//     readData();
// } catch (errOuter) {
//     console.log('Поймал! - ' + errOuter);
// }

// Здесь readData() знает только как обработать SyntaxError, тогда как внешний блок try...catch знает, как обработать всё.


// Try...catch...finally
// Конструкция try...catch может содержать ещё одну секцию - finally. Если секция есть, то она выполнится в любом случае:
// После try, если не было ошибок;
// После catch, если ошибки были.
// Вот расширенный синтаксис:
// try {
//     // пробую выполнить код
// } catch (err) {
//     // обрабатываю ошибки
// } finally {
//     // выполняю всегда
// }

// Пример из книги
// try {
//     alert('try');
//     if (confirm('Do you wanna to generate an error?')) BAD_CODE();
// } catch (err) {
//     alert('Catch');
// } finally {
//     alert('Finally');
// }

// Можно также использовать конструкцию без catch, если я хочу выбросить все ошибки.


// Пользовательские ошибки, расширение Error
// В процессе разработки часто нужно использовать собственные объекты ошибок. Будь то ошибка при работе с HTTP запросами
// или базой данных. Мои ошибки в идеале должны поддерживать стандартные свойства, типа name, message, stack. Но могут быть
// использованы и другие - как при работе с HTTP, объекты HttpError используют свойство statusCode (404, 403, 500).
// При создании объектов ошибки лучше применять наследование, потому что не знаешь, насколько разрастётся код, и что придётся
// отлавливать по мере роста кода.

// Расширение Error
// напишу функцию, которая будет читать данные из json и валидировать их.
// Для вывода ошибки я создам класс, который будет наследовать от Error. Ниже будет псевдокод Error, чтобы я видел, от чего
// наследовать.
// class Error {
//     constructor(message) {
//         this.message = message;
//         this.name = 'Error'; // (разные имена для разных встроенных классов ошибок)
//         this.stack = '<стек вызовов>'; // нестандартное свойство, но обычно поддерживается
//     }
// }

// class ValidationError extends Error {
//     constructor(message) {
//         super(message); // обязательный вызов родительского конструктора, потому что он устанавливает message
//         this.name = 'ValidationError'; // он также устанавливает имя, поэтому я его сбрасываю на правильное для этого класса
//     }
// }

// сначала тестовая функция
// function test() {
//     throw new ValidationError('Упс...');
// }

// try {
//     test();
// } catch (err) {
//     console.log(err.name);
//     console.log(err.message);
//     console.log(err.stack);
// }

// Теперь попробую его для функции, читающей из json
// несколько вариантов под разные ошибки
// let jsonNormal = '{"name": "John", "age": 30}';
// let jsonName = '{"age": 30}';
// let jsonSynt = '{"name": "John" "age": 30}';

// function readUser(json) {
//     let user = JSON.parse(json);

//     if (!user.name) {
//         throw new ValidationError('Нет поля name');
//     }
//     if (!user.age) {
//         throw new ValidationError('Нет поля age');
//     }

//     return user;
// }

// try {
//     console.log(readUser(jsonSynt));
// } catch (err) {
//     if (err instanceof ValidationError) {
//         console.log('Некорректные данные: ' + err.message);
//     } else if (err instanceof SyntaxError) {
//         console.log('JSON Ошибка синтаксиса: ' + err.message);
//     } else {
//         throw err; // если неизвестная ошибка - пробросить её из конструкции
//     }
// }
// конструкция работает - она обрататывает ошибки в зависимости от их типа (пока только 2), все остальные - выбрасывает наружу.


// Дальнейшее наследование
// Класс ValidationError является слишком общим. Сделаю более корректный класс для проверки отсутсвующих свойств. Он будет нести
// дополнительную информацию о свойстве, которое отсутствует. Далее по порядку:
// class MyError {
//     constructor(message) {
//         this.message = message;
//         this.name = 'MyError';
//     }
// }

// class ValidationError extends MyError {
//     constructor(message) {
//         super(message);
//         this.name = 'ValidationError';
//     }
// }

// class PropertyRequiredError extends ValidationError {
//     constructor(property) {
//         super('Нет свойства: ' + property); // вызываю родительский конструктор с аргументом в скобках
//         this.name = 'PropertyRequiredError'; // собственно имя объекта класса
//         this.property = property; // имя свойства будет передано при создании объекта (вызове конструктора класса)
//     }
// }

// // Применение
// let exampleJson = '{"age": 30}';

// function readUser(json) {
//     let user = JSON.parse(json);

//     if (!user.age) {
//         throw new PropertyRequiredError('age');
//     }
//     if (!user.name) {
//         throw new PropertyRequiredError('name');
//     }

//     return user;
// }

// try {
//     readUser(exampleJson);
// } catch (err) {
//     if (err instanceof ValidationError) {
//         console.log('Неверные данные: ' + err.message); // Неверные данные: Нет свойства: name
//         console.log(err.name); // PropertyRequiredError
//         console.log(err.property); // name - потому что в json только возраст, нет имени
//     } else if (err instanceof SyntaxError) {
//         console.log('Ошибка синтаксиса JSON: ' + err.message);
//         console.log('Имя ошибки: ' + err.name);
//     } else {
//         throw err; // проброс ошибки, если она неизвестна
//     }
// }

// Новый класс PropertyRequiredError легко использовать: нужно указать только имя свойства, а сообщение для пользователя
// message генерируется конструктором.
// В книге обращают внимание, что свойство this.name в конструкторе присвоено вручную. Это утомительно - постоянно писать руками.
// Можно создать мой собственный базовый класс ошибки, который будет присваивать имени ошибки имя конструктора (в объектах ошибок
// так можно делать, об этом написано ранее в книге). И затем наследовать все ошибки уже от него. Перепишу весь код заново:

// class MyBasicError {
//     constructor(message) {
//         this.message = message;
//         this.name = this.constructor.name;
//     }
// }

// class ValidationError extends MyBasicError { }

// class PropertyRequiredError extends ValidationError {
//     constructor(property) {
//         super('No such property: ' + property);
//         this.property = property;
//     }
// }
// // код стал заметно короче, потому что не нужно дублировать this.name, а конструктор прототипно наследуется.

// let json = '{"name": "John", "ge: 30}';

// function readUser(json) {
//     let user = JSON.parse(json);

//     if (!user.name) {
//         throw new PropertyRequiredError('name');
//     } else if (!user.age) {
//         throw new PropertyRequiredError('age');
//     }
//     return user;
// }

// try {
//     readUser(json);
// } catch (err) {
//     if (err instanceof ValidationError) {
//         console.log('Incorrect data: ' + err.message);
//         console.log(err.name); // PropertyRequiredError
//     } else if (err instanceof SyntaxError) {
//         console.log('Incorrect JSON: ' + err.message);
//         console.log(err.name); // SyntaxError
//     } else {
//         throw err;
//     }
// }


// Обёртывание исключений
// Сейчас назначение функции readUser - чтение данных. В процессе её работы могут возникать различные виды ошибок.
// Сейчас их два вида. Но что, если функция разрастётся и сможет давать другие ошибки? Код, который вызывает readUser должен
// обрабатывать эти ошибки. Сейчас в этом коде используются конструкции if в блоке catch, которые проверяют известные классы,
// а неизвестные ошибки при это пробрасывают. Но если функция способна генерировать столько ошибок, нужно ли мне проверять все
// типы ошибок поодиночке во всех местах в коде, где вызывается realUser? - нет. Чаще всего внешний код хочет иметь какую-то
// обобщённую ошибку чтения данных. Почему это произошло часто не имеет значения. Но лучше, когда есть способ узнать причину ошибки
// только тогда, когда мне это нужно.
// Итак, я создам новый класс ReadError, для представления таких ошибок. Если ошибка возникнет, я её перехвачу и сгенерирую
// readError, я также сохраню ссылку на исходную ошибку в свойстве cause. Тогда внешний код должен будет проверить только наличие
// ReadError. Перепишу для наглядности старый код.

// class Error {
//     constructor(message) {
//         this.message = message;
//         this.name = this.constructor.name;
//     }
// }

// class ValidationError extends Error { }

// class PropertyRequiredError extends ValidationError {
//     constructor(property) {
//         super('Отсутствует свойство ' + property);
//         this.property = property;
//     }
// }

// class ReadError extends Error {
//     constructor(message, cause) {
//         super(message);
//         this.cause = cause;
//     }
// }

// // теперь функция валидации
// function validateUser(user) {
//     if (!user.name) {
//         throw new PropertyRequiredError('name');
//     }
//     if (!user.age) {
//         throw new PropertyRequiredError('age');
//     }
// }

// // новая функция чтения
// function readUser(json) {
//     let user;

//     try {
//         user = JSON.parse(json); // сначала пробую просто прочитать json
//     } catch (err) {
//         if (err instanceof SyntaxError) {
//             throw new ReadError('Синтаксическая ошибка', err); // выдать синтаксическую ошибку (если есть)
//         } else {
//             throw err;
//         }
//     }

//     try {
//         validateUser(user); // здесь уже проверяю сами поля, если json прочитался
//     } catch (err) {
//         if (err instanceof ValidationError) {
//             throw new ReadError('Ошибка валидации', err);
//         } else {
//             throw err;
//         }
//     }
// }

// // пробую
// try {
//     readUser('{"name": "Stan"}');
// } catch (e) {
//     if (e instanceof ReadError) {
//         console.log(e.message);
//         console.log('Исходная ошибка: ' + e.cause);
//     } else {
//         throw e;
//     }
// }

// Выше функция ReadError работает, как и описано - распознаёт синтаксические ошибки и ошибки валидации и выдаёт вместо них ошибки
// ReadError. Неизвестные ошибки пробрасываются.
// Внешний код проверяет только instance of ReadError. Не нужно перечислять все возможные типы ошибок.

// Такой подход называется обёртывание исключений, потому что я беру исключения низкого уровня и оборачиваю их в ReadError,
// котрый является болл абстрактным и более удобным в вызывающем коде. Такой подход широко используется в ООП.


// Задачи после раздела
// Наследование от SyntaxError

// class FormatError extends SyntaxError {
//     constructor(message) {
//         super(message);
//         this.name = this.constructor.name;
//         this.stack = 'stack';
//     }
// }

// let err = new FormatError('Ошибка форматирования');

// console.log(err.message); // Ошибка форматирования
// console.log(err.name); // FormatError
// console.log(err.stack); // stack
// console.log(err instanceof FormatError); // true
// console.log(err instanceof SyntaxError); // true

// всё работает в соответствии с заданием


// Промисы, async/await
// Введение: колбэки

// Многие действия в JS асинхронные, например:
// function loadScript(src) {
//     let script = document.createElement('script');
//     script.src = src;
//     document.head.append(script);
// }
// эта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция <script src="..."> браузер
// загрузит скрипт и выполнит его.
// Вот пример использования:
// loadScript('/my/script.js');

// Такие функции называют асинхронными, потому что действие (загрузка скрипта) будет выполнено не сейчас, а потом.
// После вызова loadScript есть какй-то код, но он не будет ждать, пока скрипт загрузится.

// loadScript('/my/script.js');
// код, написанный после вызова функции loadScript, // не будет дожидаться полной загрузки скрипта
// ...

// Я хотел использовать новый скрипт сразу после того, как он загрузится. Допустим, он обновляет функцию, которую я бы хотел
// выполнить. Но если я просто вызову функцию loadScript(), у меня ничего не выйдет:

// loadScript('/my/script.js'); // в скрипте есть "function newFunction() {...}"
// newFunction(); // такой функции не существует!

// Так и есть, потому что у браузера не было времени загрузить скрипт. Передам в функцию колбэк, чтобы вызвать её после загрузки
// скрипта. Сам колбэк я передам вторым аргументом в loadScript.
// function loadScript(src, callback) {
//     let script = document.createElement('script'); // создаю элемент (скрипт)
//     script.src = src; // присваиваю ему свойство, равное первому аргументу функции
//     script.onload = () => callback(script); // *
//     document.head.append(script); // помещаю элемент (скрипт) в тэг head
// }

// * событие onload в основном выполняет функцию после загрузки и выполнения скрипта. Теперь, если я хочу вызвать функцию из
// скрипта, мне нужно вызывать её в колбэке:
// loadScript('/my/script.js', function () {
//     // эта функция вызовется после того, как загрузится скрипт
//     newFunction(); // теперь всё будет работать
// });
// смысл такой: вторым аргументом передаётся функция (обычно анонимная) котроая выполняется по завершении действия.

// Возьму для примера реальный скрипт с библиотекой функций
// function loadScript(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;
//     script.onload = () => callback(script);
//     document.head.append(script);
// }

// loadScript(
//     'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js',
//     script => {
//         console.log(`Здорово, скрипт ${script.src} загрузился`); // Здорово, скрипт https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js загрузился
//         console.dir(_); // функция, объявленная в загруженном скрипте
//     }
// );

// Такое написание называют асинхронным программированием с использованием колбэков.
// В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback - функция, которая будет вызвана
// по завершении асинхронного действия.


// Колбэк в колбэке
// как мне загрузить два скрипта один за одним? Первое, что приходит в голову вложенный вызов функции внутри колбэка.
// И это сработает. Можно и третий скрипт следом загрузить - его следует вкладывать уже во второй колбэк.
// function func(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;
//     script.onload = () => callback(script);
//     document.head.append(script);
// }

// func('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', (script) => {
//     console.log(_.name, _.VERSION);

//     func('https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js', (script) => {
//         console.log('Для примера подгрузил jQuery', jQuery());

//         func('https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js', (script) => {
//             console.log('А здесь - версия подгруженной jQuery:', jQuery.fn.jquery);
//         });
//     });
// });

// Это отлично подойдёт, если мне нужно выполнить пару действий - пару последовательных загрузок скриптов, например.
// Если больше, то нужен другой подход - о нём позже.


// Перехват ошибок
// Что если загрузить скрипт не удалось? Сделаю колбэк, который будет отлавливать ошибки загрузки.
// function loadScript(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;

//     script.onload = () => callback(null, script);
//     script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${script}`));

//     document.head.append(script);
// }
// Так я вызову calback(null, script) в случае успешной загрузки и calback(new Error('...')) в случае, если загрузить скрипт
// не удалось.

// Живой пример
// loadScript('/my/script.js', function (error, script) {
//     if (error) {
//         // обрабатываю ошибку
//     } else {
//         // скрипт успешно загружен
//     }
// });
// Этот подход распространён и называется "колбэк с первым аргументом ошибкой" ('error-first-callback'). Его правила таковы:
// 1. Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит как callback(error).
// 2. Второй и последующие аргументы - для результатов выполнения. В этом случае вызов выглядит вот так:
// callback(null, result1, result2, ...).
// Одна и та же функция используется и для информирования ошибке, и для передачи результатов.

// Адская пирамида вызовов
// С одной стороны такой способ вложенных вызовов выглядит нормально, так можно делать. Но если таких вызовов несколько код
// гораздо хуже читается. Я могу сам запутаться в своём же коде. Особенно, если моя функция отлавливает ошибки в том числе,
// то есть, там внутри есть ещё функции, условия и т.д.
// Иногда большое количесвто вложенных колбэков называют адом колбэков, или адской пирамидой колбэков.
// Можно решить решить эту проблему, изолируя каждое действие в отдельную функцию, вот так:

// function loadScript(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;
//     script.onload = () => callback(script);
//     document.head.append(script);
// }
// теперь напишу отдельно каждый колбэк через Function Declaration, а первый вызов будет таким
// loadScript('/source/script1.js', step1);

// делаю error-first-callback
// function step1(error, script) {
//     if (error) {
//         handleError(error); // обработчик ошибки, если такая возникнет
//     } else {
//         // ...
//         loadScript('/source/script2.js', step2); // если всё ок, то загружаю следующий скрипт и для него использую второй колбэк
//     }
// }

// function step2(error, script) {
//     if (error) {
//         handleError(error);
//     } else {
//         loadScript('/source/script3.js', step); // здесь также - если нет ошибки, загружаю третий скрипт
//     }
// }
// И так далее, сколько потребуется вызовов. Казалось бы, стало лучше. Но теперь код выглядит разорванным, нужно постоянно
// перескакивать по строчкам, а колбэки по сути одноразовые - их нельзя переиспользовать, помимо этого засоряется пространство
// имён. Есть способ получше - использование промисов.


// Промисы

// Промис - это специальный объект в JS, который связывает "создающий" и "потребляющий" коды вместе.

// Синтаксис для его создания:
// let promise = new Promise(function(resolve, reject) {
//     // функция-исполнитель (executor)
//     // некий создающий код
// });

// Функция, переданная в конструкцию new Promise называется исполнитель (executor). Когда промис создаётся, она запускается
// автоматически. Она должна содержать "создающий" код, который когда-нибудь создаст результат.
// Её аргументы - resolve, reject - это колбэки, которые предоставляет сам JS. Мой код - только внутри исполнителя!

// Когда промис получает результат (сейчас или позже), он должен вызвать один из колбэков. Resolve(value) - если работа
// завершилась успешно, с результатом value или reject(error) - если произошла ошибка, с объектом ошибки error.
// Итак, исполнитель вызывается автоматически, а затем должен вызвать один из колбэков.

// У объекта, возвращаемого конструктором new Promise есть внутренние свойства:

// state - состояние - в начале "pending" (ожидание), потом меняется на "fulfilled" (выполнено успешно) при вызове resolve,
// или на "rejected" (выполнено с ошибкой) при вызове reject.

// result - результат - вначале "undefined", далее изменяется на value при вызове resolve(value) или на error при вызове
// reject(error).

// Получается, что функция-исполнитель переводит промис в одно из двух состояний.

// Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой через setTimeOut
// let promise = new Promise(function (resolve, reject) {
//     // эта функция выполнится автоматически при вызове new Promise

//     // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
//     setTimeout(() => resolve("done"), 1e3);
// });
// Здесь функция-исполнитель запускается сразу же при вызове конструктора.
// Исполнитель получает два аргумента - они встроенные в язык, поэтому мне не нужно их писать. Спустя 1 секунду исполнитель вызовет
// resolve("done"), чтобы передать в результат. Это успешно выполненный промис.

// Теперь промис с ошибкой
// let promise = new Promise(function (resolve, reject) {
//     setTimeout(() => reject(new Error('Произошла ошибка')), 1e3);
// });

// Промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject,
// чтобы изменить состояние соответствующего Promise.

// Промис - и успешный, и отклонённый буду называть "завершённым", в отличие от изначального промиса, который "в ожидании".

// Итогом вызова промиса может быть что-то одно - результат или ошибка. В итоге исполнитель должен вызвать или resolve, или reject.
// Состояние промиса может быть изменено только один раз. Все последующие вызовы resolve и reject будут проигнорированы:
// let promise = new Promise(function (resolve, reject) {
//     resolve("done");

//     reject(new Error('Ups')); // проигнорируется
//     setTimeout(() => resolve("done again"), 1e3); // проигнорируется
// });
// console.log(promise); // Promise {<fulfilled>: 'done'}

// И ещё, функции resolve или reject ожидают только один аргумент, все остальные будут проигнорированы.

// Reject нужно вызывать только с объектом Error или унаследованным от него. Технически, можно передать всё, что угодно, но
// так делать не стоит.

// Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть через какое-то время.
// Но это не обязательно, они могут быть вызваны сразу:
// let promise = new Promise(function (resolve, reject) {
//     // задача, требующая времени
//     resolve('Right now'); // выдаст результат 'Right now' мгновенно
// });
// Это может случиться, когда я начал выполнять какую-то задачу, но тут же увидел, что ранее уже её выполнял,
// и результат закеширован. - Такая ситуация нормальна, я сразу получу успешно завершённый промис.

// Свойства state и result - это внутренние свойства объекта Promise, и я не имею к ним прямого доступа. Для обработки результата
// следует вызывать методы .then/.catch/.finally - о них - далее.

// Потребители: then, catch.
// Объект Promise является связующим звеном между функцией-исполнителем и функциями-потребителями, которые либо получат результат
// либо ошибку. Функции потребители могут быть зарегестрированы (подписаны) с помощью методов .then и .catch.

// Then - наиболее важный и фундаментальный метод.
// Его синтаксис:
// promise.then(
//     function(result) {// обработает успешное завершение промиса},
//     function(error) {// обработает ошибку}
// );

// Ниже я рассмотрю реакцию .then на успешно выполненный промис
// let promise = new Promise(function (resolve, reject) {
//     setTimeout(() => resolve('done!'), 1e3);
// });

// resolve запустит первую функцию, переданную в .then - потому что промис выполнится успешно
// promise.then(
//     result => console.log(result), // done!
//     error => console.log(error)
// );

// теперь неуспешно завершённый промис
// let promise2 = new Promise(function(resolve, reject) {
//     setTimeout(() => reject('Oh my, error!'), 1e3);
// });

// promise2.then(
//     result => console.log(result), 
//     error => console.log(error) // Oh my, error!
// );

// Если я заинтересован только в результате, то в .then можно передать только одну функцию:
// let promise = new Promise(function(resolve, reject) {
//     setTimeout(() => resolve('Only done!'));
// });

// promise.then(console.log); // Only done!


// Catch
// если бы я хотел только обработать ошибку, то можно использовать null в качестве первого аргумента, вот так:
// .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое.
// Посмотрим ниже:
// let promise = new Promise(function(resolve, reject) {
//     setTimeout(() => reject('Has only an error'), 2e3);
// });

// catch(f) - это то же самое, что и .then(null, f)
// promise.catch(console.log); // Has only an error


// Очистка: finally
// по аналогии с блоком finally из обычного try {} catch {}, у промисов также есть метод finally.
// Вызов finally(f) похож на then(f, f) в том смысле, что f выполнится в любом случае, когда промис завершится успешно или
// с ошибкой.
// Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
// Например, остановка идникатора загрузки, закрытие больше ненужных соединений и т.д.
// В книге предлагают думать об этом, как о вечеринке - неважно какой она была, хорошей или плохой - после неё нужно сделать
// уборку. Код может выглядеть следующим образом:

// let promise = new Promise(function (resolve, reject) {
//     // сделать что-то, что займёт время и после вызвать resolve/reject
// });

// finally(f) выполнится, когда промис завершится, независимо от того, успешно или нет
// promise.finally(() => остановить индикатор загрузки)
// // таким образом, индикатор всегда будет останавливаться прежде, чем я продолжу.
// .then(result => показать результат, err => показать ошибку)

// Есть пара моментов:
// 1. Обработчик, вызываемый из finally() не имеет аргументов. В finally() я не знаю, как был завершён промис. И это нормально - 
// потому что моя задача выполнить общие завершающие процедуры. В приведённом примере finally() не имеет аргументов, а результат
// промиса обрабатывается в следующем обработчике.
// 2. Обработчик finally() "пропускает" результат или ошибку дальше, к последующим обработчикам.

// например здесь, результат проходит через finally к then:
// let promise = new Promise(function (resolve, reject) {
//     setTimeout(() => resolve('value'), 2e3);
// });

// promise
//     .finally(console.log('Промис завершён')) // Промис завершён, то как он завершён пойдёт в .then
//     .then(
//         result => console.log(result), // value - покажет через 2 сек
//         erorr => console.log(error)
//     );
// как я мог видеть результат передаётся через finally к следующему then.
// Это очень удобно, потому что finally не предназначен для обработки результата промиса, его задача - общая очистка, независимо от
// результата промиса.

// А здесь ошибка из промиса проходит через finally в catch
// let promise = new Promise(function(resolve, reject) {
//     setTimeout(() => reject(new Error("Ups, error")), 2e3);
// });

// promise
// .finally(console.log('It\'s finally'))
// .then(
//     result => console.log(result),
//     error => console.log(error)
// );

// 3. И третий момент - обработчик finally не должен ничего возвращать, если это не так то возвращаемое значение игнорируется.
// * единственным исключением из этого правила является то, когда обработчик finally выдаёт ошибку. Затем ошибка передастся
// в последующий обработчик вместо любого предыдущего результата.

// На завершённых промисах обработчики запускаются сразу. Если промис находится в состоянии ожидания, то обработчики тоже будут
// ждать. Как только промис перейдёт в завершённое состояние - они немедленно запустятся.


// Пример loadScript - здесь мне предлагают рассмотреть реальные примеры того, как промисы могут облегчить мне жизнь.
// Для этого я буду использовать пример с колбэками из прошлой главы.

// Вот вариант с колбэками
// function loadScript(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;

//     script.onload = () => callback(null, script);
//     script.onerror = () => callback(new Error(`An error while loading ${src}`));

//     document.head.append(script);
// }

// Теперь перепишу его с использованием Promise
// Новой функции теперь не нужен аргумент callback. Вместо этого она будет создавать и возвращать объект Promise, который перейдёт
// в состояние "успешно завершён", когда загрузка закончится. Внешний код может добавлять обработчики "функций-потребителей",
// используя .then.

// function newLoadScript(src) {
//     return new Promise(function (resolve, reject) {
//         let script = document.createElement('script');
//         script.src = src;

//         script.onload = () => resolve(script);
//         script.onerror = () => reject(new Error(`An error while loading ${src}`));

//         document.head.append(script);
//     });
// }

// Применение
// let promise = newLoadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

// promise.then(
//     result => console.log(_.name, _.VERSION, ' - значит, скрипт загружен'), // lodash 4.17.11  - значит, скрипт загружен
//     error => console.log(error.message)
// );

// promise.then(script => console.log('Ещё один обработчик для ' + _.name));

// Итак, какие преимущества промисы мне дают по сравнению с колбэками?
// 1. Промисы позволяют мне делать вещи в естественном порядке - сперва вызвать newLoadScript(script), и затем уже что-то делать с
// результатом промиса при помощи .then --- В то время, как при использовании колбэков у меня должна быть функция callback на
// момент вызова loadScript(src, callback). Другими словами, мне нужно знать, что делать срезультатом до того, как вызовется
// loadScript.
// 2. Я могу вызывать .then у Promise столько, сколько захочу, с каким угодно обработчиком результата --- А колбэк могу вызвать
// только 1 раз.


// Задачи после раздела

// Можно ли перевыполнить промис?
// let promise = new Promise(function(resolve, reject) {
//     resolve(1);

//     setTimeout(() => resolve(2), 2e3);
// });

// promise.then(console.log); // выведет 1, потому что состояние промиса может быть изменено только один раз - все остальные вызовы
// resolve/reject будут проигнорированы


// Задержка на промисах
// Создать альтернативу setTimeOut и использованием промисов
// function delay(ms) {
//     delay.ms = ms;
//     return new Promise(resolve => setTimeout(resolve, ms));
// }

// // использование
// delay(2e3).then(() => console.log(`Выполнилось через ${delay.ms / 1000} сек.`));



// Цепочка промисов
// В систуации из главы "Введение : колбэки" у меня есть последовательность асинхронных задач, которые должны быть выполнены
// одна за другой. Напрмер, последовательная загрузка скриптов. В этой главе я рассмотрю, как грамотно реализовать это в коде
// с помощью цепочки промисов. Она выглядит вот так:

// new Promise(function (resolve, reject) {

//     setTimeout(() => resolve(1), 1e3);

// }).then(function (result) {
//     console.log(result); // 1
//     return result * 2;

// }).then(function (result) {
//     console.log(result); // 2
//     return result * 2;

// }).then(function (result) {
//     console.log(result); // 4
//     return result * 2;
// });

// Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.
// Всё это работает, потому что promise.then тоже возвращает промис, так что я могутвызвать на нём следующий .then.
// Когда обрабочтик возвращает какое-то значение, оно становится результатом выполнения соответствующего промиса и
// передаётся в следующий then.

// ! Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису, но это не цепочка.
// Например:
// let promise = new Promise(function(resolve, reject) {
//     setTimeout(() => resolve(1), 1e3);
// });

// promise.then(function(result) {
//     console.log(result); // 1
//     return result * 2;
// });

// promise.then(function(result) {
//     console.log(result); // 1
//     return result * 2;
// });

// promise.then(function(result) {
//     console.log(result); // 1
//     return result * 2;
// });

// Вот я добавил несколько обработчиков другому промису, но они не передают друг другу результат, они действуют независимо.


// Возвращаем промисы
// Обработчик, переданный в then может вернуть промис. В этом случае следующие обработчики будут ждать, пока он выполнится.
// Вот пример:
// new Promise(function (resolve, reject) {
//     setTimeout(() => resolve(1), 1e3);

// }).then(function (result) {
//     console.log(result);

//     return new Promise(function (resolve, reject) {
//         setTimeout(() => resolve(result * 2), 2e3);
//     });

// }).then(function (result) {
//     console.log(result);

//     return new Promise(function (resolve, reject) {
//         setTimeout(() => resolve(result * 2), 1e3);
//     });

// }).then(function (result) {
//     console.log(result);
// });

// Здесь первый then показывает 1 и возвращает новый промис, который успешно выолняется через 1 секунду, и его результат (аргумент
// в resolve, т.е. result * 2 передаётся обработчику в следующем then. И этот обработчик делает то же самое.
// Как и в предыдущем примере выведется результат 1>2>4, но теперь между ними существует пауза 1 сек.

// Возвращая промисы, я могу создавать цепочки из асинхронных действий.


// Пример с loadScript
// // Функция также будет загружать скрипты по очереди, но теперь она промисифицирована
// function loadScript(src) {
//     return new Promise((resolve, reject) => {
//         let script = document.createElement('script ');
//         script.src = src;

//         script.onload = resolve(script);
//         script.onerror = reject(new Error('Не удалось загрузить скрипт'));

//         document.head.append(script);
//     });
// }

// loadScript('/article/promise-chain-one.js')
//     .then(function (script) {
//         return loadScript('/article/promise-chain-two.js');
//     })
//     .then(function (script) {
//         return loadScript('article/promise-chain-three.js');
//     })
//     .then(function (script) {
//         // вызову функции, объявленные в загруженных скриптах, чтобы показать, что они действительно загрузились
//         one();
//         two();
//         three();
//     });

// Этот же код можно переписать короче, используя стрелочные функции
// loadScript('/article/promise-chain-one.js')
//     .then(script => loadScript('/article/promise-chain-two.js'))
//     .then(script => loadScript('/article/promise-chain-three.js'))
//     .then(script => {
//         one();
//         two();
//         three();
//     });

// Здесь каждый вызов loadScript возвращает промис, и следующий обработчик в then сработает только тогда, когда
// этот промис завершается. Затем инициируется загрузка следующего скрипта и т.д.

// Технически можно добавлять then напрямую к каждому вызову loadScript, но тогда код снова начнёт расти вправо, и вообще,
// использование цепочек предпочтительнее.
// Но иногда приемлемо добавлять then напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости - НО
// это скорее исключение чем правило.


// Thenable
// Обработчик может возвращать не только промис, а любой объект, содержащий метод .then, такие объекты называют thenable.
// Смысл в том, что сторонние библиотеки могут создавать свои собственные объекты, совместимые с промисами. Они могут иметь
// свои наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод then, например:

// class Thenable {
//     constructor(num) {
//         this.num = num;
//     }
//     then(resolve, reject) {
//         console.log(resolve); // ƒ () { [native code] }

//         // будет успешно выполнено с аргументом this.num * 2 через 1 секунду
//         setTimeout(() => resolve(this.num * 2), 1e3);
//     }
// }

// new Promise(resolve => resolve(1))
//     .then(result => {
//         return new Thenable(result); // *
//     })
//     .then(console.log); // покажет 2 через 1 секунду

// JS проверяет объект, возвращаемый из обработчика .then в строке *: если у него имеется метод then, который можно вызвать, то
// этот метод вызывается, и в него передаются как аргументы встроенные функции - resolve и reject, вызов одной из которых потом
// ожидается. В примере выше произошёл вызов resolve через 1 секунду, затем передаётся по цепочке дальше.
// Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.


// Fetch
// Во фронтенд разработке промисы часто используются, чтобы делать запросы по сети.
// Я буду использовать его (метод fetch), чтобы подгрузить информацию о пользователях. У него много опциональных параметров.
// Его базовый синтксис let promise = fetch(url); - этот код запрашивает урл и возвращает промис.
// Промис успешно выполняется и в свою очередь возвращает объект response после того, как удалённый сервер присылает
// заголовки ответа, но до того, как весь ответ сервера полностью загружен.
// Чтобы прочитать полный ответ, нужно вызвать метод response.text(): он тоже возвращает промис, который выполлняется, когда
// данные с сервера полностью загружены с удалённого сервера, и возвращает эти данные.

// fetch('https://jsonplaceholder.typicode.com/todos/1')
//     // then в коде ниже выполняется, когда удалённый сервер отвечает
//     .then(function (response) {
//         // response.text() - возвращает новый промис, который выполняется
//         // и возвращает полный ответ сервера, когда он загрузится
//         return response.text();
//     })
//     .then(function (text) {
//         // ... и здесь содержимое полученного файла
//         console.log(text); // {"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}
//     });

// // Есть также метод response.json() - он больше подходит для этого примера. Также я использую стрелочные функции для краткости.
// fetch('https://jsonplaceholder.typicode.com/todos/2')
//     .then(response => response.json())
//     .then(user => console.log(user.title)); // quis ut nam facilis et officia qui

// Теперь попробую что-нибудь сделать с данными пользователя. Например, я могу послать запрос на  GitHub, чтобы загрузить данные
// из профиля пользователя, чтобы загрузить его аватар. Пример из книги:

// запрашиваю данные пользователя
// fetch('https://jsonplaceholder.typicode.com/users/', { // посмотрел как юзать этот апи, чтобы кастомизировать ответ сервера
//     method: 'POST',
//     body: JSON.stringify({
//         title: 'foo',
//         body: 'bar',
//         userId: 1,
//         name: 'Ivan-Linnik', // добавил новое свойство, чтобы к нему обратиться - это мой никнейм на Гите
//     }),
//     headers: {
//         'Content-type': 'application/json; charset=UTF-8',
//     },
// })
//     // загружаю данные в формате json
//     .then(response => response.json())
//     // делаю запрос к GitHub, используя полученные данные пользователя
//     .then(result => fetch(`https://api.github.com/users/${result.name}`))
//     // загружаю ответ в формате json
//     .then(response => response.json())

//     // показываю аватар(githubUser.avatar_url) в течение 3 секунд
//     .then(githubUser => {
//         let main = document.querySelector('.main__container');
//         let img = document.createElement('img');
//         img.src = githubUser.avatar_url; // заменил изображение на странице
//         img.style.width = '250px';

//         main.appendChild(img);

//         setTimeout(() => { img.remove() }, 5e3); // вернул обратно (*)
//     });

// Код работает, но в нём есть проблема. Она в строке (*): как я могу предпринять какие-то действия после того, как аватар
// был показан и удалён? Например, я бы хотел показать форму редактирования пользователя или что-то ещё, но сейчас это невозможно.
// Чтобы сделать код расширяемым нужно возвращать ещё один промис, который будет выполняться после того, как завершается показ 
// аватара.

// fetch('https://jsonplaceholder.typicode.com/users/', {
//     method: 'POST',
//     body: JSON.stringify({
//         title: 'foo',
//         body: 'bar',
//         userId: 1,
//         name: 'Ivan-Linnik', // добавил новое свойство, чтобы к нему обратиться - это мой никнейм на Гите
//     }),
//     headers: {
//         'Content-type': 'application/json; charset=UTF-8',
//     },
// })
//     .then(response => response.json())
//     .then(result => fetch(`https://api.github.com/users/${result.name}`))
//     .then(response => response.json())
//     .then(githubUser => new Promise(function (resolve, reject) { // (*)
//         let main = document.querySelector('.main__container');
//         let img = document.createElement('img');

//         img.src = githubUser.avatar_url;
//         img.style.width = '250px';

//         main.appendChild(img);

//         setTimeout(() => {
//             img.remove();
//             resolve(githubUser);
//         }, 3e3);
//     }))
//     .then(githubUser => console.log(`Завершён показ автара пользователя ${githubUser.name}.
// URL аватара: ${githubUser.avatar_url}.`));


// Здесь обработчик then в строке (*) будет возвращать новый промис, который перейдёт в состояние "выполнен" после того,
// как в setTimeout будет вызван колбэк resolve c объектом githubUser. Соответственно следующий по цепочке then будет ждать этого.

// Как правило, все асинхронные действия должны возвращать промис. Это позволяет планировать какие действия будут выполнены после
// него. Даже если это не нужно прямо сейчас, это может понадобиться в будущем.

// Теперь автор предлагает разобрать код на отдельные функции, пригодные для использования.
// function loadJson(url, options) {
//     return fetch(url, options)
//         .then(response => response.json());
// }

// function loadGithubUser(name) {
//     return fetch(`https://api.github.com/users/${name}`)
//         .then(response => response.json());
// }

// function showAvatar(githubUser) {
//     return new Promise(function (resolve, reject) {
//         let main = document.querySelector('.main__container');
//         let img = document.createElement('img');

//         img.src = githubUser.avatar_url;
//         img.style.width = '250px';
//         main.append(img);

//         setTimeout(() => {
//             img.remove();

//             resolve(githubUser);
//         }, 3e3);
//     });
// }

// // Использование этих функций
// loadJson('https://jsonplaceholder.typicode.com/users/', {
//     method: 'POST',
//     body: JSON.stringify({
//         userId: 1,
//         name: 'Ivan-Linnik',
//     }),
//     headers: {
//         'Content-type': 'application/json; charset=UTF-8',
//     },
// })
//     .then(user => loadGithubUser(user.name))
//     .then(showAvatar)
//     .then(githubUser => console.log(`Завершил показ аватара пользователя ${githubUser.name}`));


// Задачи после раздела

// Сравните then и catch
// promise.then(f1).catch(f2) не будет эквивалентно promise.then(f1, f2). Потому что ошибка произойдёт в f1, то она
// будет обработана только в блоке catch в этом примере: promise.then(f1).catch(f2). Ошибка передаётся по цепочке, а в первом
// случае после then ничего нет, поэтому нечему её обрабатывать.


// Промисы: обработка ошибок
// Кэтч можно размещать, где угодно, например в конце. Таим образом удобно ловить ошибки. Если всё в порядке, то он просто не выполнится, но если любой из
// промисов будет отклонён, то ошибка сразу попадё в блок кэтч.


// Неявный try...catch
// Вокруг функции промиса и и обработчиков находится невидымый блок трай...кэтч. Если происходит исключение, что оно перехватывается, и промис считается
// отклонённым с этой ошибкой.

// new Promise(function(resolve, reject) {
//     throw new Error('Error-error');
// }).catch(console.log); // это работает также, как и пример ниже

// new Promise(function(resolve, reject) {
//     reject(new Error('Error-error'));
// }).catch(console.log); 

// Неявный трай-кэтч поймает любую ошибку в промисе, обработчике, даже программную ошибку.


// Проброс ошибок
// Ошибки в промисах можно пробрасывать по аналоги с трай-кэтч.
// Ниже блок кэтч обработает ошибку и передаст результат в зен.

// new Promise(function(resolve, reject) {
//     reject(new Error('Ups'));
// }).catch(function(error) {
//     console.log('Handle an ' + error);
// }).then(() => console.log('Now control is here'))


// Необработанные ошибки
// в промисах, как и в трай...кэтч, если ошибку не перехватить, скрипт умирает с сообщением в консоли. Движок это отслеживает и генерирует глобальную ошибку.

// В браузере поймать такие ошибки можно при помощи события unhandledrejection. Пример:
// new Promise(function () {
//     throw new Error('Sosi');
// }).then(result => console.log(result))

// window.addEventListener('unhandledrejection', function (event) {
//     console.log(event.promise); // Promise {<rejected>: Error: Sosi
//     console.log(event.reason); // Error: Sosi
// });

// Это событие является частью стандарта HTML


// Promise API
// В классе Promise есть 6 статических методов

// Promise.all - нужен тогда, когда мне нужно запустить сразу несколько промисов параллельно и дождаться, пока они выполнятся. Например, загрузить несколько файлов
// и обработать результат.
// В качестве аргумента передаётся перебираемый объект, как правило массив промисов, вот так:

// let promises = Promise.all([
//     new Promise((resolve) => {
//         resolve(1);
//     }),
//     new Promise((resolve) => {
//         setTimeout(() => resolve(2), 1e3);
//     }),
//     new Promise((resolve) => {
//         resolve(3)
//     }),
// ]);

// а в качестве результата возвращается новый промис
// promises.then(console.log); // [1, 2, 3] - новый промис завершится, когда выполнятся все промисы в переданном массиве, а его результатом будет
// массив результатов выполнения всех переданных промисов. Здесь каждый промис даёт элемент массива. Важно отметить, что порядок элементов массива соотвествует
// порядку переданных промисов. У меня второй промис выполняется дольше всех, но всё равно, результаты будут записаны в массив по порядку.

// Часто используемый трюк - пропустить массив данных через мап-функцию, которая для каждого элемента создаст задачу-промис, и затем обернуть получившийся массив
// в промис.олл, вот так:

// let urls = [
//     'https://api.github.com/users/iliakan',
//     'https://api.github.com/users/remy',
//     'https://api.github.com/users/jeresig'
// ];

// let requests = urls.map(url => fetch(url));

// Promise.all(requests)
// .then(responses => responses.forEach(
//     response => console.log(`${response.url}: ${response.status}`) // выведет url и статус 200 для каждого запроса
// ));


// Теперь пример побольше, с получением данных пользователей гитхаб по их логинам из массива (также можно получать массив товаров по их идентификаторам).
// let names = ['iliakan', 'remy', 'jeresig'];

// let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

// Promise.all(requests)
//     .then(responses => {
//         // все промисы успешно завершены
//         responses.forEach(response => {
//             console.log(`${response.url}: ${response.status}`);
//         });

//         return responses;
//     })
//     // преобразовать массив ответов в json, чтобы прочитать содержимое каждого
//     .then(responses => Promise.all(responses.map(r => r.json())))
//     .then(users => {
//         users.forEach(user => console.log(user.name, user.id))
//     });

// Если один из промисов завершится ошибкой, то и промис, возвращаемый промис.олл завершится с этой ошибкой. Пример:
// Promise.all([
//     new Promise((resolve, reject) => resolve(1)),
//     new Promise((resolve, reject) => setTimeout(() => reject(new Error('Ups...')), 1e3)),
//     new Promise((resolve, reject) => setTimeout(() => resolve(2), 1e3))
// ])
// .catch(console.log); // Error: Ups... at script.js:184:62

// *Технически в промис.олл можно передать не только промисы, в таком случае, переданное что-то будет обрабатываться как есть, и также попадёт в массив результатов.


// Promise.allSettled([iterable]) - в отличие от промис.олл, ожидает завершения всех промисов (неудачных в том числе), и возвращает массив результатов с объектами
// завершённых промисов, в которых указано состояние завершенного промиса и результат.
// В массиве результатов будет:
// {status:"fulfilled", value:результат} для успешных завершений,
// {status:"rejected", reason:ошибка} для ошибок.

// Например мне нужно загрузить данные пользователей, и если один из них не загрузится, то я всё равно хочу получить остальные, пример ниже:

// let urls = [
//     'https://api.github.com/users/iliakan',
//     'https://api.github.com/users/remy',
//     'https://no-such-url'
// ];

// Promise.allSettled(urls.map(url => fetch(url)))
//     .then((results) => console.log(results));

// Теперь для каждого промиса у меня есть статус и значение/ошибка.

// Promise.race([iterable]) - берёт результат первого выполненного промиса, будь то значение или ошибка.

// Promise.any([iterable]) - ждёт только первый успешно выполненный промис, из которого берёт результат.

// Promise.resolve/reject - старый синтаксис, ему на замену пришли async/await


// Промисификация
// Означает преобразование функции - я беру функцию, которая принимает колбэк и меняю её, чтобы она возвращала промис.
// Например у меня есть функция (ниже) - я её промисифицирую.

// function loadScript(src, callback) {
//     let script = document.createElement('script');
//     script.src = src;

//     script.onload = () => callback(script);
//     script.onerror = () => callback(new Error('Ошибка загрузки скрипта: ', src));

//     document.head.append(script);
// }

// // После промисификации новая функция будет принимать только src и возвращать промис.
// let loadScriptPromise = function (src) {
//     return new Promise((resolve, reject) => {
//         loadScript(src, (err, script) => {
//             if (err) reject(err)
//             else resolve(script);
//         });
//     });
// }
// использование: loadscriptPromise('/needed/path.js).then(...)

// На практике нужно промисифицироавть не одну функцию, поэтому я напишу универсальную функцию-помощник.

// function promisMe(func) {
//     return function (...args) { //возвращает анонимную функцию-обёртку, которая возвращает промис
//         return new Promise(function (resolve, reject) {
//             function callback(err, result) { // специальный колбэк для func
//                 if (err) {
//                     reject(err);
//                 } else {
//                     resolve(result);
//                 }
//             }

//             args.push(callback); // кладу колбэк в конец массива аргументов функции func

//             func.call(this, args); // вызываю оригинальную функцию
//         })
//     }
// }

// использование
// let loadScriptPromise = promisMe(loadScript);
// loadScriptPromise(...).then(...);

// здесь я подразумеваю, что исходная функция ожидает колбэк с двумя аргументами. Если аргументов больше, то тогда нужно будет сделать
// улучшенyую версию функции (см. учебник).


// Микрозадачи
// Обработчики промисов всегда асинхронны, даже если промис выполнился мгновенно, смотрю ниже:
// let promise = Promise.resolve();
// promise.then(()=> console.log('Promise completed')); // выполнится вторым
// console.log('Code completed'); // выполнится первым

// почему зен не срабатывает первым?

// Очередь микрозадач
// Для правильного управления асинхронными задачами стандарт предусматривает внутренню очередь - PromiseJobs - она же очередь микрозадач.
// Она работает так - "первый пришёл, первый выполнен", задачи выполняются только в том случае, если ничего больше не запущено.
// Получается, что обработчики попадают в очередь, и пока не выполняются, а выполняется другой код.
// Но что если мне важна последовательность - всё просто, поместить нужный код в следующий зен, и они выполнятся последовательно с предыдущим зен.


// Необработанная ошибка возникает в случае, если ошибка промиса не обрабатывается к конце очереди микрозадач. И даже если я попытаюсь отловить ошибку глобально,
// это ни на что не повлияет, так как код уже ляжет, потому что ошибка попала в очередь вне цепочки микрозадач. Поэтому ловить их нужно своевременно.


// Async/await
// это специальный синтаксис для работы с промисами.

// Асинхронные функции - это функции, которые всегда возвращают промис. Любые другие значения, возвращаемые такими функциями оборачиваются в промисы автоматически.
// Для этого используется ключевое слово async, вот так:
// async function f() {
//     return 1;
// }

// f().then(console.log); // 1


// Await
// ещё одно ключевое слово. Может использоваться только внутри async-функций. Это слово заставиит интерпретатор ожидать пока часть справа от await не выполнится, а
// потом вернёт результат и выполнение кода продолжится.
// В этом примере промис успешно выполнится через 1 секунду:
// async function f() {
//     let promise = new Promise((resolve) => {
//         setTimeout(() => resolve('Done!'), 1e3);
//     });

//     let result = await promise; // *

//     console.log(result); // Done! - через 1 сеукнду
// }

// f();
// В этом примере выполнение функции остановится на строке * до тех пор, пока промис не выполнится, после чего в переменную result будет записан
// результат выполнения промиса.
// Важно помнить, что await не занимает ресурсов процессора, другие скрипты и код будут и дальше выполняться, ожидать будет только конкретная асинхронная функция.

// Это просто синкасический сахар для получения промиса, более нагрядный, чем зен. Await нельзя использовать вне async функций, будет синтаксическая ошибка.
// Теперь я перепишу showAvatar из раздела Цепочки промисов при помощи асинхронных функция.
// 1. Мне нужно заменить then на await
// 2. Добавить ключевое слово async перед объявлением функции

// async function showAvatar() {
//     // запрашиваю json с данными пользователя
//     let response = fetch('/article/promise-chaining/user.json');
//     let user = await response.json();

//     // запрашиваю информацию об этом пользователе
//     let githubResponse = fetch(`https://api.github.com/users/${user.name}`);
//     let githubUser = await githubResponse.json();

//     // отбражаю аватар пользоваеля
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     document.body.append(img);

//     // жду 3 секунды и скрываю аватар
//     await new Promise((resolve, reject) => { setTimeout(() => resolve), 3e3 });

//     img.remove;

//     return githubUser;
// }

// showAvatar();

// Чтобы выполнить await на верхнем уровне вложенности можно обернуть код в ананимную функцию, вот так
// (async () => {
//     let response = await fetch('...');
//     let user = await response.json();
// })();

// Await работает с thenable объектами, также как и зен.
// class Thenable {
//     constructor(num) {
//         this.num = num;
//     }

//     then(resolve, reject) {
//         console.log(resolve);

//         setTimeout(resolve(this.num * 2), 1e3);
//     }
// };

// async function f() {
//     // код будет ждать 1 секунду
//     // после чего значение result станет равным 2
//     let result = await new Thenable(1);
//     console.log(result);
// }

// f();

// Для объявления асинхронного метода класса достаточно перед таким написать async.


// Задачи после раздела
// переписать,используя async/await

// function loadScript(url) {
//     return fetch(url)
//         .then(response => {
//             if (response.status == 200) {
//                 return response.json();
//             } else {
//                 throw new Error(response.status);
//             }
//         });
// }

// loadScript('no/such-user.json')
//     .catch(console.log); // 404


// // это решение из книги
// async function ldScrpt(url) {
//     let request = await fetch(url);

//     if (request.status == 200) {
//         let response = await request.json();
//         return response;
//     } else {
//         throw new Error(request.status);
//     }
// }
// ldScrpt('no/such-user.json')
//     .catch(console.log);



// 1. переписать,используя async/await
// 2. В функции demoGithubUser замените рекурсию на цикл: используя async/await , сделать это будет просто.

// class HttpError extends Error {
//     constructor(response) {
//         super(`${response.status} for ${response.url}`);
//         this.name = 'HttpError';
//         this.response = response;
//     }
// }

// function loadJson(url) {
//     return fetch(url).then(response => {
//         if (response.status == 200) {
//             return response.json();
//         } else {
//             throw new HttpError(response);
//         }
//     });
// }

// // Запрашивать логин, пока github не вернёт существующего пользователя.
// function demoGithubUser() {
//     let name = prompt("Введите логин?", "iliakan");

//     return loadJson(`https://api.github.com/users/${name}`).then(user => {
//         alert(`Полное имя: ${user.name}.`);
//         return user;
//     })
//         .catch(err => {
//             if (err instanceof HttpError && err.response.status == 404) {
//                 alert("Такого пользователя не существует, пожалуйста, повторите ввод.");
//                 return demoGithubUser();
//             } else {
//                 throw err;
//             }
//         });
// }
// // demoGithubUser();


// // 1. решение
// async function loadJsonAsync(url) {
//     let responce = await fetch(url);

//     if (responce.status == 200) {
//         return responce.json();
//     } else {
//         throw new HttpError(responce);
//     }
// }

// // 2. решение (подсмотрел)
// async function demoGithubUserAsync() {
//     let user;

//     while (true) {
//         let name = prompt('Введите логин', 'iliakan');

//         try {
//             user = await loadJsonAsync(`https://api.github.com/users/${name}`);
//             break; // если ошибок не было - выхожу из цикла
//         } catch (err) {
//             if (err instanceof HttpError && err.response.status == 404) {
//                 // после alert начнётся новая итерация цикла
//                 alert('Нет такого пользователя, повторите ввод');
//             } else {
//                 throw err; // пробрасываю ошибку, если она неизвестна
//             }
//         }
//     }

//     console.log(`Полное имя: ${user.name}`);
//     return user;
// }

// demoGithubUserAsync()
//     .then(console.log);


// Вызовите async–функцию из "обычной"
// Есть «обычная» функция. Как можно внутри неё получить результат выполнения async – функции?

// async function wait() {
//     await new Promise(resolve => setTimeout(resolve, 1000));
//     return 10;
// }

// function f() {
//     let asyncResult;

//     wait().then(result => console.log(result));
// }

// f(); // 10


// Генераторы, продвинутая итерация
// Генераторы могут порождать значения одно за другим, по мере необходимости. Они отлично работают с перебираемыми объектами
// и могут создавать потоки данных.

// Функция-генератор создаётся при помощи специальной конструкции function*, вот как она выглядит:
// function* generator() {
//     yield 1;
//     yield 2;
//     return 3;
// }

// Когда такая функция вызвана, она не выполняет свой код, вместо этого она возвращает специальный объект (генератор) для управления
// её выполнением. Смотрю ниже:
// function* generate() {
//     yield 1;
//     yield 2;
//     return 3;
// }

// let generator = generate();
// console.log(generator); // generate {<suspended>}

// Основным методом генератора является next(). При его вызове он запускает выполнение до ближайшей конструкции yield, затем
// выполнение кода приостанавливается, и во внешний код возвращается объект с ключами: value (результат yield) и done - статус
// выполнения, когда true - работа функции останавлявается. Если значение yield отсутствует, value : undefined.
// console.log(generator.next()); // {value: 1, done: false}
// console.log(generator.next()); // {value: 2, done: false} - повторный вызов возобновит работу генератора
// console.log(generator.next()); // {value: 3, done: true} - последний вызов (return) завершит работу генератора
// console.log(generator.next()); // {value: undefined, done: true}


// Перебор генераторов
// генераторы можно перебирать через for of
// function* generate() {
//     yield 1;
//     yield 2;
//     return 3;
// }

// let generator = generate();

// for (let value of generator) {
//     console.log(value); // 1 2 (тройки нет) - потому что перебор игнорирует последнее значение, потому что done: true.
// }

// если я хочу получить последнее значение, то должен использовать yield вместо return:
// function* generateAll() {
//     yield 1;
//     yield 2;
//     yield 3;
// }

// let generator2 = generateAll();

// for (let value of generator2) {
//     console.log(value); // 1 2 3
// }

// Поскольку генераторы являются перебираемыми объектами, я могу использовать с ними оператор расширения, вот так:
// function* gen () {
//     yield 1;
//     yield 'sosi';
//     yield true;
// }

// let sequence = [0, ...gen()];
// console.log(sequence); // [0, 1, 'sosi', true]


// Использование генераторов для перебираемых объектов

// вспомню, что такое перебираемый объект
// let range = {
//     from: 0,
//     to: 5,

//     [Symbol.iterator]() {
//         // for..of вызывает этот метод один раз в самом начале
//         // он возвращает перебираемый объект, и далее for..of работает только с ним
//         return {
//             current: this.from,
//             last: this.to,

//             // next() - вызывается при каждой итерации цикла
//             next() {
//                 // нужно вернуть значение как объект {done: ..., value: ...}
//                 if (this.current <= this.last) {
//                     return { done: false, value: this.current++ };
//                 } else {
//                     return { done: true };
//                 }
//             }
//         }
//     }
// };

// console.log('range: ' + [...range]); // range: 0,1,2,3,4,5

// // теперь я могу использовать функцию-генератор для итерации, указав её в Symbol.iterator
// let rangeMod = {
//     from: 0,
//     to: 5,

//     *[Symbol.iterator]() { // - это краткая запись для [Symbol.iterator]: function* ()
//         for (let value = this.from; value <= this.to; value++) {
//             yield value;
//         }
//     }
// };

// console.log('rangeMod: ' + [...rangeMod]); // rangeMod: 0,1,2,3,4,5

// Это работает, потому что генератор возвращает всё то, что ожидает for..of - объект вида {done: ..., value: ...}, а также
// у него есть метод next(). Генераторы были добавлены в язык в том числе для упрощения создания перебираемых объектов.


// Композиция генераторов
// это возможность генераторов, которая позволяет прозрачно встраивать генераторы друг в друга.

// Например, у меня есть функция, генерирующая последовательность чисел
// function* genSequence(start, end) {
//     for (let value = start; value <= end; value++) {
//         yield value;
//     }
// }

// Я могу использовать её для генерации более сложной последовательности:
// сначала цифры 0-9 (с кодами символов 48-57)
// за которыми следуют буквы в верхнем регистре A-Z (коды символов 65-90)
// за которыми следуют уквы алфавита a-z (коды символов 97-122)

// это можно использовать например для генерации паролей, выбирать символы из неё. Но сначала её нужно сгенерировать.

// В обычной функции, чтобы объеденить результаты нескольких функций, мне нужно получать их в переменные и только потом объединять.
// В функциях-генераторах есть синтаксис *yield, который позволяет вкладывать их друг в друга (осуществлять композицию).

// function* generateSequence(start, end) {
//     for (let i = start; i <= end; i++) {
//         yield i;
//     }
// }

// function* generatePassword() {
//     // 0-9
//     yield* generateSequence(48, 57);

//     // A-Z
//     yield* generateSequence(65, 90);

//     //a-z
//     yield* generateSequence(97, 122);

//     // symbols
//     yield* generateSequence(33, 46);
// }

// let str = '';

// for (let code of generatePassword()) {
//     str += String.fromCharCode((code * Math.random()).toFixed(0));
// }

// console.log(str);

// Директива yield* делегирует выполнение другому генератору. Это означает, что yield* gen перебирает генератор gen и прозрачно
// направляет его вывод наружу. Как если бы значения были сгенерированы внешним генератором.


// yield - дорога в обе стороны - дело в том, что эта директива может не только отдавать значения наружу,но и передавать значения
// из внешнего кода в генератор. Чтобы это сделать, нужно вызвать generator.next(arg) с аргументом, и этот аргумент становится
// результатом yield.

// function* gen() {
//     let result = yield '2 + 2 = ?'; // (*)

//     console.log(result)
// }

// let generator = gen();

// let question = generator.next().value; // yield возвращает значение

// generator.next(4); // 4

// внешний код не обязан сразу вызывать next(), ему может потребоваться время - в таком случае генератор подождёт:
// setTimeout(() => generator.next(5), 1e3);

// пример для наглядности
// function* gen() {
//     let ask1 = yield "2 + 2 = ?";
//     alert(ask1); // 4
//     let ask2 = yield "3 * 3 = ?"
//     alert(ask2); // 9
// }

// let generator2 = gen();
// alert(generator2.next().value); // "2 + 2 = ?"
// alert(generator2.next(4).value); // "3 * 3 = ?"
// alert(generator2.next(9).done); // true

// generator.throw
// можно не только передавать значения во внешний код, но и инициировать ошибку. Ошибка - это тоде результат.
// это делается так - generator.throw(err). Пример ниже:
// function* gen() {
//     try {
//         let result = yield '2 + 2 = ?';
//         console.log('Выполнение программы не дойдёт до этой строки, потому что выше возникнет исключение', result);
//     } catch (e) {
//         console.log(e); // покажет ошибку
//     }
// }

// let generator = gen();

// let question = generator.next().value;

// generator.throw(new Error('Ответ не найден внутри программы')); // Error: Ответ не найден внутри программы

// Если ошибку не перехватить, то она, как и раньше - вывалится наружу и "положит" код.


// Задачи после раздела
// Псевжослучайный генератор

// function* pseudoRandom(seed) {
//     let val = seed;

//     while (true) {
//         val = val * 16807 % 2147483647;
//         yield val;
//     }
// }

// let generator = pseudoRandom(1);

// console.log(generator.next().value); // 16807
// console.log(generator.next().value); // 282475249
// console.log(generator.next().value); // 1622650073


// Асинхронные итераторы и генераторы